var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"FCEvReferenceApplication","ref":false,"files":[{"name":"FCEvReferenceApplication.c","type":"source","group":"model","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * FCEvReferenceApplication.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"FCEvReferenceApplication.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"FCEvReferenceApplication_private.h\"\r\n#include \"rt_modd_snf.h\"\r\n#include <math.h>\r\n#include \"rt_powd_snf.h\"\r\n#include \"rt_assert.h\"\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n#include <emmintrin.h>\r\n#include \"norm_7x8GXtWF.h\"\r\n#include \"log2_tqJQ4MCN.h\"\r\n#include \"recomputeBlockDiag_NxbsuIUb.h\"\r\n#include \"xhseqr_f1Jkm75w.h\"\r\n#include \"look1_pbinlcapw.h\"\r\n#include \"FCEvPowertrainController.h\"\r\n#include \"DrivetrainEv.h\"\r\n#include \"FCElectricPlant.h\"\r\n#include \"FCEvReferenceApplication_dt.h\"\r\n\r\n/* user code (top of parameter file) */\r\nconst int_T gblNumToFiles = 0;\r\nconst int_T gblNumFrFiles = 0;\r\nconst int_T gblNumFrWksBlocks = 0;\r\nconst char *gblSlvrJacPatternFileName =\r\n  \"FCEvReferenceApplication_rsim_rtw\\\\FCEvReferenceApplication_Jpattern.mat\";\r\n\r\n/* Root inports information  */\r\nconst int_T gblNumRootInportBlks = 1;\r\nconst int_T gblNumModelInputs = 1;\r\nextern rtInportTUtable *gblInportTUtables;\r\nextern const char *gblInportFileName;\r\nconst int_T gblInportDataTypeIdx[] = { 0 };\r\n\r\nconst int_T gblInportDims[] = { 1, 1 } ;\r\n\r\nconst int_T gblInportComplex[] = { 0 };\r\n\r\nconst int_T gblInportInterpoFlag[] = { 1 };\r\n\r\nconst int_T gblInportContinuous[] = { 0 };\r\n\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n\r\n/* Named constants for Chart: '<S39>/Shift Controller' */\r\n#define FCEvReferenc_IN_NO_ACTIVE_CHILD ((uint8_T)0U)\r\n#define FCEvReferenceApplica_IN_Neutral ((uint8_T)1U)\r\n#define FCEvReferenceApplica_IN_Reverse ((uint8_T)3U)\r\n#define FCEvReferenceApplication_IN_Odd ((uint8_T)2U)\r\n\r\n/* Block signals (default storage) */\r\nB_FCEvReferenceApplication_T FCEvReferenceApplication_B;\r\n\r\n/* Continuous states */\r\nX_FCEvReferenceApplication_T FCEvReferenceApplication_X;\r\n\r\n/* Block states (default storage) */\r\nDW_FCEvReferenceApplication_T FCEvReferenceApplication_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_FCEvReferenceApplication_T FCEvReferenceApplication_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_FCEvReferenceApplication_T FCEvReferenceApplication_Y;\r\n\r\n/* Periodic continuous states */\r\nPeriodicIndX_FCEvReferenceApp_T FCEvReferenceAppli_PeriodicIndX;\r\nPeriodicRngX_FCEvReferenceApp_T FCEvReferenceAppli_PeriodicRngX;\r\n\r\n/* Mass Matrices */\r\nMassMatrix_FCEvReferenceAppli_T FCEvReferenceApplica_MassMatrix;\r\n\r\n/* Parent Simstruct */\r\nstatic SimStruct model_S;\r\nSimStruct *const rtS = &model_S;\r\n\r\n/* Forward declaration for local functions */\r\nstatic void FCEvReferenceApplication_mpower(const real_T a[4], real_T b, real_T\r\n  c[4]);\r\nstatic void FCEvReferenceApplicati_mpower_e(const real_T a[4], real_T b, real_T\r\n  c[4]);\r\nstatic void FCEvReferenceApplication_schur(const real_T A[4], real_T V[4],\r\n  real_T T[4]);\r\nstatic void FCEvReferenceApplication_expm(real_T A[4], real_T F[4]);\r\n\r\n/*\r\n * System initialize for enable system:\r\n *    '<S32>/Pass Through'\r\n *    '<S34>/Pass Through'\r\n */\r\nvoid FCEvReferenceA_PassThrough_Init(real_T rtp_IC,\r\n  B_PassThrough_FCEvReferenceAp_T *localB)\r\n{\r\n  /* SystemInitialize for SignalConversion generated from: '<S33>/u' incorporates:\r\n   *  Outport: '<S33>/y'\r\n   */\r\n  localB->u = rtp_IC;\r\n}\r\n\r\n/*\r\n * Disable for enable system:\r\n *    '<S32>/Pass Through'\r\n *    '<S34>/Pass Through'\r\n */\r\nvoid FCEvReferen_PassThrough_Disable(DW_PassThrough_FCEvReferenceA_T *localDW)\r\n{\r\n  localDW->PassThrough_MODE = false;\r\n}\r\n\r\n/*\r\n * Start for enable system:\r\n *    '<S32>/Pass Through'\r\n *    '<S34>/Pass Through'\r\n */\r\nvoid FCEvReference_PassThrough_Start(SimStruct * const rtS_0,\r\n  DW_PassThrough_FCEvReferenceA_T *localDW)\r\n{\r\n  localDW->PassThrough_MODE = false;\r\n  ssSetBlockStateForSolverChangedAtMajorStep(rtS_0);\r\n}\r\n\r\n/*\r\n * Output and update for enable system:\r\n *    '<S32>/Pass Through'\r\n *    '<S34>/Pass Through'\r\n */\r\nvoid FCEvReferenceApplic_PassThrough(SimStruct * const rtS_2, boolean_T\r\n  rtu_Enable, real_T rtu_u, B_PassThrough_FCEvReferenceAp_T *localB,\r\n  DW_PassThrough_FCEvReferenceA_T *localDW)\r\n{\r\n  /* Outputs for Enabled SubSystem: '<S32>/Pass Through' incorporates:\r\n   *  EnablePort: '<S33>/Enable'\r\n   */\r\n  if (ssIsSampleHit(rtS_2, 1, 0) && ssIsModeUpdateTimeStep(rtS_2)) {\r\n    if (rtu_Enable) {\r\n      if (!localDW->PassThrough_MODE) {\r\n        if (ssGetTaskTime(rtS_2,1) != ssGetTStart(rtS_2)) {\r\n          ssSetBlockStateForSolverChangedAtMajorStep(rtS_2);\r\n        }\r\n\r\n        localDW->PassThrough_MODE = true;\r\n      }\r\n    } else if (localDW->PassThrough_MODE) {\r\n      ssSetBlockStateForSolverChangedAtMajorStep(rtS_2);\r\n      FCEvReferen_PassThrough_Disable(localDW);\r\n    }\r\n  }\r\n\r\n  if (localDW->PassThrough_MODE) {\r\n    /* SignalConversion generated from: '<S33>/u' */\r\n    localB->u = rtu_u;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S32>/Pass Through' */\r\n}\r\n\r\n/* Function for MATLAB Function: '<S25>/Setup' */\r\nstatic void FCEvReferenceApplication_mpower(const real_T a[4], real_T b, real_T\r\n  c[4])\r\n{\r\n  real_T aBuffer[4];\r\n  real_T b_a[4];\r\n  real_T cBuffer[4];\r\n  real_T cBuffer_0[4];\r\n  real_T cBuffer_1[4];\r\n  int32_T b_n;\r\n  int32_T nbitson;\r\n  if (b == b) {\r\n    real_T y_tmp;\r\n    int32_T n;\r\n    int32_T nb;\r\n    b_a[0] = a[0];\r\n    b_a[1] = a[1];\r\n    b_a[2] = a[2];\r\n    b_a[3] = a[3];\r\n    y_tmp = fabs(b);\r\n    n = (int32_T)y_tmp;\r\n    b_n = (int32_T)y_tmp;\r\n    nbitson = 0;\r\n    nb = -2;\r\n    while (b_n > 0) {\r\n      nb++;\r\n      if (((uint32_T)b_n & 1U) != 0U) {\r\n        nbitson++;\r\n      }\r\n\r\n      b_n >>= 1;\r\n    }\r\n\r\n    if ((int32_T)y_tmp <= 2) {\r\n      if (b == 2.0) {\r\n        for (b_n = 0; b_n < 2; b_n++) {\r\n          real_T cBuffer_tmp;\r\n          n = b_n << 1;\r\n          c[n] = 0.0;\r\n          y_tmp = a[n];\r\n          c[n] += y_tmp * a[0];\r\n          cBuffer_tmp = a[n + 1];\r\n          c[n] += cBuffer_tmp * a[2];\r\n          c[n + 1] = 0.0;\r\n          c[n + 1] += y_tmp * a[1];\r\n          c[n + 1] += cBuffer_tmp * a[3];\r\n        }\r\n      } else if (b == 1.0) {\r\n        c[0] = a[0];\r\n        c[1] = a[1];\r\n        c[2] = a[2];\r\n        c[3] = a[3];\r\n      } else {\r\n        boolean_T first;\r\n        first = false;\r\n        if (rtIsNaN(a[0]) || rtIsNaN(a[1])) {\r\n          first = true;\r\n        }\r\n\r\n        if (first || rtIsNaN(a[2])) {\r\n          first = true;\r\n        }\r\n\r\n        if (first || rtIsNaN(a[3])) {\r\n          first = true;\r\n        }\r\n\r\n        if (first) {\r\n          c[0] = (rtNaN);\r\n          c[1] = (rtNaN);\r\n          c[2] = (rtNaN);\r\n          c[3] = (rtNaN);\r\n        } else {\r\n          c[1] = 0.0;\r\n          c[2] = 0.0;\r\n          c[0] = 1.0;\r\n          c[3] = 1.0;\r\n        }\r\n      }\r\n    } else {\r\n      boolean_T aBufferInUse;\r\n      boolean_T cBufferInUse;\r\n      boolean_T first;\r\n      first = true;\r\n      aBufferInUse = false;\r\n      cBufferInUse = (((uint32_T)nbitson & 1U) == 0U);\r\n      for (nbitson = 0; nbitson <= nb; nbitson++) {\r\n        __m128d tmp;\r\n        __m128d tmp_0;\r\n        __m128d tmp_1;\r\n        if (((uint32_T)n & 1U) != 0U) {\r\n          if (first) {\r\n            first = false;\r\n            if (cBufferInUse) {\r\n              if (aBufferInUse) {\r\n                cBuffer[0] = aBuffer[0];\r\n                cBuffer[1] = aBuffer[1];\r\n                cBuffer[2] = aBuffer[2];\r\n                cBuffer[3] = aBuffer[3];\r\n              } else {\r\n                cBuffer[0] = b_a[0];\r\n                cBuffer[1] = b_a[1];\r\n                cBuffer[2] = b_a[2];\r\n                cBuffer[3] = b_a[3];\r\n              }\r\n            } else if (aBufferInUse) {\r\n              c[0] = aBuffer[0];\r\n              c[1] = aBuffer[1];\r\n              c[2] = aBuffer[2];\r\n              c[3] = aBuffer[3];\r\n            } else {\r\n              c[0] = b_a[0];\r\n              c[1] = b_a[1];\r\n              c[2] = b_a[2];\r\n              c[3] = b_a[3];\r\n            }\r\n          } else {\r\n            if (aBufferInUse) {\r\n              if (cBufferInUse) {\r\n                for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                  tmp_1 = _mm_set1_pd(0.0);\r\n                  _mm_storeu_pd(&c[b_n], tmp_1);\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                  _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                    (aBuffer[0])), tmp_0));\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                  _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                    (aBuffer[1])), tmp_0));\r\n                  _mm_storeu_pd(&c[b_n + 2], tmp_1);\r\n                  tmp_1 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                  _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n                    _mm_set1_pd(aBuffer[2]))));\r\n                  tmp_1 = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                  _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                    _mm_set1_pd(aBuffer[3])), tmp));\r\n                }\r\n              } else {\r\n                for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                  tmp_1 = _mm_set1_pd(0.0);\r\n                  _mm_storeu_pd(&cBuffer[b_n], tmp_1);\r\n                  tmp = _mm_loadu_pd(&c[b_n]);\r\n                  tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                    _mm_set1_pd(aBuffer[0])), tmp_0));\r\n                  tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                  tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                    _mm_set1_pd(aBuffer[1])), tmp_0));\r\n                  _mm_storeu_pd(&cBuffer[b_n + 2], tmp_1);\r\n                  tmp_1 = _mm_loadu_pd(&c[b_n]);\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd\r\n                    (tmp_1, _mm_set1_pd(aBuffer[2]))));\r\n                  tmp_1 = _mm_loadu_pd(&c[b_n + 2]);\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                    _mm_set1_pd(aBuffer[3])), tmp));\r\n                }\r\n              }\r\n            } else if (cBufferInUse) {\r\n              for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                tmp_1 = _mm_set1_pd(0.0);\r\n                _mm_storeu_pd(&c[b_n], tmp_1);\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n]);\r\n                tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                  (b_a[0])), tmp_0));\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                  (b_a[1])), tmp_0));\r\n                _mm_storeu_pd(&c[b_n + 2], tmp_1);\r\n                tmp_1 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n                  _mm_set1_pd(b_a[2]))));\r\n                tmp_1 = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                  _mm_set1_pd(b_a[3])), tmp));\r\n              }\r\n            } else {\r\n              for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                tmp_1 = _mm_set1_pd(0.0);\r\n                _mm_storeu_pd(&cBuffer[b_n], tmp_1);\r\n                tmp = _mm_loadu_pd(&c[b_n]);\r\n                tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                  _mm_set1_pd(b_a[0])), tmp_0));\r\n                tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                  _mm_set1_pd(b_a[1])), tmp_0));\r\n                _mm_storeu_pd(&cBuffer[b_n + 2], tmp_1);\r\n                tmp_1 = _mm_loadu_pd(&c[b_n]);\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd\r\n                  (tmp_1, _mm_set1_pd(b_a[2]))));\r\n                tmp_1 = _mm_loadu_pd(&c[b_n + 2]);\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                  _mm_set1_pd(b_a[3])), tmp));\r\n              }\r\n            }\r\n\r\n            cBufferInUse = !cBufferInUse;\r\n          }\r\n        }\r\n\r\n        n >>= 1;\r\n        if (aBufferInUse) {\r\n          for (b_n = 0; b_n <= 0; b_n += 2) {\r\n            tmp_1 = _mm_set1_pd(0.0);\r\n            _mm_storeu_pd(&b_a[b_n], tmp_1);\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n]);\r\n            tmp_0 = _mm_loadu_pd(&b_a[b_n]);\r\n            _mm_storeu_pd(&b_a[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (aBuffer[0])), tmp_0));\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            tmp_0 = _mm_loadu_pd(&b_a[b_n]);\r\n            _mm_storeu_pd(&b_a[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (aBuffer[1])), tmp_0));\r\n            _mm_storeu_pd(&b_a[b_n + 2], tmp_1);\r\n            tmp_1 = _mm_loadu_pd(&aBuffer[b_n]);\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            _mm_storeu_pd(&b_a[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(aBuffer[2]))));\r\n            tmp_1 = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            _mm_storeu_pd(&b_a[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(aBuffer[3])), tmp));\r\n          }\r\n        } else {\r\n          for (b_n = 0; b_n <= 0; b_n += 2) {\r\n            tmp_1 = _mm_set1_pd(0.0);\r\n            _mm_storeu_pd(&aBuffer[b_n], tmp_1);\r\n            tmp = _mm_loadu_pd(&b_a[b_n]);\r\n            tmp_0 = _mm_loadu_pd(&aBuffer[b_n]);\r\n            _mm_storeu_pd(&aBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (b_a[0])), tmp_0));\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            tmp_0 = _mm_loadu_pd(&aBuffer[b_n]);\r\n            _mm_storeu_pd(&aBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (b_a[1])), tmp_0));\r\n            _mm_storeu_pd(&aBuffer[b_n + 2], tmp_1);\r\n            tmp_1 = _mm_loadu_pd(&b_a[b_n]);\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            _mm_storeu_pd(&aBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(b_a[2]))));\r\n            tmp_1 = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            _mm_storeu_pd(&aBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(b_a[3])), tmp));\r\n          }\r\n        }\r\n\r\n        aBufferInUse = !aBufferInUse;\r\n      }\r\n\r\n      for (b_n = 0; b_n < 2; b_n++) {\r\n        real_T cBuffer_tmp;\r\n        real_T cBuffer_tmp_0;\r\n        real_T cBuffer_tmp_1;\r\n        n = b_n << 1;\r\n        cBuffer_0[n] = 0.0;\r\n        cBuffer_1[n] = 0.0;\r\n        y_tmp = aBuffer[n];\r\n        cBuffer_0[n] += y_tmp * cBuffer[0];\r\n        cBuffer_tmp = b_a[n];\r\n        cBuffer_1[n] += cBuffer_tmp * cBuffer[0];\r\n        cBuffer_tmp_0 = aBuffer[n + 1];\r\n        cBuffer_0[n] += cBuffer_tmp_0 * cBuffer[2];\r\n        cBuffer_tmp_1 = b_a[n + 1];\r\n        cBuffer_1[n] += cBuffer_tmp_1 * cBuffer[2];\r\n        cBuffer_0[n + 1] = 0.0;\r\n        cBuffer_1[n + 1] = 0.0;\r\n        cBuffer_0[n + 1] += y_tmp * cBuffer[1];\r\n        cBuffer_1[n + 1] += cBuffer_tmp * cBuffer[1];\r\n        cBuffer_0[n + 1] += cBuffer_tmp_0 * cBuffer[3];\r\n        cBuffer_1[n + 1] += cBuffer_tmp_1 * cBuffer[3];\r\n      }\r\n\r\n      if (first) {\r\n        if (aBufferInUse) {\r\n          c[0] = aBuffer[0];\r\n          c[1] = aBuffer[1];\r\n          c[2] = aBuffer[2];\r\n          c[3] = aBuffer[3];\r\n        } else {\r\n          c[0] = b_a[0];\r\n          c[1] = b_a[1];\r\n          c[2] = b_a[2];\r\n          c[3] = b_a[3];\r\n        }\r\n      } else if (aBufferInUse) {\r\n        c[0] = cBuffer_0[0];\r\n        c[1] = cBuffer_0[1];\r\n        c[2] = cBuffer_0[2];\r\n        c[3] = cBuffer_0[3];\r\n      } else {\r\n        c[0] = cBuffer_1[0];\r\n        c[1] = cBuffer_1[1];\r\n        c[2] = cBuffer_1[2];\r\n        c[3] = cBuffer_1[3];\r\n      }\r\n    }\r\n  } else {\r\n    c[0] = (rtNaN);\r\n    c[1] = (rtNaN);\r\n    c[2] = (rtNaN);\r\n    c[3] = (rtNaN);\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nstatic void FCEvReferenceApplicati_mpower_e(const real_T a[4], real_T b, real_T\r\n  c[4])\r\n{\r\n  real_T aBuffer[4];\r\n  real_T b_a[4];\r\n  real_T cBuffer[4];\r\n  real_T cBuffer_0[4];\r\n  real_T cBuffer_1[4];\r\n  real_T e;\r\n  int32_T b_n;\r\n  int32_T nbitson;\r\n  e = fabs(b);\r\n  if (e <= 2.147483647E+9) {\r\n    int32_T n;\r\n    int32_T nb;\r\n    b_a[0] = a[0];\r\n    b_a[1] = a[1];\r\n    b_a[2] = a[2];\r\n    b_a[3] = a[3];\r\n    n = (int32_T)e;\r\n    b_n = (int32_T)e;\r\n    nbitson = 0;\r\n    nb = -2;\r\n    while (b_n > 0) {\r\n      nb++;\r\n      if (((uint32_T)b_n & 1U) != 0U) {\r\n        nbitson++;\r\n      }\r\n\r\n      b_n >>= 1;\r\n    }\r\n\r\n    if ((int32_T)e <= 2) {\r\n      if (b == 2.0) {\r\n        for (b_n = 0; b_n < 2; b_n++) {\r\n          real_T ed2;\r\n          n = b_n << 1;\r\n          c[n] = 0.0;\r\n          e = a[n];\r\n          c[n] += e * a[0];\r\n          ed2 = a[n + 1];\r\n          c[n] += ed2 * a[2];\r\n          c[n + 1] = 0.0;\r\n          c[n + 1] += e * a[1];\r\n          c[n + 1] += ed2 * a[3];\r\n        }\r\n      } else {\r\n        boolean_T firstmult;\r\n        firstmult = false;\r\n        if (rtIsNaN(a[0]) || rtIsNaN(a[1])) {\r\n          firstmult = true;\r\n        }\r\n\r\n        if (firstmult || rtIsNaN(a[2])) {\r\n          firstmult = true;\r\n        }\r\n\r\n        if (firstmult || rtIsNaN(a[3])) {\r\n          firstmult = true;\r\n        }\r\n\r\n        if (firstmult) {\r\n          c[0] = (rtNaN);\r\n          c[1] = (rtNaN);\r\n          c[2] = (rtNaN);\r\n          c[3] = (rtNaN);\r\n        } else {\r\n          c[1] = 0.0;\r\n          c[2] = 0.0;\r\n          c[0] = 1.0;\r\n          c[3] = 1.0;\r\n        }\r\n      }\r\n    } else {\r\n      boolean_T aBufferInUse;\r\n      boolean_T cBufferInUse;\r\n      boolean_T firstmult;\r\n      firstmult = true;\r\n      aBufferInUse = false;\r\n      cBufferInUse = (((uint32_T)nbitson & 1U) == 0U);\r\n      for (nbitson = 0; nbitson <= nb; nbitson++) {\r\n        __m128d tmp;\r\n        __m128d tmp_0;\r\n        __m128d tmp_1;\r\n        if (((uint32_T)n & 1U) != 0U) {\r\n          if (firstmult) {\r\n            firstmult = false;\r\n            if (cBufferInUse) {\r\n              if (aBufferInUse) {\r\n                cBuffer[0] = aBuffer[0];\r\n                cBuffer[1] = aBuffer[1];\r\n                cBuffer[2] = aBuffer[2];\r\n                cBuffer[3] = aBuffer[3];\r\n              } else {\r\n                cBuffer[0] = b_a[0];\r\n                cBuffer[1] = b_a[1];\r\n                cBuffer[2] = b_a[2];\r\n                cBuffer[3] = b_a[3];\r\n              }\r\n            } else if (aBufferInUse) {\r\n              c[0] = aBuffer[0];\r\n              c[1] = aBuffer[1];\r\n              c[2] = aBuffer[2];\r\n              c[3] = aBuffer[3];\r\n            } else {\r\n              c[0] = b_a[0];\r\n              c[1] = b_a[1];\r\n              c[2] = b_a[2];\r\n              c[3] = b_a[3];\r\n            }\r\n          } else {\r\n            if (aBufferInUse) {\r\n              if (cBufferInUse) {\r\n                for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                  tmp_1 = _mm_set1_pd(0.0);\r\n                  _mm_storeu_pd(&c[b_n], tmp_1);\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                  _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                    (aBuffer[0])), tmp_0));\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                  _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                    (aBuffer[1])), tmp_0));\r\n                  _mm_storeu_pd(&c[b_n + 2], tmp_1);\r\n                  tmp_1 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                  _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n                    _mm_set1_pd(aBuffer[2]))));\r\n                  tmp_1 = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                  _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                    _mm_set1_pd(aBuffer[3])), tmp));\r\n                }\r\n              } else {\r\n                for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                  tmp_1 = _mm_set1_pd(0.0);\r\n                  _mm_storeu_pd(&cBuffer[b_n], tmp_1);\r\n                  tmp = _mm_loadu_pd(&c[b_n]);\r\n                  tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                    _mm_set1_pd(aBuffer[0])), tmp_0));\r\n                  tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                  tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                  _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                    _mm_set1_pd(aBuffer[1])), tmp_0));\r\n                  _mm_storeu_pd(&cBuffer[b_n + 2], tmp_1);\r\n                  tmp_1 = _mm_loadu_pd(&c[b_n]);\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd\r\n                    (tmp_1, _mm_set1_pd(aBuffer[2]))));\r\n                  tmp_1 = _mm_loadu_pd(&c[b_n + 2]);\r\n                  tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                  _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                    _mm_set1_pd(aBuffer[3])), tmp));\r\n                }\r\n              }\r\n            } else if (cBufferInUse) {\r\n              for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                tmp_1 = _mm_set1_pd(0.0);\r\n                _mm_storeu_pd(&c[b_n], tmp_1);\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n]);\r\n                tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                  (b_a[0])), tmp_0));\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                tmp_0 = _mm_loadu_pd(&c[b_n]);\r\n                _mm_storeu_pd(&c[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n                  (b_a[1])), tmp_0));\r\n                _mm_storeu_pd(&c[b_n + 2], tmp_1);\r\n                tmp_1 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n                  _mm_set1_pd(b_a[2]))));\r\n                tmp_1 = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                _mm_storeu_pd(&c[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                  _mm_set1_pd(b_a[3])), tmp));\r\n              }\r\n            } else {\r\n              for (b_n = 0; b_n <= 0; b_n += 2) {\r\n                tmp_1 = _mm_set1_pd(0.0);\r\n                _mm_storeu_pd(&cBuffer[b_n], tmp_1);\r\n                tmp = _mm_loadu_pd(&c[b_n]);\r\n                tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                  _mm_set1_pd(b_a[0])), tmp_0));\r\n                tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n                tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n                _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                  _mm_set1_pd(b_a[1])), tmp_0));\r\n                _mm_storeu_pd(&cBuffer[b_n + 2], tmp_1);\r\n                tmp_1 = _mm_loadu_pd(&c[b_n]);\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd\r\n                  (tmp_1, _mm_set1_pd(b_a[2]))));\r\n                tmp_1 = _mm_loadu_pd(&c[b_n + 2]);\r\n                tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n                _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                  _mm_set1_pd(b_a[3])), tmp));\r\n              }\r\n            }\r\n\r\n            cBufferInUse = !cBufferInUse;\r\n          }\r\n        }\r\n\r\n        n >>= 1;\r\n        if (aBufferInUse) {\r\n          for (b_n = 0; b_n <= 0; b_n += 2) {\r\n            tmp_1 = _mm_set1_pd(0.0);\r\n            _mm_storeu_pd(&b_a[b_n], tmp_1);\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n]);\r\n            tmp_0 = _mm_loadu_pd(&b_a[b_n]);\r\n            _mm_storeu_pd(&b_a[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (aBuffer[0])), tmp_0));\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            tmp_0 = _mm_loadu_pd(&b_a[b_n]);\r\n            _mm_storeu_pd(&b_a[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (aBuffer[1])), tmp_0));\r\n            _mm_storeu_pd(&b_a[b_n + 2], tmp_1);\r\n            tmp_1 = _mm_loadu_pd(&aBuffer[b_n]);\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            _mm_storeu_pd(&b_a[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(aBuffer[2]))));\r\n            tmp_1 = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            _mm_storeu_pd(&b_a[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(aBuffer[3])), tmp));\r\n          }\r\n        } else {\r\n          for (b_n = 0; b_n <= 0; b_n += 2) {\r\n            tmp_1 = _mm_set1_pd(0.0);\r\n            _mm_storeu_pd(&aBuffer[b_n], tmp_1);\r\n            tmp = _mm_loadu_pd(&b_a[b_n]);\r\n            tmp_0 = _mm_loadu_pd(&aBuffer[b_n]);\r\n            _mm_storeu_pd(&aBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (b_a[0])), tmp_0));\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            tmp_0 = _mm_loadu_pd(&aBuffer[b_n]);\r\n            _mm_storeu_pd(&aBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (b_a[1])), tmp_0));\r\n            _mm_storeu_pd(&aBuffer[b_n + 2], tmp_1);\r\n            tmp_1 = _mm_loadu_pd(&b_a[b_n]);\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            _mm_storeu_pd(&aBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(b_a[2]))));\r\n            tmp_1 = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            tmp = _mm_loadu_pd(&aBuffer[b_n + 2]);\r\n            _mm_storeu_pd(&aBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(b_a[3])), tmp));\r\n          }\r\n        }\r\n\r\n        aBufferInUse = !aBufferInUse;\r\n      }\r\n\r\n      for (b_n = 0; b_n < 2; b_n++) {\r\n        real_T cBuffer_tmp;\r\n        real_T cBuffer_tmp_0;\r\n        real_T ed2;\r\n        n = b_n << 1;\r\n        cBuffer_0[n] = 0.0;\r\n        cBuffer_1[n] = 0.0;\r\n        e = aBuffer[n];\r\n        cBuffer_0[n] += e * cBuffer[0];\r\n        ed2 = b_a[n];\r\n        cBuffer_1[n] += ed2 * cBuffer[0];\r\n        cBuffer_tmp = aBuffer[n + 1];\r\n        cBuffer_0[n] += cBuffer_tmp * cBuffer[2];\r\n        cBuffer_tmp_0 = b_a[n + 1];\r\n        cBuffer_1[n] += cBuffer_tmp_0 * cBuffer[2];\r\n        cBuffer_0[n + 1] = 0.0;\r\n        cBuffer_1[n + 1] = 0.0;\r\n        cBuffer_0[n + 1] += e * cBuffer[1];\r\n        cBuffer_1[n + 1] += ed2 * cBuffer[1];\r\n        cBuffer_0[n + 1] += cBuffer_tmp * cBuffer[3];\r\n        cBuffer_1[n + 1] += cBuffer_tmp_0 * cBuffer[3];\r\n      }\r\n\r\n      if (firstmult) {\r\n        if (aBufferInUse) {\r\n          c[0] = aBuffer[0];\r\n          c[1] = aBuffer[1];\r\n          c[2] = aBuffer[2];\r\n          c[3] = aBuffer[3];\r\n        } else {\r\n          c[0] = b_a[0];\r\n          c[1] = b_a[1];\r\n          c[2] = b_a[2];\r\n          c[3] = b_a[3];\r\n        }\r\n      } else if (aBufferInUse) {\r\n        c[0] = cBuffer_0[0];\r\n        c[1] = cBuffer_0[1];\r\n        c[2] = cBuffer_0[2];\r\n        c[3] = cBuffer_0[3];\r\n      } else {\r\n        c[0] = cBuffer_1[0];\r\n        c[1] = cBuffer_1[1];\r\n        c[2] = cBuffer_1[2];\r\n        c[3] = cBuffer_1[3];\r\n      }\r\n    }\r\n  } else {\r\n    b_a[0] = a[0];\r\n    b_a[1] = a[1];\r\n    b_a[2] = a[2];\r\n    b_a[3] = a[3];\r\n    if ((!rtIsInf(b)) && (!rtIsNaN(b))) {\r\n      boolean_T firstmult;\r\n      firstmult = true;\r\n      real_T ed2;\r\n      int32_T exitg1;\r\n      do {\r\n        __m128d tmp;\r\n        __m128d tmp_0;\r\n        __m128d tmp_1;\r\n        exitg1 = 0;\r\n        ed2 = floor(e / 2.0);\r\n        if (2.0 * ed2 != e) {\r\n          if (firstmult) {\r\n            c[0] = b_a[0];\r\n            c[1] = b_a[1];\r\n            c[2] = b_a[2];\r\n            c[3] = b_a[3];\r\n            firstmult = false;\r\n          } else {\r\n            for (b_n = 0; b_n <= 0; b_n += 2) {\r\n              tmp_1 = _mm_set1_pd(0.0);\r\n              _mm_storeu_pd(&cBuffer[b_n], tmp_1);\r\n              tmp = _mm_loadu_pd(&c[b_n]);\r\n              tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n              _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                _mm_set1_pd(b_a[0])), tmp_0));\r\n              tmp = _mm_loadu_pd(&c[b_n + 2]);\r\n              tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n              _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp,\r\n                _mm_set1_pd(b_a[1])), tmp_0));\r\n              _mm_storeu_pd(&cBuffer[b_n + 2], tmp_1);\r\n              tmp_1 = _mm_loadu_pd(&c[b_n]);\r\n              tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n              _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n                _mm_set1_pd(b_a[2]))));\r\n              tmp_1 = _mm_loadu_pd(&c[b_n + 2]);\r\n              tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n              _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n                _mm_set1_pd(b_a[3])), tmp));\r\n            }\r\n\r\n            c[0] = cBuffer[0];\r\n            c[1] = cBuffer[1];\r\n            c[2] = cBuffer[2];\r\n            c[3] = cBuffer[3];\r\n          }\r\n        }\r\n\r\n        if (ed2 == 0.0) {\r\n          exitg1 = 1;\r\n        } else {\r\n          e = ed2;\r\n          for (b_n = 0; b_n <= 0; b_n += 2) {\r\n            tmp_1 = _mm_set1_pd(0.0);\r\n            _mm_storeu_pd(&cBuffer[b_n], tmp_1);\r\n            tmp = _mm_loadu_pd(&b_a[b_n]);\r\n            tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n            _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (b_a[0])), tmp_0));\r\n            tmp = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            tmp_0 = _mm_loadu_pd(&cBuffer[b_n]);\r\n            _mm_storeu_pd(&cBuffer[b_n], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd\r\n              (b_a[1])), tmp_0));\r\n            _mm_storeu_pd(&cBuffer[b_n + 2], tmp_1);\r\n            tmp_1 = _mm_loadu_pd(&b_a[b_n]);\r\n            tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n            _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(b_a[2]))));\r\n            tmp_1 = _mm_loadu_pd(&b_a[b_n + 2]);\r\n            tmp = _mm_loadu_pd(&cBuffer[b_n + 2]);\r\n            _mm_storeu_pd(&cBuffer[b_n + 2], _mm_add_pd(_mm_mul_pd(tmp_1,\r\n              _mm_set1_pd(b_a[3])), tmp));\r\n          }\r\n\r\n          b_a[0] = cBuffer[0];\r\n          b_a[1] = cBuffer[1];\r\n          b_a[2] = cBuffer[2];\r\n          b_a[3] = cBuffer[3];\r\n        }\r\n      } while (exitg1 == 0);\r\n    } else {\r\n      c[0] = (rtNaN);\r\n      c[1] = (rtNaN);\r\n      c[2] = (rtNaN);\r\n      c[3] = (rtNaN);\r\n    }\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nstatic void FCEvReferenceApplication_schur(const real_T A[4], real_T V[4],\r\n  real_T T[4])\r\n{\r\n  boolean_T p;\r\n  p = true;\r\n  if (rtIsInf(A[0]) || rtIsNaN(A[0])) {\r\n    p = false;\r\n  }\r\n\r\n  if (p && ((!rtIsInf(A[1])) && (!rtIsNaN(A[1])))) {\r\n  } else {\r\n    p = false;\r\n  }\r\n\r\n  if (p && ((!rtIsInf(A[2])) && (!rtIsNaN(A[2])))) {\r\n  } else {\r\n    p = false;\r\n  }\r\n\r\n  if (p && ((!rtIsInf(A[3])) && (!rtIsNaN(A[3])))) {\r\n  } else {\r\n    p = false;\r\n  }\r\n\r\n  if (!p) {\r\n    V[0] = (rtNaN);\r\n    V[2] = (rtNaN);\r\n    V[3] = (rtNaN);\r\n    V[1] = 0.0;\r\n    T[0] = (rtNaN);\r\n    T[1] = (rtNaN);\r\n    T[2] = (rtNaN);\r\n    T[3] = (rtNaN);\r\n  } else {\r\n    T[0] = A[0];\r\n    T[2] = A[2];\r\n    T[3] = A[3];\r\n    T[1] = A[1];\r\n    V[2] = 0.0;\r\n    V[1] = 0.0;\r\n    V[0] = 1.0;\r\n    V[3] = 1.0;\r\n    xhseqr_f1Jkm75w(T, V);\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nstatic void FCEvReferenceApplication_expm(real_T A[4], real_T F[4])\r\n{\r\n  real_T A2[4];\r\n  real_T A4[4];\r\n  real_T A6[4];\r\n  real_T T[4];\r\n  real_T U[4];\r\n  real_T V[4];\r\n  int32_T blockFormat;\r\n  int32_T i;\r\n  int32_T r2;\r\n  boolean_T recomputeDiags;\r\n  recomputeDiags = true;\r\n  if (rtIsInf(A[0]) || rtIsNaN(A[0])) {\r\n    recomputeDiags = false;\r\n  }\r\n\r\n  if (recomputeDiags && ((!rtIsInf(A[1])) && (!rtIsNaN(A[1])))) {\r\n  } else {\r\n    recomputeDiags = false;\r\n  }\r\n\r\n  if (recomputeDiags && ((!rtIsInf(A[2])) && (!rtIsNaN(A[2])))) {\r\n  } else {\r\n    recomputeDiags = false;\r\n  }\r\n\r\n  if (recomputeDiags && ((!rtIsInf(A[3])) && (!rtIsNaN(A[3])))) {\r\n  } else {\r\n    recomputeDiags = false;\r\n  }\r\n\r\n  if (!recomputeDiags) {\r\n    F[0] = (rtNaN);\r\n    F[1] = (rtNaN);\r\n    F[2] = (rtNaN);\r\n    F[3] = (rtNaN);\r\n  } else {\r\n    int32_T exitg1;\r\n    int32_T r1;\r\n    boolean_T exitg2;\r\n    r1 = 0;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (r1 < 2)) {\r\n      r2 = 0;\r\n      do {\r\n        exitg1 = 0;\r\n        if (r2 < 2) {\r\n          if ((r2 != r1) && (!(A[(r1 << 1) + r2] == 0.0))) {\r\n            recomputeDiags = false;\r\n            exitg1 = 1;\r\n          } else {\r\n            r2++;\r\n          }\r\n        } else {\r\n          r1++;\r\n          exitg1 = 2;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      if (exitg1 == 1) {\r\n        exitg2 = true;\r\n      }\r\n    }\r\n\r\n    if (recomputeDiags) {\r\n      F[1] = 0.0;\r\n      F[2] = 0.0;\r\n      F[0] = exp(A[0]);\r\n      F[3] = exp(A[3]);\r\n    } else {\r\n      recomputeDiags = true;\r\n      r1 = 0;\r\n      exitg2 = false;\r\n      while ((!exitg2) && (r1 < 2)) {\r\n        r2 = 0;\r\n        do {\r\n          exitg1 = 0;\r\n          if (r2 <= r1) {\r\n            if (!(A[(r1 << 1) + r2] == A[(r2 << 1) + r1])) {\r\n              recomputeDiags = false;\r\n              exitg1 = 1;\r\n            } else {\r\n              r2++;\r\n            }\r\n          } else {\r\n            r1++;\r\n            exitg1 = 2;\r\n          }\r\n        } while (exitg1 == 0);\r\n\r\n        if (exitg1 == 1) {\r\n          exitg2 = true;\r\n        }\r\n      }\r\n\r\n      if (recomputeDiags) {\r\n        real_T exptj;\r\n        FCEvReferenceApplication_schur(A, U, T);\r\n        exptj = exp(T[0]);\r\n        V[0] = U[0] * exptj;\r\n        V[1] = U[1] * exptj;\r\n        exptj = exp(T[3]);\r\n        V[2] = U[2] * exptj;\r\n        V[3] = U[3] * exptj;\r\n        for (i = 0; i <= 0; i += 2) {\r\n          __m128d tmp;\r\n          __m128d tmp_4;\r\n          __m128d tmp_5;\r\n          tmp_4 = _mm_set1_pd(0.0);\r\n          _mm_storeu_pd(&F[i], tmp_4);\r\n          tmp = _mm_loadu_pd(&V[i]);\r\n          tmp_5 = _mm_loadu_pd(&F[i]);\r\n          _mm_storeu_pd(&F[i], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd(U[0])),\r\n            tmp_5));\r\n          tmp = _mm_loadu_pd(&V[i + 2]);\r\n          tmp_5 = _mm_loadu_pd(&F[i]);\r\n          _mm_storeu_pd(&F[i], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd(U[2])),\r\n            tmp_5));\r\n          _mm_storeu_pd(&F[i + 2], tmp_4);\r\n          tmp_4 = _mm_loadu_pd(&V[i]);\r\n          tmp = _mm_loadu_pd(&F[i + 2]);\r\n          _mm_storeu_pd(&F[i + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_4, _mm_set1_pd\r\n            (U[1]))));\r\n          tmp_4 = _mm_loadu_pd(&V[i + 2]);\r\n          tmp = _mm_loadu_pd(&F[i + 2]);\r\n          _mm_storeu_pd(&F[i + 2], _mm_add_pd(_mm_mul_pd(tmp_4, _mm_set1_pd(U[3])),\r\n            tmp));\r\n        }\r\n\r\n        exptj = (F[1] + F[2]) / 2.0;\r\n        F[3] = (F[3] + F[3]) / 2.0;\r\n        F[0] = (F[0] + F[0]) / 2.0;\r\n        F[1] = exptj;\r\n        F[2] = exptj;\r\n      } else {\r\n        __m128d tmp;\r\n        __m128d tmp_4;\r\n        __m128d tmp_5;\r\n        real_T A4_tmp;\r\n        real_T A6_idx_3;\r\n        real_T d6;\r\n        real_T eta1;\r\n        real_T exptj;\r\n        boolean_T guard1 = false;\r\n        boolean_T guard2 = false;\r\n        boolean_T guard3 = false;\r\n        boolean_T guard4 = false;\r\n        recomputeDiags = true;\r\n        if (A[1] != 0.0) {\r\n          if (A[0] != A[3]) {\r\n            recomputeDiags = false;\r\n          } else {\r\n            if (rtIsNaN(A[1])) {\r\n              exptj = (rtNaN);\r\n            } else if (A[1] < 0.0) {\r\n              exptj = -1.0;\r\n            } else {\r\n              exptj = (A[1] > 0.0);\r\n            }\r\n\r\n            if (rtIsNaN(A[2])) {\r\n              d6 = (rtNaN);\r\n            } else if (A[2] < 0.0) {\r\n              d6 = -1.0;\r\n            } else {\r\n              d6 = (A[2] > 0.0);\r\n            }\r\n\r\n            if (exptj * d6 != -1.0) {\r\n              recomputeDiags = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        exptj = 0.0;\r\n        for (i = 0; i < 2; i++) {\r\n          r1 = i << 1;\r\n          A2[r1] = 0.0;\r\n          d6 = A[r1];\r\n          A2[r1] += d6 * A[0];\r\n          eta1 = A[r1 + 1];\r\n          A2[r1] += eta1 * A[2];\r\n          A2[r1 + 1] = 0.0;\r\n          A2[r1 + 1] += d6 * A[1];\r\n          A2[r1 + 1] += eta1 * A[3];\r\n        }\r\n\r\n        for (i = 0; i <= 0; i += 2) {\r\n          __m128d tmp_0;\r\n          __m128d tmp_1;\r\n          __m128d tmp_2;\r\n          __m128d tmp_3;\r\n          tmp_4 = _mm_set1_pd(0.0);\r\n          _mm_storeu_pd(&A4[i], tmp_4);\r\n          tmp = _mm_loadu_pd(&A2[i]);\r\n          tmp_5 = _mm_set1_pd(A2[0]);\r\n          tmp_0 = _mm_loadu_pd(&A4[i]);\r\n          _mm_storeu_pd(&A4[i], _mm_add_pd(_mm_mul_pd(tmp, tmp_5), tmp_0));\r\n          tmp = _mm_loadu_pd(&A2[i + 2]);\r\n          tmp_0 = _mm_set1_pd(A2[1]);\r\n          tmp_1 = _mm_loadu_pd(&A4[i]);\r\n          _mm_storeu_pd(&A4[i], _mm_add_pd(_mm_mul_pd(tmp, tmp_0), tmp_1));\r\n          _mm_storeu_pd(&A4[i + 2], tmp_4);\r\n          tmp = _mm_loadu_pd(&A2[i]);\r\n          tmp_1 = _mm_set1_pd(A2[2]);\r\n          tmp_2 = _mm_loadu_pd(&A4[i + 2]);\r\n          _mm_storeu_pd(&A4[i + 2], _mm_add_pd(tmp_2, _mm_mul_pd(tmp, tmp_1)));\r\n          tmp = _mm_loadu_pd(&A2[i + 2]);\r\n          tmp_2 = _mm_set1_pd(A2[3]);\r\n          tmp_3 = _mm_loadu_pd(&A4[i + 2]);\r\n          _mm_storeu_pd(&A4[i + 2], _mm_add_pd(_mm_mul_pd(tmp, tmp_2), tmp_3));\r\n          _mm_storeu_pd(&A6[i], tmp_4);\r\n          tmp = _mm_loadu_pd(&A4[i]);\r\n          tmp_3 = _mm_loadu_pd(&A6[i]);\r\n          _mm_storeu_pd(&A6[i], _mm_add_pd(_mm_mul_pd(tmp, tmp_5), tmp_3));\r\n          tmp = _mm_loadu_pd(&A4[i + 2]);\r\n          tmp_5 = _mm_loadu_pd(&A6[i]);\r\n          _mm_storeu_pd(&A6[i], _mm_add_pd(_mm_mul_pd(tmp, tmp_0), tmp_5));\r\n          _mm_storeu_pd(&A6[i + 2], tmp_4);\r\n          tmp_4 = _mm_loadu_pd(&A4[i]);\r\n          tmp = _mm_loadu_pd(&A6[i + 2]);\r\n          _mm_storeu_pd(&A6[i + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_4, tmp_1)));\r\n          tmp_4 = _mm_loadu_pd(&A4[i + 2]);\r\n          tmp = _mm_loadu_pd(&A6[i + 2]);\r\n          _mm_storeu_pd(&A6[i + 2], _mm_add_pd(_mm_mul_pd(tmp_4, tmp_2), tmp));\r\n        }\r\n\r\n        d6 = rt_powd_snf(norm_7x8GXtWF(A6), 0.16666666666666666);\r\n        eta1 = fmax(rt_powd_snf(norm_7x8GXtWF(A4), 0.25), d6);\r\n        guard1 = false;\r\n        guard2 = false;\r\n        guard3 = false;\r\n        guard4 = false;\r\n        if (eta1 <= 0.01495585217958292) {\r\n          V[0] = 0.19285012468241128 * fabs(A[0]);\r\n          V[1] = 0.19285012468241128 * fabs(A[1]);\r\n          V[2] = 0.19285012468241128 * fabs(A[2]);\r\n          V[3] = 0.19285012468241128 * fabs(A[3]);\r\n          FCEvReferenceApplicati_mpower_e(V, 7.0, U);\r\n          if (fmax(ceil(log2_tqJQ4MCN(norm_7x8GXtWF(U) / norm_7x8GXtWF(A) * 2.0 /\r\n                 2.2204460492503131E-16) / 6.0), 0.0) == 0.0) {\r\n            r1 = 3;\r\n          } else {\r\n            guard4 = true;\r\n          }\r\n        } else {\r\n          guard4 = true;\r\n        }\r\n\r\n        if (guard4) {\r\n          if (eta1 <= 0.253939833006323) {\r\n            V[0] = 0.12321872304378752 * fabs(A[0]);\r\n            V[1] = 0.12321872304378752 * fabs(A[1]);\r\n            V[2] = 0.12321872304378752 * fabs(A[2]);\r\n            V[3] = 0.12321872304378752 * fabs(A[3]);\r\n            FCEvReferenceApplicati_mpower_e(V, 11.0, U);\r\n            if (fmax(ceil(log2_tqJQ4MCN(norm_7x8GXtWF(U) / norm_7x8GXtWF(A) *\r\n                   2.0 / 2.2204460492503131E-16) / 10.0), 0.0) == 0.0) {\r\n              r1 = 5;\r\n            } else {\r\n              guard3 = true;\r\n            }\r\n          } else {\r\n            guard3 = true;\r\n          }\r\n        }\r\n\r\n        if (guard3) {\r\n          FCEvReferenceApplicati_mpower_e(A4, 2.0, U);\r\n          eta1 = rt_powd_snf(norm_7x8GXtWF(U), 0.125);\r\n          d6 = fmax(d6, eta1);\r\n          if (d6 <= 0.95041789961629319) {\r\n            V[0] = 0.090475336558796943 * fabs(A[0]);\r\n            V[1] = 0.090475336558796943 * fabs(A[1]);\r\n            V[2] = 0.090475336558796943 * fabs(A[2]);\r\n            V[3] = 0.090475336558796943 * fabs(A[3]);\r\n            FCEvReferenceApplicati_mpower_e(V, 15.0, U);\r\n            if (fmax(ceil(log2_tqJQ4MCN(norm_7x8GXtWF(U) / norm_7x8GXtWF(A) *\r\n                   2.0 / 2.2204460492503131E-16) / 14.0), 0.0) == 0.0) {\r\n              r1 = 7;\r\n            } else {\r\n              guard2 = true;\r\n            }\r\n          } else {\r\n            guard2 = true;\r\n          }\r\n        }\r\n\r\n        if (guard2) {\r\n          if (d6 <= 2.097847961257068) {\r\n            V[0] = 0.071467735648795785 * fabs(A[0]);\r\n            V[1] = 0.071467735648795785 * fabs(A[1]);\r\n            V[2] = 0.071467735648795785 * fabs(A[2]);\r\n            V[3] = 0.071467735648795785 * fabs(A[3]);\r\n            FCEvReferenceApplicati_mpower_e(V, 19.0, U);\r\n            if (fmax(ceil(log2_tqJQ4MCN(norm_7x8GXtWF(U) / norm_7x8GXtWF(A) *\r\n                   2.0 / 2.2204460492503131E-16) / 18.0), 0.0) == 0.0) {\r\n              r1 = 9;\r\n            } else {\r\n              guard1 = true;\r\n            }\r\n          } else {\r\n            guard1 = true;\r\n          }\r\n        }\r\n\r\n        if (guard1) {\r\n          for (i = 0; i < 2; i++) {\r\n            r1 = i << 1;\r\n            V[r1] = 0.0;\r\n            exptj = A6[r1];\r\n            V[r1] += exptj * A4[0];\r\n            A4_tmp = A6[r1 + 1];\r\n            V[r1] += A4_tmp * A4[2];\r\n            V[r1 + 1] = 0.0;\r\n            V[r1 + 1] += exptj * A4[1];\r\n            V[r1 + 1] += A4_tmp * A4[3];\r\n          }\r\n\r\n          exptj = fmax(ceil(log2_tqJQ4MCN(fmin(d6, fmax(eta1, rt_powd_snf\r\n            (norm_7x8GXtWF(V), 0.1))) / 5.3719203511481517)), 0.0);\r\n          d6 = rt_powd_snf(2.0, exptj);\r\n          eta1 = A[0] / d6;\r\n          V[0] = 0.05031554467093536 * fabs(eta1);\r\n          T[0] = eta1;\r\n          eta1 = A[1] / d6;\r\n          V[1] = 0.05031554467093536 * fabs(eta1);\r\n          T[1] = eta1;\r\n          eta1 = A[2] / d6;\r\n          V[2] = 0.05031554467093536 * fabs(eta1);\r\n          T[2] = eta1;\r\n          eta1 = A[3] / d6;\r\n          V[3] = 0.05031554467093536 * fabs(eta1);\r\n          T[3] = eta1;\r\n          FCEvReferenceApplicati_mpower_e(V, 27.0, U);\r\n          exptj += fmax(ceil(log2_tqJQ4MCN(norm_7x8GXtWF(U) / norm_7x8GXtWF(T) *\r\n            2.0 / 2.2204460492503131E-16) / 26.0), 0.0);\r\n          if (rtIsInf(exptj)) {\r\n            d6 = norm_7x8GXtWF(A) / 5.3719203511481517;\r\n            if ((!rtIsInf(d6)) && (!rtIsNaN(d6))) {\r\n              d6 = frexp(d6, &blockFormat);\r\n            } else {\r\n              blockFormat = 0;\r\n            }\r\n\r\n            exptj = blockFormat;\r\n            if (d6 == 0.5) {\r\n              exptj = (real_T)blockFormat - 1.0;\r\n            }\r\n          }\r\n\r\n          r1 = 13;\r\n        }\r\n\r\n        if (exptj != 0.0) {\r\n          d6 = rt_powd_snf(2.0, exptj);\r\n          A[0] /= d6;\r\n          A[1] /= d6;\r\n          A[2] /= d6;\r\n          A[3] /= d6;\r\n          d6 = rt_powd_snf(2.0, 2.0 * exptj);\r\n          A2[0] /= d6;\r\n          A2[1] /= d6;\r\n          A2[2] /= d6;\r\n          A2[3] /= d6;\r\n          d6 = rt_powd_snf(2.0, 4.0 * exptj);\r\n          A4[0] /= d6;\r\n          A4[1] /= d6;\r\n          A4[2] /= d6;\r\n          A4[3] /= d6;\r\n          d6 = rt_powd_snf(2.0, 6.0 * exptj);\r\n          A6[0] /= d6;\r\n          A6[1] /= d6;\r\n          A6[2] /= d6;\r\n          A6[3] /= d6;\r\n        }\r\n\r\n        if (recomputeDiags) {\r\n          if (A[1] == 0.0) {\r\n            blockFormat = 1;\r\n          } else {\r\n            blockFormat = 2;\r\n          }\r\n        }\r\n\r\n        if (r1 == 3) {\r\n          U[1] = A2[1];\r\n          U[2] = A2[2];\r\n          U[0] = A2[0] + 60.0;\r\n          U[3] = A2[3] + 60.0;\r\n          for (i = 0; i < 2; i++) {\r\n            r1 = i << 1;\r\n            T[r1] = 0.0;\r\n            d6 = U[r1];\r\n            T[r1] += d6 * A[0];\r\n            eta1 = U[r1 + 1];\r\n            T[r1] += eta1 * A[2];\r\n            T[r1 + 1] = 0.0;\r\n            T[r1 + 1] += d6 * A[1];\r\n            T[r1 + 1] += eta1 * A[3];\r\n          }\r\n\r\n          U[0] = T[0];\r\n          V[0] = 12.0 * A2[0];\r\n          U[1] = T[1];\r\n          V[1] = 12.0 * A2[1];\r\n          U[2] = T[2];\r\n          V[2] = 12.0 * A2[2];\r\n          U[3] = T[3];\r\n          V[3] = 12.0 * A2[3];\r\n          d6 = 120.0;\r\n        } else if (r1 == 5) {\r\n          U[0] = 420.0 * A2[0] + A4[0];\r\n          U[1] = 420.0 * A2[1] + A4[1];\r\n          U[2] = 420.0 * A2[2] + A4[2];\r\n          U[3] = 420.0 * A2[3] + A4[3];\r\n          U[0] += 15120.0;\r\n          U[3] += 15120.0;\r\n          for (i = 0; i < 2; i++) {\r\n            r1 = i << 1;\r\n            T[r1] = 0.0;\r\n            d6 = U[r1];\r\n            T[r1] += d6 * A[0];\r\n            eta1 = U[r1 + 1];\r\n            T[r1] += eta1 * A[2];\r\n            T[r1 + 1] = 0.0;\r\n            T[r1 + 1] += d6 * A[1];\r\n            T[r1 + 1] += eta1 * A[3];\r\n          }\r\n\r\n          U[0] = T[0];\r\n          V[0] = 30.0 * A4[0] + 3360.0 * A2[0];\r\n          U[1] = T[1];\r\n          V[1] = 30.0 * A4[1] + 3360.0 * A2[1];\r\n          U[2] = T[2];\r\n          V[2] = 30.0 * A4[2] + 3360.0 * A2[2];\r\n          U[3] = T[3];\r\n          V[3] = 30.0 * A4[3] + 3360.0 * A2[3];\r\n          d6 = 30240.0;\r\n        } else if (r1 == 7) {\r\n          U[0] = (1512.0 * A4[0] + A6[0]) + 277200.0 * A2[0];\r\n          U[1] = (1512.0 * A4[1] + A6[1]) + 277200.0 * A2[1];\r\n          U[2] = (1512.0 * A4[2] + A6[2]) + 277200.0 * A2[2];\r\n          U[3] = (1512.0 * A4[3] + A6[3]) + 277200.0 * A2[3];\r\n          U[0] += 8.64864E+6;\r\n          U[3] += 8.64864E+6;\r\n          for (i = 0; i < 2; i++) {\r\n            r1 = i << 1;\r\n            T[r1] = 0.0;\r\n            d6 = U[r1];\r\n            T[r1] += d6 * A[0];\r\n            eta1 = U[r1 + 1];\r\n            T[r1] += eta1 * A[2];\r\n            T[r1 + 1] = 0.0;\r\n            T[r1 + 1] += d6 * A[1];\r\n            T[r1 + 1] += eta1 * A[3];\r\n          }\r\n\r\n          U[0] = T[0];\r\n          V[0] = (56.0 * A6[0] + 25200.0 * A4[0]) + 1.99584E+6 * A2[0];\r\n          U[1] = T[1];\r\n          V[1] = (56.0 * A6[1] + 25200.0 * A4[1]) + 1.99584E+6 * A2[1];\r\n          U[2] = T[2];\r\n          V[2] = (56.0 * A6[2] + 25200.0 * A4[2]) + 1.99584E+6 * A2[2];\r\n          U[3] = T[3];\r\n          V[3] = (56.0 * A6[3] + 25200.0 * A4[3]) + 1.99584E+6 * A2[3];\r\n          d6 = 1.729728E+7;\r\n        } else if (r1 == 9) {\r\n          for (i = 0; i < 2; i++) {\r\n            real_T U_tmp;\r\n            r1 = i << 1;\r\n            V[r1] = 0.0;\r\n            U_tmp = A2[r1];\r\n            V[r1] += U_tmp * A6[0];\r\n            d6 = A2[r1 + 1];\r\n            V[r1] += d6 * A6[2];\r\n            V[r1 + 1] = 0.0;\r\n            V[r1 + 1] += U_tmp * A6[1];\r\n            V[r1 + 1] += d6 * A6[3];\r\n          }\r\n\r\n          U[0] = ((3960.0 * A6[0] + V[0]) + 2.16216E+6 * A4[0]) + 3.027024E+8 *\r\n            A2[0];\r\n          U[1] = ((3960.0 * A6[1] + V[1]) + 2.16216E+6 * A4[1]) + 3.027024E+8 *\r\n            A2[1];\r\n          U[2] = ((3960.0 * A6[2] + V[2]) + 2.16216E+6 * A4[2]) + 3.027024E+8 *\r\n            A2[2];\r\n          U[3] = ((3960.0 * A6[3] + V[3]) + 2.16216E+6 * A4[3]) + 3.027024E+8 *\r\n            A2[3];\r\n          U[0] += 8.8216128E+9;\r\n          U[3] += 8.8216128E+9;\r\n          for (i = 0; i < 2; i++) {\r\n            r1 = i << 1;\r\n            T[r1] = 0.0;\r\n            d6 = U[r1];\r\n            T[r1] += d6 * A[0];\r\n            eta1 = U[r1 + 1];\r\n            T[r1] += eta1 * A[2];\r\n            T[r1 + 1] = 0.0;\r\n            T[r1 + 1] += d6 * A[1];\r\n            T[r1 + 1] += eta1 * A[3];\r\n          }\r\n\r\n          U[0] = T[0];\r\n          V[0] = ((90.0 * V[0] + 110880.0 * A6[0]) + 3.027024E+7 * A4[0]) +\r\n            2.0756736E+9 * A2[0];\r\n          U[1] = T[1];\r\n          V[1] = ((90.0 * V[1] + 110880.0 * A6[1]) + 3.027024E+7 * A4[1]) +\r\n            2.0756736E+9 * A2[1];\r\n          U[2] = T[2];\r\n          V[2] = ((90.0 * V[2] + 110880.0 * A6[2]) + 3.027024E+7 * A4[2]) +\r\n            2.0756736E+9 * A2[2];\r\n          U[3] = T[3];\r\n          V[3] = ((90.0 * V[3] + 110880.0 * A6[3]) + 3.027024E+7 * A4[3]) +\r\n            2.0756736E+9 * A2[3];\r\n          d6 = 1.76432256E+10;\r\n        } else {\r\n          U[0] = (3.352212864E+10 * A6[0] + 1.05594705216E+13 * A4[0]) +\r\n            1.1873537964288E+15 * A2[0];\r\n          U[1] = (3.352212864E+10 * A6[1] + 1.05594705216E+13 * A4[1]) +\r\n            1.1873537964288E+15 * A2[1];\r\n          U[2] = (3.352212864E+10 * A6[2] + 1.05594705216E+13 * A4[2]) +\r\n            1.1873537964288E+15 * A2[2];\r\n          U[3] = (3.352212864E+10 * A6[3] + 1.05594705216E+13 * A4[3]) +\r\n            1.1873537964288E+15 * A2[3];\r\n          U[0] += 3.238237626624E+16;\r\n          U[3] += 3.238237626624E+16;\r\n          d6 = (16380.0 * A4[0] + A6[0]) + 4.08408E+7 * A2[0];\r\n          eta1 = (16380.0 * A4[1] + A6[1]) + 4.08408E+7 * A2[1];\r\n          A4_tmp = (16380.0 * A4[2] + A6[2]) + 4.08408E+7 * A2[2];\r\n          A6_idx_3 = (16380.0 * A4[3] + A6[3]) + 4.08408E+7 * A2[3];\r\n          for (i = 0; i <= 0; i += 2) {\r\n            tmp_4 = _mm_loadu_pd(&A6[i + 2]);\r\n            tmp = _mm_loadu_pd(&A6[i]);\r\n            tmp_5 = _mm_loadu_pd(&U[i]);\r\n            _mm_storeu_pd(&T[i], _mm_add_pd(_mm_add_pd(_mm_mul_pd(tmp_4,\r\n              _mm_set1_pd(eta1)), _mm_mul_pd(tmp, _mm_set1_pd(d6))), tmp_5));\r\n            tmp_4 = _mm_loadu_pd(&A6[i + 2]);\r\n            tmp = _mm_loadu_pd(&A6[i]);\r\n            tmp_5 = _mm_loadu_pd(&U[i + 2]);\r\n            _mm_storeu_pd(&T[i + 2], _mm_add_pd(_mm_add_pd(_mm_mul_pd(tmp_4,\r\n              _mm_set1_pd(A6_idx_3)), _mm_mul_pd(tmp, _mm_set1_pd(A4_tmp))),\r\n              tmp_5));\r\n          }\r\n\r\n          d6 = (182.0 * A6[0] + 960960.0 * A4[0]) + 1.32324192E+9 * A2[0];\r\n          eta1 = (182.0 * A6[1] + 960960.0 * A4[1]) + 1.32324192E+9 * A2[1];\r\n          A4_tmp = (182.0 * A6[2] + 960960.0 * A4[2]) + 1.32324192E+9 * A2[2];\r\n          A6_idx_3 = (182.0 * A6[3] + 960960.0 * A4[3]) + 1.32324192E+9 * A2[3];\r\n          for (i = 0; i < 2; i++) {\r\n            real_T U_tmp;\r\n            real_T U_tmp_0;\r\n            r1 = i << 1;\r\n            U[r1] = 0.0;\r\n            U_tmp = T[r1];\r\n            U[r1] += U_tmp * A[0];\r\n            U_tmp_0 = T[r1 + 1];\r\n            U[r1] += U_tmp_0 * A[2];\r\n            U[r1 + 1] = 0.0;\r\n            U[r1 + 1] += U_tmp * A[1];\r\n            U[r1 + 1] += U_tmp_0 * A[3];\r\n            U_tmp = A6[i + 2];\r\n            V[i] = (((U_tmp * eta1 + A6[i] * d6) + 6.704425728E+11 * A6[i]) +\r\n                    1.29060195264E+14 * A4[i]) + 7.7717703038976E+15 * A2[i];\r\n            V[i + 2] = (((U_tmp * A6_idx_3 + A6[i] * A4_tmp) + U_tmp *\r\n                         6.704425728E+11) + A4[i + 2] * 1.29060195264E+14) +\r\n              A2[i + 2] * 7.7717703038976E+15;\r\n          }\r\n\r\n          d6 = 6.476475253248E+16;\r\n        }\r\n\r\n        V[0] = (V[0] + d6) - U[0];\r\n        U[0] *= 2.0;\r\n        V[1] -= U[1];\r\n        U[1] *= 2.0;\r\n        V[2] -= U[2];\r\n        U[2] *= 2.0;\r\n        V[3] = (V[3] + d6) - U[3];\r\n        U[3] *= 2.0;\r\n        if (fabs(V[1]) > fabs(V[0])) {\r\n          r1 = 1;\r\n          r2 = 0;\r\n        } else {\r\n          r1 = 0;\r\n          r2 = 1;\r\n        }\r\n\r\n        d6 = V[r2] / V[r1];\r\n        A4_tmp = V[r1 + 2];\r\n        eta1 = V[r2 + 2] - A4_tmp * d6;\r\n        F[1] = (U[r2] - U[r1] * d6) / eta1;\r\n        F[0] = (U[r1] - A4_tmp * F[1]) / V[r1];\r\n        A6_idx_3 = U[r1 + 2];\r\n        F[3] = (U[r2 + 2] - A6_idx_3 * d6) / eta1;\r\n        F[2] = (A6_idx_3 - A4_tmp * F[3]) / V[r1];\r\n        F[0]++;\r\n        F[3]++;\r\n        if (recomputeDiags) {\r\n          recomputeBlockDiag_NxbsuIUb(A, F, blockFormat);\r\n        }\r\n\r\n        r1 = (int32_T)exptj;\r\n        for (r2 = 0; r2 < r1; r2++) {\r\n          for (i = 0; i <= 0; i += 2) {\r\n            tmp_4 = _mm_set1_pd(0.0);\r\n            _mm_storeu_pd(&A2[i], tmp_4);\r\n            tmp = _mm_loadu_pd(&F[i]);\r\n            tmp_5 = _mm_loadu_pd(&A2[i]);\r\n            _mm_storeu_pd(&A2[i], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd(F[0])),\r\n              tmp_5));\r\n            tmp = _mm_loadu_pd(&F[i + 2]);\r\n            tmp_5 = _mm_loadu_pd(&A2[i]);\r\n            _mm_storeu_pd(&A2[i], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd(F[1])),\r\n              tmp_5));\r\n            _mm_storeu_pd(&A2[i + 2], tmp_4);\r\n            tmp_4 = _mm_loadu_pd(&F[i]);\r\n            tmp = _mm_loadu_pd(&A2[i + 2]);\r\n            _mm_storeu_pd(&A2[i + 2], _mm_add_pd(tmp, _mm_mul_pd(tmp_4,\r\n              _mm_set1_pd(F[2]))));\r\n            tmp_4 = _mm_loadu_pd(&F[i + 2]);\r\n            tmp = _mm_loadu_pd(&A2[i + 2]);\r\n            _mm_storeu_pd(&A2[i + 2], _mm_add_pd(_mm_mul_pd(tmp_4, _mm_set1_pd\r\n              (F[3])), tmp));\r\n          }\r\n\r\n          F[0] = A2[0];\r\n          F[1] = A2[1];\r\n          F[2] = A2[2];\r\n          F[3] = A2[3];\r\n          if (recomputeDiags) {\r\n            A[0] *= 2.0;\r\n            A[1] *= 2.0;\r\n            A[2] *= 2.0;\r\n            A[3] *= 2.0;\r\n            recomputeBlockDiag_NxbsuIUb(A, F, blockFormat);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* System initialize for root system: '<Root>' */\r\nvoid MdlInitialize(void)\r\n{\r\n  /* InitializeConditions for FirstOrderHold: '<S46>/First Order Hold' */\r\n  FCEvReferenceApplication_DW.Tk = (rtInf);\r\n  FCEvReferenceApplication_DW.Ck =\r\n    FCEvReferenceApplication_P.FirstOrderHold_IniOut;\r\n  FCEvReferenceApplication_DW.Uk = (rtInf);\r\n  FCEvReferenceApplication_DW.Mk = 0.0;\r\n\r\n  /* InitializeConditions for FirstOrderHold: '<S46>/First Order Hold1' */\r\n  FCEvReferenceApplication_DW.Tk_o = (rtInf);\r\n  FCEvReferenceApplication_DW.Ck_d =\r\n    FCEvReferenceApplication_P.FirstOrderHold1_IniOut;\r\n  FCEvReferenceApplication_DW.Uk_j = (rtInf);\r\n  FCEvReferenceApplication_DW.Mk_e = 0.0;\r\n\r\n  /* InitializeConditions for Derivative: '<S6>/Derivative' */\r\n  FCEvReferenceApplication_DW.TimeStampA = (rtInf);\r\n  FCEvReferenceApplication_DW.TimeStampB = (rtInf);\r\n\r\n  /* InitializeConditions for Integrator: '<S27>/Integrator1' */\r\n  FCEvReferenceApplication_X.Integrator1_CSTATE =\r\n    FCEvReferenceApplication_P.Integrator1_IC;\r\n\r\n  /* InitializeConditions for Integrator: '<S38>/Integrator2' */\r\n  FCEvReferenceApplication_X.Integrator2_CSTATE =\r\n    FCEvReferenceApplication_P.Integrator2_IC;\r\n\r\n  /* InitializeConditions for UnitDelay: '<S38>/Unit Delay' */\r\n  FCEvReferenceApplication_DW.UnitDelay_DSTATE[0] =\r\n    FCEvReferenceApplication_P.UnitDelay_InitialCondition[0];\r\n  FCEvReferenceApplication_DW.UnitDelay_DSTATE[1] =\r\n    FCEvReferenceApplication_P.UnitDelay_InitialCondition[1];\r\n\r\n  /* InitializeConditions for TransferFcn: '<S45>/Motor Coupling Dynamics' */\r\n  FCEvReferenceApplication_X.MotorCouplingDynamics_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for FirstOrderHold: '<S45>/First Order Hold' */\r\n  FCEvReferenceApplication_DW.Tk_a = (rtInf);\r\n  FCEvReferenceApplication_DW.Ck_g =\r\n    FCEvReferenceApplication_P.FirstOrderHold_IniOut_b;\r\n  FCEvReferenceApplication_DW.Uk_h = (rtInf);\r\n  FCEvReferenceApplication_DW.Mk_h = 0.0;\r\n\r\n  /* InitializeConditions for Integrator: '<S48>/Integrator' */\r\n  FCEvReferenceApplication_X.Integrator_CSTATE =\r\n    FCEvReferenceApplication_P.Integrator_IC;\r\n\r\n  /* InitializeConditions for Integrator: '<S48>/Integrator1' */\r\n  FCEvReferenceApplication_X.Integrator1_CSTATE_j =\r\n    FCEvReferenceApplication_P.Integrator1_IC_o;\r\n\r\n  /* SystemInitialize for ModelReference: '<S5>/Drivetrain' */\r\n  DrivetrainEv_Init(&(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtm),\r\n                    &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n                    &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw),\r\n                    &(FCEvReferenceApplication_X.Drivetrain_CSTATE));\r\n\r\n  /* SystemInitialize for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_Init\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE));\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S32>/Pass Through' */\r\n  FCEvReferenceA_PassThrough_Init(FCEvReferenceApplication_P.SignalHold_IC,\r\n    &FCEvReferenceApplication_B.PassThrough);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S32>/Pass Through' */\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S34>/Pass Through' */\r\n  FCEvReferenceA_PassThrough_Init(FCEvReferenceApplication_P.SignalHold_IC_k,\r\n    &FCEvReferenceApplication_B.PassThrough_b);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S34>/Pass Through' */\r\n\r\n  /* SystemInitialize for Chart: '<S39>/Shift Controller' */\r\n  FCEvReferenceApplication_DW.is_GearSelect = FCEvReferenc_IN_NO_ACTIVE_CHILD;\r\n  FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n  FCEvReferenceApplication_DW.is_active_c6_autolibsharedcommo = 0U;\r\n  FCEvReferenceApplication_DW.GearState = 0.0;\r\n  FCEvReferenceApplication_B.Gear = 0.0;\r\n  FCEvReferenceApplication_DW.presentTime = 0.0;\r\n  FCEvReferenceApplication_DW.elapsedTime = 0.0;\r\n  FCEvReferenceApplication_DW.previousTime = 0.0;\r\n\r\n  /* SystemInitialize for ModelReference: '<S1>/Powertrain Control Module (PCM)' */\r\n  FCEvPowertrainController_Init\r\n    (&(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtdw));\r\n\r\n  /* InitializeConditions for root-level periodic continuous states */\r\n  {\r\n    int_T rootPeriodicContStateIndices[1] = { 6 };\r\n\r\n    real_T rootPeriodicContStateRanges[2] = { -3.1415926535897931,\r\n      3.1415926535897931 };\r\n\r\n    (void) memcpy((void*)FCEvReferenceAppli_PeriodicIndX,\r\n                  rootPeriodicContStateIndices,\r\n                  1*sizeof(int_T));\r\n    (void) memcpy((void*)FCEvReferenceAppli_PeriodicRngX,\r\n                  rootPeriodicContStateRanges,\r\n                  2*sizeof(real_T));\r\n  }\r\n\r\n  /* Root-level InitSystemMatrices */\r\n  {\r\n    static int_T modelMassMatrixIr[129] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\r\n      12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\r\n      31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 83, 84, 86, 85, 87, 88, 90,\r\n      89, 48, 49, 51, 50, 52, 53, 55, 54, 42, 44, 45, 44, 46, 47, 48, 52, 56, 57,\r\n      58, 59, 58, 59, 60, 61, 60, 61, 62, 63, 64, 63, 66, 65, 67, 68, 67, 70, 69,\r\n      71, 72, 71, 73, 74, 75, 75, 76, 78, 77, 79, 80, 82, 81, 79, 83, 87, 91, 92,\r\n      94, 93, 91, 95, 96, 95, 97, 98, 100, 516, 99, 517, 518, 519, 520, 521, 522,\r\n      523, 524, 525, 526, 527 };\r\n\r\n    static int_T modelMassMatrixJc[529] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\r\n      12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\r\n      31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51,\r\n      53, 54, 55, 57, 58, 59, 60, 62, 63, 64, 65, 66, 67, 68, 69, 71, 73, 75, 77,\r\n      78, 80, 81, 82, 83, 85, 86, 87, 88, 90, 91, 92, 93, 94, 96, 97, 98, 100,\r\n      101, 102, 103, 104, 105, 107, 108, 109, 110, 112, 113, 114, 115, 117, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,\r\n      118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 119, 120, 121, 122,\r\n      123, 124, 125, 126, 127, 128, 129 };\r\n\r\n    static real_T modelMassMatrixPr[129] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0 };\r\n\r\n    (void) memcpy(FCEvReferenceApplica_MassMatrix.ir, modelMassMatrixIr,\r\n                  129*sizeof(int_T));\r\n    (void) memcpy(FCEvReferenceApplica_MassMatrix.jc, modelMassMatrixJc,\r\n                  529*sizeof(int_T));\r\n    (void) memcpy(FCEvReferenceApplica_MassMatrix.pr, modelMassMatrixPr,\r\n                  129*sizeof(real_T));\r\n  }\r\n}\r\n\r\n/* Enable for root system: '<Root>' */\r\nvoid MdlEnable(void)\r\n{\r\n  /* Enable for Chart: '<S39>/Shift Controller' */\r\n  FCEvReferenceApplication_DW.presentTime = ssGetTaskTime(rtS,1);\r\n  FCEvReferenceApplication_DW.previousTime =\r\n    FCEvReferenceApplication_DW.presentTime;\r\n}\r\n\r\n/* Start for root system: '<Root>' */\r\nvoid MdlStart(void)\r\n{\r\n  /* SetupRuntimeResources for ToWorkspace: '<Root>/To Workspace' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace_PWORK.LoggedData = rt_CreateLogVar(\r\n      ssGetRTWLogInfo(rtS),\r\n      ssGetTStart(rtS),\r\n      ssGetTFinal(rtS),\r\n      0.0,\r\n      (&ssGetErrorStatus(rtS)),\r\n      \"Pe\",\r\n      SS_DOUBLE,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      dimensions,\r\n      NO_LOGVALDIMS,\r\n      (NULL),\r\n      (NULL),\r\n      0,\r\n      1,\r\n      1.0,\r\n      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<Root>/To Workspace1' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace1_PWORK.LoggedData = rt_CreateLogVar(\r\n      ssGetRTWLogInfo(rtS),\r\n      ssGetTStart(rtS),\r\n      ssGetTFinal(rtS),\r\n      0.0,\r\n      (&ssGetErrorStatus(rtS)),\r\n      \"T\",\r\n      SS_DOUBLE,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      dimensions,\r\n      NO_LOGVALDIMS,\r\n      (NULL),\r\n      (NULL),\r\n      0,\r\n      1,\r\n      1.0,\r\n      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace1_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<Root>/To Workspace2' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace2_PWORK.LoggedData = rt_CreateLogVar(\r\n      ssGetRTWLogInfo(rtS),\r\n      ssGetTStart(rtS),\r\n      ssGetTFinal(rtS),\r\n      0.0,\r\n      (&ssGetErrorStatus(rtS)),\r\n      \"Pfc\",\r\n      SS_DOUBLE,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      dimensions,\r\n      NO_LOGVALDIMS,\r\n      (NULL),\r\n      (NULL),\r\n      0,\r\n      1,\r\n      1.0,\r\n      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace2_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S6>/To Workspace1' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace1_PWORK_c.LoggedData =\r\n      rt_CreateLogVar(\r\n                      ssGetRTWLogInfo(rtS),\r\n                      ssGetTStart(rtS),\r\n                      ssGetTFinal(rtS),\r\n                      0.0,\r\n                      (&ssGetErrorStatus(rtS)),\r\n                      \"efc\",\r\n                      SS_DOUBLE,\r\n                      0,\r\n                      0,\r\n                      0,\r\n                      1,\r\n                      1,\r\n                      dimensions,\r\n                      NO_LOGVALDIMS,\r\n                      (NULL),\r\n                      (NULL),\r\n                      0,\r\n                      1,\r\n                      1.0,\r\n                      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace1_PWORK_c.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S6>/To Workspace2' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace2_PWORK_i.LoggedData =\r\n      rt_CreateLogVar(\r\n                      ssGetRTWLogInfo(rtS),\r\n                      ssGetTStart(rtS),\r\n                      ssGetTFinal(rtS),\r\n                      0.0,\r\n                      (&ssGetErrorStatus(rtS)),\r\n                      \"soc\",\r\n                      SS_DOUBLE,\r\n                      0,\r\n                      0,\r\n                      0,\r\n                      1,\r\n                      1,\r\n                      dimensions,\r\n                      NO_LOGVALDIMS,\r\n                      (NULL),\r\n                      (NULL),\r\n                      0,\r\n                      1,\r\n                      1.0,\r\n                      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace2_PWORK_i.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S6>/To Workspace3' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace3_PWORK.LoggedData = rt_CreateLogVar(\r\n      ssGetRTWLogInfo(rtS),\r\n      ssGetTStart(rtS),\r\n      ssGetTFinal(rtS),\r\n      0.0,\r\n      (&ssGetErrorStatus(rtS)),\r\n      \"v\",\r\n      SS_DOUBLE,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      dimensions,\r\n      NO_LOGVALDIMS,\r\n      (NULL),\r\n      (NULL),\r\n      0,\r\n      1,\r\n      1.0,\r\n      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace3_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S6>/To Workspace4' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace4_PWORK.LoggedData = rt_CreateLogVar(\r\n      ssGetRTWLogInfo(rtS),\r\n      ssGetTStart(rtS),\r\n      ssGetTFinal(rtS),\r\n      0.0,\r\n      (&ssGetErrorStatus(rtS)),\r\n      \"a\",\r\n      SS_DOUBLE,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      dimensions,\r\n      NO_LOGVALDIMS,\r\n      (NULL),\r\n      (NULL),\r\n      0,\r\n      1,\r\n      1.0,\r\n      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace4_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<Root>/To Workspace3' */\r\n  {\r\n    int_T dimensions[1] = { 1 };\r\n\r\n    FCEvReferenceApplication_DW.ToWorkspace3_PWORK_j.LoggedData =\r\n      rt_CreateLogVar(\r\n                      ssGetRTWLogInfo(rtS),\r\n                      ssGetTStart(rtS),\r\n                      ssGetTFinal(rtS),\r\n                      0.0,\r\n                      (&ssGetErrorStatus(rtS)),\r\n                      \"Clock\",\r\n                      SS_DOUBLE,\r\n                      0,\r\n                      0,\r\n                      0,\r\n                      1,\r\n                      1,\r\n                      dimensions,\r\n                      NO_LOGVALDIMS,\r\n                      (NULL),\r\n                      (NULL),\r\n                      0,\r\n                      1,\r\n                      1.0,\r\n                      1);\r\n    if (FCEvReferenceApplication_DW.ToWorkspace3_PWORK_j.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* Start for ModelReference: '<S5>/Drivetrain' */\r\n  DrivetrainEv_Start(&(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n                     &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw));\r\n\r\n  /* Start for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_Start\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE),\r\n     &(((CXPtMin_FCEvReferenceApplicat_T *)\r\n        ssGetJacobianPerturbationBoundsMinVec(rtS))->ElectricPlant_CSTATE),\r\n     &(((CXPtMax_FCEvReferenceApplicat_T *)\r\n        ssGetJacobianPerturbationBoundsMaxVec(rtS))->ElectricPlant_CSTATE));\r\n\r\n  /* Start for Enabled SubSystem: '<S32>/Pass Through' */\r\n  FCEvReference_PassThrough_Start(rtS, &FCEvReferenceApplication_DW.PassThrough);\r\n\r\n  /* End of Start for SubSystem: '<S32>/Pass Through' */\r\n\r\n  /* Start for Enabled SubSystem: '<S34>/Pass Through' */\r\n  FCEvReference_PassThrough_Start(rtS,\r\n    &FCEvReferenceApplication_DW.PassThrough_b);\r\n\r\n  /* End of Start for SubSystem: '<S34>/Pass Through' */\r\n\r\n  /* Start for Sqrt: '<S48>/Sqrt' */\r\n  FCEvReferenceApplication_DW.Sqrt_DWORK1 = 0;\r\n  MdlInitialize();\r\n  MdlEnable();\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nvoid MdlOutputs(int_T tid)\r\n{\r\n  /* local block i/o variables */\r\n  real_T rtb_Saturation;\r\n  real_T rtb_Saturation_h;\r\n  real_T rtb_PowertrainControlModulePCM_;\r\n  real_T rtb_PowertrainControlModulePC_h;\r\n  real_T rtb_PowertrainControlModulePC_m;\r\n  real_T a_tmp[4];\r\n  real_T b_a[4];\r\n  real_T rtb_F[4];\r\n  real_T sigmaA[4];\r\n  real_T rtb_TraceVelocityTargetActualmp[2];\r\n  real_T rtb_BatteryCurrentA;\r\n  real_T rtb_BatterySOC;\r\n  real_T rtb_FuelCellCurrentA;\r\n  real_T rtb_FuelCellVoltageV;\r\n  real_T rtb_G_idx_1;\r\n  real_T rtb_MotorSpeedRPM;\r\n  real_T rtb_MotorTorqueNm;\r\n  real_T rtb_Saturation_k;\r\n  real_T rtb_USMPG;\r\n  real_T rtb_USMPG_tmp;\r\n  real_T sigmaB_idx_0;\r\n  real_T sigmaB_idx_1;\r\n  real_T sigmaB_idx_2;\r\n  real_T sigmaB_idx_3;\r\n  real_T *lastU;\r\n  int32_T trueCount;\r\n  boolean_T rtb_RelationalOperator;\r\n  static const real_T e_1[170] = { 1.0, 2.0, 6.0, 24.0, 120.0, 720.0, 5040.0,\r\n    40320.0, 362880.0, 3.6288E+6, 3.99168E+7, 4.790016E+8, 6.2270208E+9,\r\n    8.71782912E+10, 1.307674368E+12, 2.0922789888E+13, 3.55687428096E+14,\r\n    6.402373705728E+15, 1.21645100408832E+17, 2.43290200817664E+18,\r\n    5.109094217170944E+19, 1.1240007277776077E+21, 2.5852016738884978E+22,\r\n    6.2044840173323941E+23, 1.5511210043330986E+25, 4.0329146112660565E+26,\r\n    1.0888869450418352E+28, 3.0488834461171384E+29, 8.8417619937397008E+30,\r\n    2.6525285981219103E+32, 8.2228386541779224E+33, 2.6313083693369352E+35,\r\n    8.6833176188118859E+36, 2.9523279903960412E+38, 1.0333147966386144E+40,\r\n    3.7199332678990118E+41, 1.3763753091226343E+43, 5.23022617466601E+44,\r\n    2.0397882081197442E+46, 8.1591528324789768E+47, 3.3452526613163803E+49,\r\n    1.4050061177528798E+51, 6.0415263063373834E+52, 2.6582715747884485E+54,\r\n    1.1962222086548019E+56, 5.5026221598120885E+57, 2.5862324151116818E+59,\r\n    1.2413915592536073E+61, 6.0828186403426752E+62, 3.0414093201713376E+64,\r\n    1.5511187532873822E+66, 8.0658175170943877E+67, 4.2748832840600255E+69,\r\n    2.3084369733924138E+71, 1.2696403353658276E+73, 7.1099858780486348E+74,\r\n    4.0526919504877221E+76, 2.3505613312828789E+78, 1.3868311854568986E+80,\r\n    8.3209871127413916E+81, 5.0758021387722484E+83, 3.1469973260387939E+85,\r\n    1.98260831540444E+87, 1.2688693218588417E+89, 8.2476505920824715E+90,\r\n    5.4434493907744307E+92, 3.6471110918188683E+94, 2.4800355424368305E+96,\r\n    1.711224524281413E+98, 1.197857166996989E+100, 8.5047858856786218E+101,\r\n    6.1234458376886077E+103, 4.4701154615126834E+105, 3.3078854415193856E+107,\r\n    2.4809140811395391E+109, 1.8854947016660498E+111, 1.4518309202828584E+113,\r\n    1.1324281178206295E+115, 8.9461821307829729E+116, 7.1569457046263779E+118,\r\n    5.7971260207473655E+120, 4.75364333701284E+122, 3.9455239697206569E+124,\r\n    3.314240134565352E+126, 2.8171041143805494E+128, 2.4227095383672724E+130,\r\n    2.1077572983795269E+132, 1.8548264225739836E+134, 1.6507955160908452E+136,\r\n    1.4857159644817607E+138, 1.3520015276784023E+140, 1.24384140546413E+142,\r\n    1.1567725070816409E+144, 1.0873661566567424E+146, 1.0329978488239052E+148,\r\n    9.916779348709491E+149, 9.6192759682482062E+151, 9.426890448883242E+153,\r\n    9.33262154439441E+155, 9.33262154439441E+157, 9.4259477598383536E+159,\r\n    9.6144667150351211E+161, 9.9029007164861754E+163, 1.0299016745145622E+166,\r\n    1.0813967582402903E+168, 1.1462805637347078E+170, 1.2265202031961373E+172,\r\n    1.3246418194518284E+174, 1.4438595832024928E+176, 1.5882455415227421E+178,\r\n    1.7629525510902437E+180, 1.9745068572210728E+182, 2.2311927486598123E+184,\r\n    2.5435597334721862E+186, 2.9250936934930141E+188, 3.3931086844518965E+190,\r\n    3.969937160808719E+192, 4.6845258497542883E+194, 5.5745857612076033E+196,\r\n    6.6895029134491239E+198, 8.09429852527344E+200, 9.8750442008335976E+202,\r\n    1.2146304367025325E+205, 1.5061417415111404E+207, 1.8826771768889254E+209,\r\n    2.3721732428800459E+211, 3.0126600184576582E+213, 3.8562048236258025E+215,\r\n    4.9745042224772855E+217, 6.4668554892204716E+219, 8.4715806908788174E+221,\r\n    1.1182486511960039E+224, 1.4872707060906852E+226, 1.9929427461615181E+228,\r\n    2.6904727073180495E+230, 3.6590428819525472E+232, 5.01288874827499E+234,\r\n    6.9177864726194859E+236, 9.6157231969410859E+238, 1.346201247571752E+241,\r\n    1.89814375907617E+243, 2.6953641378881614E+245, 3.8543707171800706E+247,\r\n    5.5502938327393013E+249, 8.0479260574719866E+251, 1.17499720439091E+254,\r\n    1.7272458904546376E+256, 2.5563239178728637E+258, 3.8089226376305671E+260,\r\n    5.7133839564458505E+262, 8.6272097742332346E+264, 1.3113358856834518E+267,\r\n    2.0063439050956811E+269, 3.0897696138473489E+271, 4.7891429014633912E+273,\r\n    7.47106292628289E+275, 1.1729568794264138E+278, 1.8532718694937338E+280,\r\n    2.9467022724950369E+282, 4.714723635992059E+284, 7.5907050539472148E+286,\r\n    1.2296942187394488E+289, 2.0044015765453015E+291, 3.2872185855342945E+293,\r\n    5.423910666131586E+295, 9.0036917057784329E+297, 1.5036165148649983E+300,\r\n    2.5260757449731969E+302, 4.2690680090047027E+304, 7.257415615307994E+306 };\r\n\r\n  /* Read data from the mat file of inport block */\r\n  if (gblInportFileName != (NULL)) {\r\n    int_T currTimeIdx;\r\n    int_T i;\r\n\r\n    /*\r\n     *  Read in data from mat file for root inport pfc\r\n     */\r\n    if (gblInportTUtables[0].nTimePoints > 0) {\r\n      if (ssIsSampleHit(rtS, 2, 0)) {\r\n        {\r\n          real_T time = ssGetTaskTime(rtS,2);\r\n          int k = 1;\r\n          if (gblInportTUtables[0].nTimePoints == 1) {\r\n            k = 0;\r\n          }\r\n\r\n          currTimeIdx = rt_getTimeIdx(gblInportTUtables[0].time, time,\r\n            gblInportTUtables[0].nTimePoints,\r\n            *(gblInportTUtables[0].currTimeIdx),\r\n            1,\r\n            0);\r\n          (*gblInportTUtables[0].currTimeIdx) = currTimeIdx;\r\n          for (i = 0; i < 1; i++) {\r\n            real_T* realPtr1 = (real_T*)gblInportTUtables[0].ur +\r\n              i*gblInportTUtables[0].nTimePoints +currTimeIdx;\r\n            real_T* realPtr2 = realPtr1 + 1*k;\r\n            (void)rt_Interpolate_Datatype(\r\n              realPtr1,\r\n              realPtr2,\r\n              &FCEvReferenceApplication_U.pfc,\r\n              time,\r\n              gblInportTUtables[0].time[currTimeIdx],\r\n              gblInportTUtables[0].time[currTimeIdx + k],\r\n              gblInportTUtables[0].uDataType);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* end read inport data from file */\r\n\r\n  /* FirstOrderHold: '<S46>/First Order Hold' */\r\n  FCEvReferenceApplication_B.MotTrqCmd = FCEvReferenceApplication_DW.Ck;\r\n\r\n  /* FirstOrderHold: '<S46>/First Order Hold' */\r\n  if (FCEvReferenceApplication_DW.Tk != (rtInf)) {\r\n    /* FirstOrderHold: '<S46>/First Order Hold' */\r\n    FCEvReferenceApplication_B.MotTrqCmd += (ssGetT(rtS) -\r\n      FCEvReferenceApplication_DW.Tk) * FCEvReferenceApplication_DW.Mk;\r\n  }\r\n\r\n  /* ModelReference: '<S5>/Drivetrain' */\r\n  DrivetrainEv(&(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtm),\r\n               &FCEvReferenceApplication_B.xdot,\r\n               &FCEvReferenceApplication_B.MotSpd,\r\n               &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n               &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw),\r\n               &(FCEvReferenceApplication_X.Drivetrain_CSTATE),\r\n               &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtzce));\r\n\r\n  /* FirstOrderHold: '<S46>/First Order Hold1' */\r\n  FCEvReferenceApplication_B.FCCurrCmd = FCEvReferenceApplication_DW.Ck_d;\r\n\r\n  /* FirstOrderHold: '<S46>/First Order Hold1' */\r\n  if (FCEvReferenceApplication_DW.Tk_o != (rtInf)) {\r\n    /* FirstOrderHold: '<S46>/First Order Hold1' */\r\n    FCEvReferenceApplication_B.FCCurrCmd += (ssGetT(rtS) -\r\n      FCEvReferenceApplication_DW.Tk_o) * FCEvReferenceApplication_DW.Mk_e;\r\n  }\r\n\r\n  /* ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant(&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n                  &FCEvReferenceApplication_B.MotTrqCmd,\r\n                  &FCEvReferenceApplication_B.MotSpd,\r\n                  &FCEvReferenceApplication_B.FCCurrCmd,\r\n                  &FCEvReferenceApplication_B.BattSoc,\r\n                  &FCEvReferenceApplication_B.BattPwr,\r\n                  &FCEvReferenceApplication_B.BattCurr,\r\n                  &FCEvReferenceApplication_B.MotTrq,\r\n                  &FCEvReferenceApplication_B.ElectricPlant_o5,\r\n                  &FCEvReferenceApplication_B.FCCurr,\r\n                  &FCEvReferenceApplication_B.TotPwr,\r\n                  &FCEvReferenceApplication_B.H2Flow,\r\n                  &FCEvReferenceApplication_B.ElectricPlant_o9,\r\n                  &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n                  &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n                  &(FCEvReferenceApplication_X.ElectricPlant_CSTATE),\r\n                  &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtzce));\r\n\r\n  /* RateTransition: '<S6>/Rate Transition1' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition1_semaphoreTaken == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition1_Buffer0 =\r\n      FCEvReferenceApplication_B.BattSoc;\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition1_semaphoreTaken = 1;\r\n    rtb_BatterySOC = FCEvReferenceApplication_DW.RateTransition1_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition1_semaphoreTaken = 0;\r\n\r\n    /* Outport: '<Root>/soc' */\r\n    FCEvReferenceApplication_Y.soc = rtb_BatterySOC;\r\n  }\r\n\r\n  /* End of RateTransition: '<S6>/Rate Transition1' */\r\n\r\n  /* Saturate: '<S6>/Saturation' */\r\n  if (ssIsModeUpdateTimeStep(rtS)) {\r\n    FCEvReferenceApplication_DW.Saturation_MODE =\r\n      FCEvReferenceApplication_B.xdot >=\r\n      FCEvReferenceApplication_P.Saturation_UpperSat ? 1 :\r\n      FCEvReferenceApplication_B.xdot >\r\n      FCEvReferenceApplication_P.Saturation_LowerSat ? 0 : -1;\r\n  }\r\n\r\n  /* Saturate: '<S6>/Saturation' */\r\n  FCEvReferenceApplication_B.Saturation =\r\n    FCEvReferenceApplication_DW.Saturation_MODE == 1 ?\r\n    FCEvReferenceApplication_P.Saturation_UpperSat :\r\n    FCEvReferenceApplication_DW.Saturation_MODE == -1 ?\r\n    FCEvReferenceApplication_P.Saturation_LowerSat :\r\n    FCEvReferenceApplication_B.xdot;\r\n\r\n  /* Gain: '<S6>/Gain' */\r\n  FCEvReferenceApplication_B.Gain = FCEvReferenceApplication_P.Gain_Gain *\r\n    FCEvReferenceApplication_B.Saturation;\r\n\r\n  /* Derivative: '<S6>/Derivative' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   *  Clock: '<S11>/Clock'\r\n   *  FirstOrderHold: '<S45>/First Order Hold'\r\n   */\r\n  rtb_USMPG_tmp = ssGetT(rtS);\r\n  rtb_USMPG = rtb_USMPG_tmp;\r\n  if ((FCEvReferenceApplication_DW.TimeStampA >= rtb_USMPG) &&\r\n      (FCEvReferenceApplication_DW.TimeStampB >= rtb_USMPG)) {\r\n    /* Derivative: '<S6>/Derivative' */\r\n    FCEvReferenceApplication_B.Derivative = 0.0;\r\n  } else {\r\n    rtb_Saturation_k = FCEvReferenceApplication_DW.TimeStampA;\r\n    lastU = &FCEvReferenceApplication_DW.LastUAtTimeA;\r\n    if (FCEvReferenceApplication_DW.TimeStampA <\r\n        FCEvReferenceApplication_DW.TimeStampB) {\r\n      if (FCEvReferenceApplication_DW.TimeStampB < rtb_USMPG) {\r\n        rtb_Saturation_k = FCEvReferenceApplication_DW.TimeStampB;\r\n        lastU = &FCEvReferenceApplication_DW.LastUAtTimeB;\r\n      }\r\n    } else if (FCEvReferenceApplication_DW.TimeStampA >= rtb_USMPG) {\r\n      rtb_Saturation_k = FCEvReferenceApplication_DW.TimeStampB;\r\n      lastU = &FCEvReferenceApplication_DW.LastUAtTimeB;\r\n    }\r\n\r\n    /* Derivative: '<S6>/Derivative' */\r\n    FCEvReferenceApplication_B.Derivative = (FCEvReferenceApplication_B.Gain -\r\n      *lastU) / (rtb_USMPG - rtb_Saturation_k);\r\n  }\r\n\r\n  /* End of Derivative: '<S6>/Derivative' */\r\n\r\n  /* Outport: '<Root>/v' */\r\n  FCEvReferenceApplication_Y.v = FCEvReferenceApplication_B.Derivative;\r\n\r\n  /* Outport: '<Root>/a' */\r\n  FCEvReferenceApplication_Y.a = FCEvReferenceApplication_B.Gain;\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    /* Gain: '<Root>/Gain' incorporates:\r\n     *  Inport: '<Root>/pfc'\r\n     */\r\n    FCEvReferenceApplication_B.Gain_g = FCEvReferenceApplication_P.Gain_Gain_n *\r\n      FCEvReferenceApplication_U.pfc;\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Logic: '<S26>/Logical Operator2' */\r\n    FCEvReferenceApplication_B.LogicalOperator2 = false;\r\n\r\n    /* Constant: '<S26>/Constant' */\r\n    FCEvReferenceApplication_B.Constant =\r\n      FCEvReferenceApplication_P.Constant_Value_m;\r\n\r\n    /* Gain: '<S25>/Gain' incorporates:\r\n     *  Trigonometry: '<S25>/Trigonometric Function'\r\n     *  UnitConversion: '<S25>/Unit Conversion2'\r\n     */\r\n    /* Unit Conversion - from: deg to: rad\r\n       Expression: output = (0.0174533*input) + (0) */\r\n    FCEvReferenceApplication_B.Gain_a =\r\n      FCEvReferenceApplication_P.LongitudinalDriverModel_g *\r\n      FCEvReferenceApplication_P.LongitudinalDriverModel_m *\r\n      FCEvReferenceApplication_P.LongitudinalDriverModel_m /\r\n      FCEvReferenceApplication_P.LongitudinalDriverModel_Kpt * 0.0;\r\n  }\r\n\r\n  /* Integrator: '<S27>/Integrator1' */\r\n  FCEvReferenceApplication_B.Integrator1 =\r\n    FCEvReferenceApplication_X.Integrator1_CSTATE;\r\n\r\n  /* Sum: '<S25>/Add' */\r\n  FCEvReferenceApplication_B.Add = FCEvReferenceApplication_B.Integrator1 -\r\n    FCEvReferenceApplication_B.Gain_a;\r\n\r\n  /* Switch: '<S26>/Switch1' incorporates:\r\n   *  Saturate: '<S26>/0~1'\r\n   *  Switch: '<S26>/Switch'\r\n   */\r\n  if (FCEvReferenceApplication_B.LogicalOperator2) {\r\n    rtb_Saturation_k = 0.0;\r\n  } else if (FCEvReferenceApplication_B.Add >\r\n             FCEvReferenceApplication_P.u1_UpperSat) {\r\n    /* Saturate: '<S26>/0~1' incorporates:\r\n     *  Switch: '<S26>/Switch'\r\n     */\r\n    rtb_Saturation_k = FCEvReferenceApplication_P.u1_UpperSat;\r\n  } else if (FCEvReferenceApplication_B.Add <\r\n             FCEvReferenceApplication_P.u1_LowerSat) {\r\n    /* Saturate: '<S26>/0~1' incorporates:\r\n     *  Switch: '<S26>/Switch'\r\n     */\r\n    rtb_Saturation_k = FCEvReferenceApplication_P.u1_LowerSat;\r\n  } else {\r\n    /* Switch: '<S26>/Switch' incorporates:\r\n     *  Saturate: '<S26>/0~1'\r\n     */\r\n    rtb_Saturation_k = FCEvReferenceApplication_B.Add;\r\n  }\r\n\r\n  /* End of Switch: '<S26>/Switch1' */\r\n\r\n  /* Saturate: '<S26>/Saturation' */\r\n  if (rtb_Saturation_k > FCEvReferenceApplication_P.Saturation_UpperSat_e) {\r\n    /* Saturate: '<S26>/Saturation' */\r\n    rtb_Saturation = FCEvReferenceApplication_P.Saturation_UpperSat_e;\r\n  } else if (rtb_Saturation_k < FCEvReferenceApplication_P.Saturation_LowerSat_j)\r\n  {\r\n    /* Saturate: '<S26>/Saturation' */\r\n    rtb_Saturation = FCEvReferenceApplication_P.Saturation_LowerSat_j;\r\n  } else {\r\n    /* Saturate: '<S26>/Saturation' */\r\n    rtb_Saturation = rtb_Saturation_k;\r\n  }\r\n\r\n  /* End of Saturate: '<S26>/Saturation' */\r\n  rtb_RelationalOperator = ssIsSampleHit(rtS, 1, 0);\r\n\r\n  /* Logic: '<S32>/NOT' */\r\n  FCEvReferenceApplication_B.NOT = (rtb_RelationalOperator ||\r\n    FCEvReferenceApplication_B.NOT);\r\n\r\n  /* Outputs for Enabled SubSystem: '<S32>/Pass Through' */\r\n  FCEvReferenceApplic_PassThrough(rtS, FCEvReferenceApplication_B.NOT,\r\n    rtb_Saturation, &FCEvReferenceApplication_B.PassThrough,\r\n    &FCEvReferenceApplication_DW.PassThrough);\r\n\r\n  /* End of Outputs for SubSystem: '<S32>/Pass Through' */\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Logic: '<S28>/Logical Operator2' */\r\n    FCEvReferenceApplication_B.LogicalOperator2_j = false;\r\n\r\n    /* Constant: '<S28>/Constant' */\r\n    FCEvReferenceApplication_B.Constant_d =\r\n      FCEvReferenceApplication_P.Constant_Value_l;\r\n  }\r\n\r\n  /* Switch: '<S28>/Switch1' incorporates:\r\n   *  Saturate: '<S28>/-1~0'\r\n   *  Switch: '<S28>/Switch'\r\n   */\r\n  if (FCEvReferenceApplication_B.LogicalOperator2_j) {\r\n    rtb_Saturation_k = 0.0;\r\n  } else if (FCEvReferenceApplication_B.Add >\r\n             FCEvReferenceApplication_P.u0_UpperSat) {\r\n    /* Saturate: '<S28>/-1~0' incorporates:\r\n     *  Switch: '<S28>/Switch'\r\n     *  UnaryMinus: '<S28>/Unary Minus'\r\n     */\r\n    rtb_Saturation_k = -FCEvReferenceApplication_P.u0_UpperSat;\r\n  } else if (FCEvReferenceApplication_B.Add <\r\n             FCEvReferenceApplication_P.u0_LowerSat) {\r\n    /* Saturate: '<S28>/-1~0' incorporates:\r\n     *  Switch: '<S28>/Switch'\r\n     *  UnaryMinus: '<S28>/Unary Minus'\r\n     */\r\n    rtb_Saturation_k = -FCEvReferenceApplication_P.u0_LowerSat;\r\n  } else {\r\n    /* Switch: '<S28>/Switch' incorporates:\r\n     *  Saturate: '<S28>/-1~0'\r\n     *  UnaryMinus: '<S28>/Unary Minus'\r\n     */\r\n    rtb_Saturation_k = -FCEvReferenceApplication_B.Add;\r\n  }\r\n\r\n  /* End of Switch: '<S28>/Switch1' */\r\n\r\n  /* Saturate: '<S28>/Saturation' */\r\n  if (rtb_Saturation_k > FCEvReferenceApplication_P.Saturation_UpperSat_n) {\r\n    /* Saturate: '<S28>/Saturation' */\r\n    rtb_Saturation_h = FCEvReferenceApplication_P.Saturation_UpperSat_n;\r\n  } else if (rtb_Saturation_k <\r\n             FCEvReferenceApplication_P.Saturation_LowerSat_jd) {\r\n    /* Saturate: '<S28>/Saturation' */\r\n    rtb_Saturation_h = FCEvReferenceApplication_P.Saturation_LowerSat_jd;\r\n  } else {\r\n    /* Saturate: '<S28>/Saturation' */\r\n    rtb_Saturation_h = rtb_Saturation_k;\r\n  }\r\n\r\n  /* End of Saturate: '<S28>/Saturation' */\r\n\r\n  /* Logic: '<S34>/NOT' */\r\n  FCEvReferenceApplication_B.NOT_g = (rtb_RelationalOperator ||\r\n    FCEvReferenceApplication_B.NOT_g);\r\n\r\n  /* Outputs for Enabled SubSystem: '<S34>/Pass Through' */\r\n  FCEvReferenceApplic_PassThrough(rtS, FCEvReferenceApplication_B.NOT_g,\r\n    rtb_Saturation_h, &FCEvReferenceApplication_B.PassThrough_b,\r\n    &FCEvReferenceApplication_DW.PassThrough_b);\r\n\r\n  /* End of Outputs for SubSystem: '<S34>/Pass Through' */\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Constant: '<S11>/tFinal' */\r\n    FCEvReferenceApplication_B.tFinal = FCEvReferenceApplication_P.tFinal_Value;\r\n\r\n    /* Constant: '<S11>/repeat' */\r\n    FCEvReferenceApplication_B.repeat = FCEvReferenceApplication_P.repeat_Value;\r\n  }\r\n\r\n  /* Switch: '<S11>/Switch' */\r\n  if (FCEvReferenceApplication_B.repeat >\r\n      FCEvReferenceApplication_P.Switch_Threshold) {\r\n    /* Switch: '<S11>/Switch' incorporates:\r\n     *  Math: '<S11>/Math Function'\r\n     */\r\n    FCEvReferenceApplication_B.Switch = rt_modd_snf(rtb_USMPG,\r\n      FCEvReferenceApplication_B.tFinal);\r\n  } else {\r\n    /* Switch: '<S11>/Switch' */\r\n    FCEvReferenceApplication_B.Switch = rtb_USMPG;\r\n  }\r\n\r\n  /* End of Switch: '<S11>/Switch' */\r\n\r\n  /* Lookup_n-D: '<S11>/1-D Lookup Table' incorporates:\r\n   *  Switch: '<S11>/Switch'\r\n   */\r\n  FCEvReferenceApplication_B.uDLookupTable = look1_pbinlcapw\r\n    (FCEvReferenceApplication_B.Switch,\r\n     FCEvReferenceApplication_P.uDLookupTable_bp01Data,\r\n     FCEvReferenceApplication_P.uDLookupTable_tableData,\r\n     &FCEvReferenceApplication_DW.m_bpIndex, 1369U);\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Chart: '<S39>/Shift Controller' */\r\n    FCEvReferenceApplication_DW.presentTime = ssGetTaskTime(rtS,1);\r\n    FCEvReferenceApplication_DW.elapsedTime =\r\n      FCEvReferenceApplication_DW.presentTime -\r\n      FCEvReferenceApplication_DW.previousTime;\r\n    FCEvReferenceApplication_DW.previousTime =\r\n      FCEvReferenceApplication_DW.presentTime;\r\n    FCEvReferenceApplication_DW.temporalCounter_i1 +=\r\n      FCEvReferenceApplication_DW.elapsedTime;\r\n\r\n    /* Gateway: Longitudinal Driver/Shift/Basic/Shift Controller */\r\n    /* During: Longitudinal Driver/Shift/Basic/Shift Controller */\r\n    if (FCEvReferenceApplication_DW.is_active_c6_autolibsharedcommo == 0U) {\r\n      /* Entry: Longitudinal Driver/Shift/Basic/Shift Controller */\r\n      FCEvReferenceApplication_DW.is_active_c6_autolibsharedcommo = 1U;\r\n\r\n      /* Entry Internal: Longitudinal Driver/Shift/Basic/Shift Controller */\r\n      /* Entry Internal 'GearSelect': '<S41>:374' */\r\n      /* Transition: '<S41>:490' */\r\n      /*  InitialGear  */\r\n      FCEvReferenceApplication_B.Gear =\r\n        FCEvReferenceApplication_P.LongitudinalDriverModel_GearIni;\r\n      FCEvReferenceApplication_DW.GearState =\r\n        FCEvReferenceApplication_P.LongitudinalDriverModel_GearIni;\r\n      if (FCEvReferenceApplication_P.LongitudinalDriverModel_GearIni < 0.0) {\r\n        /* Transition: '<S41>:480' */\r\n        /* Transition: '<S41>:479' */\r\n        FCEvReferenceApplication_DW.is_GearSelect =\r\n          FCEvReferenceApplica_IN_Reverse;\r\n        FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n        /* Entry 'Reverse': '<S41>:375' */\r\n        FCEvReferenceApplication_B.Gear = -1.0;\r\n\r\n        /* Transition: '<S41>:481' */\r\n      } else if (FCEvReferenceApplication_P.LongitudinalDriverModel_GearIni ==\r\n                 0.0) {\r\n        /* Transition: '<S41>:477' */\r\n        /* Transition: '<S41>:484' */\r\n        FCEvReferenceApplication_DW.is_GearSelect =\r\n          FCEvReferenceApplica_IN_Neutral;\r\n        FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n        /* Entry 'Neutral': '<S41>:355' */\r\n        FCEvReferenceApplication_B.Gear = 0.0;\r\n      } else {\r\n        /* Transition: '<S41>:486' */\r\n        /* Transition: '<S41>:478' */\r\n        FCEvReferenceApplication_DW.is_GearSelect =\r\n          FCEvReferenceApplication_IN_Odd;\r\n        FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n        /* Entry 'Odd': '<S41>:356' */\r\n      }\r\n    } else {\r\n      /* During 'GearSelect': '<S41>:374' */\r\n      switch (FCEvReferenceApplication_DW.is_GearSelect) {\r\n       case FCEvReferenceApplica_IN_Neutral:\r\n        /* During 'Neutral': '<S41>:355' */\r\n        rtb_Saturation_k = (ssGetTaskTime(rtS,1) -\r\n                            FCEvReferenceApplication_DW.previousTime) +\r\n          FCEvReferenceApplication_DW.temporalCounter_i1;\r\n        if ((rtb_Saturation_k >=\r\n             FCEvReferenceApplication_P.LongitudinalDriverModel_tShift) &&\r\n            ((FCEvReferenceApplication_B.uDLookupTable > 0.0) &&\r\n             (FCEvReferenceApplication_B.PassThrough.u > 0.0))) {\r\n          /* Transition: '<S41>:365' */\r\n          FCEvReferenceApplication_DW.GearState++;\r\n          FCEvReferenceApplication_DW.is_GearSelect =\r\n            FCEvReferenceApplication_IN_Odd;\r\n          FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n          /* Entry 'Odd': '<S41>:356' */\r\n          FCEvReferenceApplication_B.Gear =\r\n            FCEvReferenceApplication_DW.GearState;\r\n        } else if ((rtb_Saturation_k >=\r\n                    FCEvReferenceApplication_P.LongitudinalDriverModel_tShift) &&\r\n                   (FCEvReferenceApplication_B.uDLookupTable < 0.0)) {\r\n          /* Transition: '<S41>:376' */\r\n          FCEvReferenceApplication_DW.GearState--;\r\n          FCEvReferenceApplication_DW.is_GearSelect =\r\n            FCEvReferenceApplica_IN_Reverse;\r\n          FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n          /* Entry 'Reverse': '<S41>:375' */\r\n          FCEvReferenceApplication_B.Gear = -1.0;\r\n        }\r\n        break;\r\n\r\n       case FCEvReferenceApplication_IN_Odd:\r\n        /* During 'Odd': '<S41>:356' */\r\n        if (((ssGetTaskTime(rtS,1) - FCEvReferenceApplication_DW.previousTime) +\r\n             FCEvReferenceApplication_DW.temporalCounter_i1 >=\r\n             FCEvReferenceApplication_P.LongitudinalDriverModel_tShift) &&\r\n            (((FCEvReferenceApplication_B.PassThrough_b.u >= 0.0) &&\r\n              (FCEvReferenceApplication_B.xdot <= 0.0) &&\r\n              (FCEvReferenceApplication_B.PassThrough.u <= 0.0)) ||\r\n             (FCEvReferenceApplication_B.uDLookupTable <= 0.0))) {\r\n          /* Transition: '<S41>:467' */\r\n          FCEvReferenceApplication_DW.GearState--;\r\n          FCEvReferenceApplication_DW.is_GearSelect =\r\n            FCEvReferenceApplica_IN_Neutral;\r\n          FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n          /* Entry 'Neutral': '<S41>:355' */\r\n          FCEvReferenceApplication_B.Gear = 0.0;\r\n        }\r\n        break;\r\n\r\n       default:\r\n        /* During 'Reverse': '<S41>:375' */\r\n        if (((ssGetTaskTime(rtS,1) - FCEvReferenceApplication_DW.previousTime) +\r\n             FCEvReferenceApplication_DW.temporalCounter_i1 >=\r\n             FCEvReferenceApplication_P.LongitudinalDriverModel_tShift) &&\r\n            (FCEvReferenceApplication_B.uDLookupTable >= 0.0)) {\r\n          /* Transition: '<S41>:377' */\r\n          FCEvReferenceApplication_DW.GearState++;\r\n          FCEvReferenceApplication_DW.is_GearSelect =\r\n            FCEvReferenceApplica_IN_Neutral;\r\n          FCEvReferenceApplication_DW.temporalCounter_i1 = 0.0;\r\n\r\n          /* Entry 'Neutral': '<S41>:355' */\r\n          FCEvReferenceApplication_B.Gear = 0.0;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* End of Chart: '<S39>/Shift Controller' */\r\n\r\n    /* Constant: '<S40>/Constant1' */\r\n    FCEvReferenceApplication_B.Constant1 =\r\n      FCEvReferenceApplication_P.Constant1_Value;\r\n\r\n    /* RelationalOperator: '<S42>/Compare' incorporates:\r\n     *  Constant: '<S42>/Constant'\r\n     */\r\n    if (ssIsModeUpdateTimeStep(rtS)) {\r\n      FCEvReferenceApplication_DW.Compare_Mode =\r\n        (FCEvReferenceApplication_B.uDLookupTable !=\r\n         FCEvReferenceApplication_P.Constant_Value);\r\n    }\r\n\r\n    /* Logic: '<S40>/Logical Operator' incorporates:\r\n     *  Constant: '<S43>/Constant'\r\n     *  RelationalOperator: '<S42>/Compare'\r\n     *  RelationalOperator: '<S43>/Compare'\r\n     */\r\n    FCEvReferenceApplication_B.LogicalOperator =\r\n      (FCEvReferenceApplication_DW.Compare_Mode &&\r\n       (FCEvReferenceApplication_B.Gear >\r\n        FCEvReferenceApplication_P.Constant_Value_n));\r\n\r\n    /* Constant: '<S40>/Constant' */\r\n    FCEvReferenceApplication_B.Constant_l =\r\n      FCEvReferenceApplication_P.Constant_Value_f;\r\n  }\r\n\r\n  /* Switch: '<S40>/Switch' incorporates:\r\n   *  Switch: '<S40>/Switch1'\r\n   */\r\n  if (FCEvReferenceApplication_B.LogicalOperator) {\r\n    /* Switch: '<S40>/Switch2' */\r\n    if (FCEvReferenceApplication_B.Gear != 0.0) {\r\n      /* Switch: '<S40>/Switch' */\r\n      FCEvReferenceApplication_B.Switch_b[0] =\r\n        FCEvReferenceApplication_B.PassThrough.u;\r\n    } else {\r\n      /* Switch: '<S40>/Switch' */\r\n      FCEvReferenceApplication_B.Switch_b[0] =\r\n        FCEvReferenceApplication_B.Constant1;\r\n    }\r\n\r\n    /* End of Switch: '<S40>/Switch2' */\r\n\r\n    /* Switch: '<S40>/Switch' */\r\n    FCEvReferenceApplication_B.Switch_b[1] =\r\n      FCEvReferenceApplication_B.PassThrough_b.u;\r\n  } else if (FCEvReferenceApplication_B.Gear != 0.0) {\r\n    /* Switch: '<S40>/Switch' incorporates:\r\n     *  Switch: '<S40>/Switch1'\r\n     */\r\n    FCEvReferenceApplication_B.Switch_b[0] =\r\n      FCEvReferenceApplication_B.PassThrough_b.u;\r\n    FCEvReferenceApplication_B.Switch_b[1] =\r\n      FCEvReferenceApplication_B.PassThrough.u;\r\n  } else {\r\n    /* Switch: '<S40>/Switch' incorporates:\r\n     *  MinMax: '<S40>/MinMax'\r\n     *  Switch: '<S40>/Switch1'\r\n     */\r\n    FCEvReferenceApplication_B.Switch_b[0] =\r\n      FCEvReferenceApplication_B.Constant_l;\r\n    FCEvReferenceApplication_B.Switch_b[1] = fmax\r\n      (FCEvReferenceApplication_B.PassThrough_b.u,\r\n       FCEvReferenceApplication_B.PassThrough.u);\r\n  }\r\n\r\n  /* End of Switch: '<S40>/Switch' */\r\n\r\n  /* RateTransition: '<S7>/Rate Transition' incorporates:\r\n   *  RateTransition: '<S7>/Rate Transition1'\r\n   */\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    if (FCEvReferenceApplication_DW.RateTransition_semaphoreTaken == 0) {\r\n      FCEvReferenceApplication_DW.RateTransition_Buffer0 =\r\n        FCEvReferenceApplication_B.Switch_b[0];\r\n    }\r\n\r\n    if (FCEvReferenceApplication_DW.RateTransition1_semaphoreTake_h == 0) {\r\n      FCEvReferenceApplication_DW.RateTransition1_Buffer0_m =\r\n        FCEvReferenceApplication_B.Switch_b[1];\r\n    }\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition' */\r\n    FCEvReferenceApplication_B.RateTransition =\r\n      FCEvReferenceApplication_DW.RateTransition_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition_semaphoreTaken = 0;\r\n  }\r\n\r\n  /* End of RateTransition: '<S7>/Rate Transition' */\r\n\r\n  /* RateTransition: '<S7>/Rate Transition2' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition2_semaphoreTaken == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition2_Buffer0 =\r\n      FCEvReferenceApplication_B.xdot;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition1' */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition1_semaphoreTake_h = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition1' */\r\n    FCEvReferenceApplication_B.RateTransition1 =\r\n      FCEvReferenceApplication_DW.RateTransition1_Buffer0_m;\r\n    FCEvReferenceApplication_DW.RateTransition1_semaphoreTake_h = 0;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition3' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition3_semaphoreTaken == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition3_Buffer0 =\r\n      FCEvReferenceApplication_B.BattSoc;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition2' */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition2_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition2' */\r\n    FCEvReferenceApplication_B.RateTransition2 =\r\n      FCEvReferenceApplication_DW.RateTransition2_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition2_semaphoreTaken = 0;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition6' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition6_semaphoreTaken == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition6_Buffer0 =\r\n      FCEvReferenceApplication_B.MotSpd;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition3' */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition3_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition3' */\r\n    FCEvReferenceApplication_B.RateTransition3 =\r\n      FCEvReferenceApplication_DW.RateTransition3_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition3_semaphoreTaken = 0;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition7' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition7_semaphoreTaken == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition7_Buffer0 =\r\n      FCEvReferenceApplication_B.ElectricPlant_o5;\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition6' incorporates:\r\n   *  RateTransition: '<S7>/Rate Transition7'\r\n   */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition6_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition6' */\r\n    FCEvReferenceApplication_B.RateTransition6 =\r\n      FCEvReferenceApplication_DW.RateTransition6_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition6_semaphoreTaken = 0;\r\n    FCEvReferenceApplication_DW.RateTransition7_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition7' */\r\n    FCEvReferenceApplication_B.RateTransition7 =\r\n      FCEvReferenceApplication_DW.RateTransition7_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition7_semaphoreTaken = 0;\r\n\r\n    /* ModelReference: '<S1>/Powertrain Control Module (PCM)' */\r\n    FCEvPowertrainController\r\n      (&(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtm),\r\n       &FCEvReferenceApplication_B.RateTransition,\r\n       &FCEvReferenceApplication_B.RateTransition1,\r\n       &FCEvReferenceApplication_B.RateTransition2,\r\n       &FCEvReferenceApplication_B.RateTransition3,\r\n       &FCEvReferenceApplication_B.RateTransition6,\r\n       &FCEvReferenceApplication_B.RateTransition7,\r\n       &FCEvReferenceApplication_B.Gain_g,\r\n       &FCEvReferenceApplication_B.MotTrqCmd_j,\r\n       &FCEvReferenceApplication_B.BrkCmd,\r\n       &FCEvReferenceApplication_B.PowertrainControlModulePCM_o3,\r\n       &rtb_PowertrainControlModulePCM_, &rtb_PowertrainControlModulePC_h,\r\n       &rtb_PowertrainControlModulePC_m,\r\n       &(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtb),\r\n       &(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtdw));\r\n\r\n    /* Gain: '<Root>/Gain2' */\r\n    FCEvReferenceApplication_B.Gain2 = FCEvReferenceApplication_P.Gain2_Gain *\r\n      rtb_PowertrainControlModulePC_h;\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    /* ToWorkspace: '<Root>/To Workspace' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace_PWORK.LoggedData),\r\n                      &FCEvReferenceApplication_B.Gain2, 0);\r\n    }\r\n\r\n    /* ToWorkspace: '<Root>/To Workspace1' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace1_PWORK.LoggedData),\r\n                      &FCEvReferenceApplication_B.ElectricPlant_o9, 0);\r\n    }\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    /* Saturate: '<Root>/Saturation' */\r\n    if (rtb_PowertrainControlModulePC_m >\r\n        FCEvReferenceApplication_P.Saturation_UpperSat_eq) {\r\n      rtb_Saturation_k = FCEvReferenceApplication_P.Saturation_UpperSat_eq;\r\n    } else if (rtb_PowertrainControlModulePC_m <\r\n               FCEvReferenceApplication_P.Saturation_LowerSat_l) {\r\n      rtb_Saturation_k = FCEvReferenceApplication_P.Saturation_LowerSat_l;\r\n    } else {\r\n      rtb_Saturation_k = rtb_PowertrainControlModulePC_m;\r\n    }\r\n\r\n    /* Gain: '<Root>/Gain1' incorporates:\r\n     *  Saturate: '<Root>/Saturation'\r\n     */\r\n    FCEvReferenceApplication_B.Gain1 = FCEvReferenceApplication_P.Gain1_Gain *\r\n      rtb_Saturation_k;\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    /* ToWorkspace: '<Root>/To Workspace2' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace2_PWORK.LoggedData),\r\n                      &FCEvReferenceApplication_B.Gain1, 0);\r\n    }\r\n  }\r\n\r\n  /* RateTransition: '<S7>/Rate Transition4' incorporates:\r\n   *  RateTransition: '<S7>/Rate Transition5'\r\n   */\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    if (FCEvReferenceApplication_DW.RateTransition4_semaphoreTaken == 0) {\r\n      FCEvReferenceApplication_DW.RateTransition4_Buffer0 =\r\n        FCEvReferenceApplication_B.BattPwr;\r\n    }\r\n\r\n    if (FCEvReferenceApplication_DW.RateTransition5_semaphoreTaken == 0) {\r\n      FCEvReferenceApplication_DW.RateTransition5_Buffer0 =\r\n        FCEvReferenceApplication_B.BattCurr;\r\n    }\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition4_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition4' */\r\n    FCEvReferenceApplication_B.RateTransition4 =\r\n      FCEvReferenceApplication_DW.RateTransition4_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition4_semaphoreTaken = 0;\r\n    FCEvReferenceApplication_DW.RateTransition5_semaphoreTaken = 1;\r\n\r\n    /* RateTransition: '<S7>/Rate Transition5' */\r\n    FCEvReferenceApplication_B.RateTransition5 =\r\n      FCEvReferenceApplication_DW.RateTransition5_Buffer0;\r\n    FCEvReferenceApplication_DW.RateTransition5_semaphoreTaken = 0;\r\n  }\r\n\r\n  /* End of RateTransition: '<S7>/Rate Transition4' */\r\n  if (ssIsSampleHit(rtS, 3, 0)) {\r\n    /* DigitalClock: '<S11>/Digital Clock' */\r\n    FCEvReferenceApplication_B.DigitalClock = ssGetTaskTime(rtS,3);\r\n  }\r\n\r\n  /* Sum: '<S11>/Add1' */\r\n  FCEvReferenceApplication_B.Add1 = rtb_USMPG -\r\n    FCEvReferenceApplication_B.DigitalClock;\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Constant: '<S3>/Constant2' */\r\n    FCEvReferenceApplication_B.Grade =\r\n      FCEvReferenceApplication_P.Constant2_Value;\r\n\r\n    /* Constant: '<S3>/Constant3' */\r\n    FCEvReferenceApplication_B.wind_x =\r\n      FCEvReferenceApplication_P.Constant3_Value;\r\n  }\r\n\r\n  /* MATLAB Function: '<S25>/Setup' */\r\n  /* MATLAB Function 'Longitudinal Driver/Control/Predictive/Setup': '<S30>:1' */\r\n  /* '<S30>:1:5' */\r\n  rtb_Saturation_k = fabs(FCEvReferenceApplication_B.xdot);\r\n  rtb_RelationalOperator = (rtb_Saturation_k < 0.001);\r\n  trueCount = 0;\r\n  if (rtb_RelationalOperator) {\r\n    trueCount = 1;\r\n  }\r\n\r\n  if (trueCount - 1 >= 0) {\r\n    rtb_G_idx_1 = rtb_Saturation_k / 0.001;\r\n    sigmaB_idx_0 = 0.002 / (3.0 - rtb_G_idx_1 * rtb_G_idx_1);\r\n  }\r\n\r\n  if (rtb_RelationalOperator) {\r\n    rtb_Saturation_k = sigmaB_idx_0;\r\n  }\r\n\r\n  rtb_RelationalOperator = (FCEvReferenceApplication_B.xdot < 0.0);\r\n  trueCount = -1;\r\n  if (rtb_RelationalOperator) {\r\n    trueCount = 0;\r\n  }\r\n\r\n  if (trueCount >= 0) {\r\n    sigmaB_idx_0 = -rtb_Saturation_k;\r\n  }\r\n\r\n  rtb_G_idx_1 = rtb_Saturation_k;\r\n  if (rtb_RelationalOperator) {\r\n    rtb_G_idx_1 = sigmaB_idx_0;\r\n  }\r\n\r\n  if (rtb_Saturation_k > 5.0) {\r\n    rtb_Saturation_k = fmax(fmin\r\n      (FCEvReferenceApplication_P.LongitudinalDriverModel_tau,\r\n       FCEvReferenceApplication_P.LongitudinalDriverModel_L / rtb_Saturation_k),\r\n      0.001);\r\n  } else {\r\n    rtb_Saturation_k = FCEvReferenceApplication_P.LongitudinalDriverModel_tau;\r\n  }\r\n\r\n  rtb_F[0] = 0.0;\r\n  rtb_F[2] = 1.0;\r\n  rtb_F[1] = -((FCEvReferenceApplication_P.LongitudinalDriverModel_aR /\r\n                rtb_G_idx_1 +\r\n                FCEvReferenceApplication_P.LongitudinalDriverModel_cR *\r\n                FCEvReferenceApplication_B.xdot) * tanh\r\n               (FCEvReferenceApplication_B.xdot) +\r\n               FCEvReferenceApplication_P.LongitudinalDriverModel_bR) /\r\n    FCEvReferenceApplication_P.LongitudinalDriverModel_m;\r\n  rtb_F[3] = 0.0;\r\n  rtb_G_idx_1 = FCEvReferenceApplication_P.LongitudinalDriverModel_Kpt /\r\n    FCEvReferenceApplication_P.LongitudinalDriverModel_m;\r\n  sigmaA[0] = 0.0;\r\n  sigmaB_idx_0 = 0.0;\r\n  sigmaA[1] = 0.0;\r\n  sigmaB_idx_1 = 0.0;\r\n  sigmaA[2] = 0.0;\r\n  sigmaB_idx_2 = 0.0;\r\n  sigmaA[3] = 0.0;\r\n  sigmaB_idx_3 = 0.0;\r\n  for (trueCount = 0; trueCount < 15; trueCount++) {\r\n    real_T b_tmp;\r\n    real_T e;\r\n    real_T e_0;\r\n    real_T sigmaA_tmp;\r\n    FCEvReferenceApplication_mpower(rtb_F, (real_T)trueCount + 1.0, a_tmp);\r\n    b_tmp = rt_powd_snf(rtb_Saturation_k, (real_T)trueCount + 1.0);\r\n    e = e_1[trueCount + 1];\r\n    e_0 = e_1[trueCount];\r\n    sigmaA_tmp = a_tmp[0] * b_tmp;\r\n    sigmaA[0] += sigmaA_tmp / e;\r\n    sigmaB_idx_0 += sigmaA_tmp / e_0;\r\n    sigmaA_tmp = a_tmp[1] * b_tmp;\r\n    sigmaA[1] += sigmaA_tmp / e;\r\n    sigmaB_idx_1 += sigmaA_tmp / e_0;\r\n    sigmaA_tmp = a_tmp[2] * b_tmp;\r\n    sigmaA[2] += sigmaA_tmp / e;\r\n    sigmaB_idx_2 += sigmaA_tmp / e_0;\r\n    sigmaA_tmp = a_tmp[3] * b_tmp;\r\n    sigmaA[3] += sigmaA_tmp / e;\r\n    sigmaB_idx_3 += sigmaA_tmp / e_0;\r\n  }\r\n\r\n  rtb_Saturation_k = ((sigmaA[0] + 1.0) * rtb_Saturation_k + rtb_Saturation_k *\r\n                      sigmaA[1]) * 0.0 + ((sigmaA[3] + 1.0) * rtb_Saturation_k +\r\n    rtb_Saturation_k * sigmaA[2]) * rtb_G_idx_1;\r\n\r\n  /* MATLAB Function: '<S25>/Vehicle' */\r\n  /* '<S30>:1:5' */\r\n  /* MATLAB Function 'Longitudinal Driver/Control/Predictive/Vehicle': '<S31>:1' */\r\n  /* '<S31>:1:4' */\r\n  a_tmp[0] = 0.0;\r\n  a_tmp[1] = rtb_F[1] * 0.001;\r\n  a_tmp[2] = 0.001;\r\n  a_tmp[3] = 0.0;\r\n  FCEvReferenceApplication_expm(a_tmp, sigmaA);\r\n  a_tmp[0] = 0.0;\r\n  a_tmp[1] = rtb_F[1] * 0.0;\r\n  a_tmp[2] = 0.0;\r\n  a_tmp[3] = 0.0;\r\n  FCEvReferenceApplication_expm(a_tmp, b_a);\r\n  a_tmp[0] = 0.0;\r\n  a_tmp[1] = rtb_F[1] * 0.001;\r\n  a_tmp[2] = 0.001;\r\n  a_tmp[3] = 0.0;\r\n  FCEvReferenceApplication_expm(a_tmp, rtb_F);\r\n\r\n  /* Product: '<S25>/Product1' incorporates:\r\n   *  MATLAB Function: '<S25>/Setup'\r\n   *  MATLAB Function: '<S25>/Vehicle'\r\n   */\r\n  FCEvReferenceApplication_B.Product1 = (((b_a[0] * 0.0 + b_a[2] * rtb_G_idx_1)\r\n    + (rtb_F[0] * 0.0 + rtb_F[2] * rtb_G_idx_1)) / 2.0 * 0.001 *\r\n    FCEvReferenceApplication_B.Add + (sigmaA[0] *\r\n    FCEvReferenceApplication_B.xdot + sigmaA[2] * 0.0)) * ((sigmaB_idx_0 + 1.0)\r\n    + sigmaB_idx_1) + (((b_a[1] * 0.0 + b_a[3] * rtb_G_idx_1) + (rtb_F[1] * 0.0\r\n    + rtb_F[3] * rtb_G_idx_1)) / 2.0 * 0.001 * FCEvReferenceApplication_B.Add +\r\n                       (sigmaA[1] * FCEvReferenceApplication_B.xdot + sigmaA[3] *\r\n                        0.0)) * ((sigmaB_idx_3 + 1.0) + sigmaB_idx_2);\r\n\r\n  /* Product: '<S25>/Product' incorporates:\r\n   *  MATLAB Function: '<S25>/Setup'\r\n   */\r\n  FCEvReferenceApplication_B.Product = FCEvReferenceApplication_B.Add *\r\n    rtb_Saturation_k;\r\n\r\n  /* Sum: '<S25>/Add2' */\r\n  FCEvReferenceApplication_B.ytT = FCEvReferenceApplication_B.Product1 +\r\n    FCEvReferenceApplication_B.Product;\r\n\r\n  /* Sum: '<S25>/Add4' */\r\n  FCEvReferenceApplication_B.etT = FCEvReferenceApplication_B.uDLookupTable -\r\n    FCEvReferenceApplication_B.ytT;\r\n\r\n  /* Product: '<S25>/Divide' incorporates:\r\n   *  MATLAB Function: '<S25>/Setup'\r\n   */\r\n  FCEvReferenceApplication_B.Divide = FCEvReferenceApplication_B.etT /\r\n    rtb_Saturation_k;\r\n\r\n  /* Sum: '<S25>/Add1' */\r\n  FCEvReferenceApplication_B.u_ot = FCEvReferenceApplication_B.Divide +\r\n    FCEvReferenceApplication_B.Integrator1;\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Constant: '<S27>/Constant' */\r\n    FCEvReferenceApplication_B.Constant_a = 1.0 /\r\n      FCEvReferenceApplication_P.LongitudinalDriverModel_tau *\r\n      3.1415926535897931 * 2.0;\r\n  }\r\n\r\n  /* Sum: '<S27>/Sum' */\r\n  FCEvReferenceApplication_B.Sum = FCEvReferenceApplication_B.u_ot -\r\n    FCEvReferenceApplication_B.Integrator1;\r\n\r\n  /* Product: '<S27>/Divide' */\r\n  FCEvReferenceApplication_B.Divide_j = FCEvReferenceApplication_B.Sum *\r\n    FCEvReferenceApplication_B.Constant_a;\r\n\r\n  /* Sum: '<S20>/Sum7' */\r\n  FCEvReferenceApplication_B.Sum7 = FCEvReferenceApplication_B.uDLookupTable -\r\n    FCEvReferenceApplication_B.xdot;\r\n\r\n  /* Product: '<S38>/Product' incorporates:\r\n   *  UnitConversion: '<S23>/Unit Conversion'\r\n   */\r\n  /* Unit Conversion - from: m/s to: m/s\r\n     Expression: output = (1*input) + (0) */\r\n  FCEvReferenceApplication_B.Product_m = FCEvReferenceApplication_B.Sum7 *\r\n    FCEvReferenceApplication_B.Sum7;\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    /* UnitDelay: '<S38>/Unit Delay' */\r\n    FCEvReferenceApplication_B.UnitDelay[0] =\r\n      FCEvReferenceApplication_DW.UnitDelay_DSTATE[0];\r\n    FCEvReferenceApplication_B.UnitDelay[1] =\r\n      FCEvReferenceApplication_DW.UnitDelay_DSTATE[1];\r\n  }\r\n\r\n  /* Switch: '<S38>/Switch' incorporates:\r\n   *  RelationalOperator: '<S38>/Relational Operator'\r\n   *  RelationalOperator: '<S38>/Relational Operator1'\r\n   *  UnitConversion: '<S23>/Unit Conversion'\r\n   */\r\n  if (FCEvReferenceApplication_B.Sum7 > FCEvReferenceApplication_B.UnitDelay[0])\r\n  {\r\n    /* Switch: '<S38>/Switch' */\r\n    FCEvReferenceApplication_B.Switch_p[0] = FCEvReferenceApplication_B.Sum7;\r\n  } else {\r\n    /* Switch: '<S38>/Switch' */\r\n    FCEvReferenceApplication_B.Switch_p[0] =\r\n      FCEvReferenceApplication_B.UnitDelay[0];\r\n  }\r\n\r\n  if (FCEvReferenceApplication_B.Sum7 < FCEvReferenceApplication_B.UnitDelay[1])\r\n  {\r\n    /* Switch: '<S38>/Switch' */\r\n    FCEvReferenceApplication_B.Switch_p[1] = FCEvReferenceApplication_B.Sum7;\r\n  } else {\r\n    /* Switch: '<S38>/Switch' */\r\n    FCEvReferenceApplication_B.Switch_p[1] =\r\n      FCEvReferenceApplication_B.UnitDelay[1];\r\n  }\r\n\r\n  /* End of Switch: '<S38>/Switch' */\r\n\r\n  /* TransferFcn: '<S45>/Motor Coupling Dynamics' */\r\n  FCEvReferenceApplication_B.MotTrq_f = 0.0;\r\n  FCEvReferenceApplication_B.MotTrq_f +=\r\n    FCEvReferenceApplication_P.MotorCouplingDynamics_C *\r\n    FCEvReferenceApplication_X.MotorCouplingDynamics_CSTATE;\r\n\r\n  /* FirstOrderHold: '<S45>/First Order Hold' */\r\n  FCEvReferenceApplication_B.BrkCmd_f = FCEvReferenceApplication_DW.Ck_g;\r\n\r\n  /* FirstOrderHold: '<S45>/First Order Hold' */\r\n  if (FCEvReferenceApplication_DW.Tk_a != (rtInf)) {\r\n    /* FirstOrderHold: '<S45>/First Order Hold' */\r\n    FCEvReferenceApplication_B.BrkCmd_f += (rtb_USMPG -\r\n      FCEvReferenceApplication_DW.Tk_a) * FCEvReferenceApplication_DW.Mk_h;\r\n  }\r\n\r\n  /* Gain: '<S6>/m//s to mph' */\r\n  FCEvReferenceApplication_B.mstomph[0] =\r\n    FCEvReferenceApplication_P.mstomph_Gain *\r\n    FCEvReferenceApplication_B.uDLookupTable;\r\n  FCEvReferenceApplication_B.mstomph[1] =\r\n    FCEvReferenceApplication_P.mstomph_Gain * FCEvReferenceApplication_B.xdot;\r\n\r\n  /* RateTransition: '<S6>/Rate Transition4' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition4_semaphoreTake_d == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition4_Buffer0_b[0] =\r\n      FCEvReferenceApplication_B.mstomph[0];\r\n    FCEvReferenceApplication_DW.RateTransition4_Buffer0_b[1] =\r\n      FCEvReferenceApplication_B.mstomph[1];\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition4_semaphoreTake_d = 1;\r\n    rtb_TraceVelocityTargetActualmp[0] =\r\n      FCEvReferenceApplication_DW.RateTransition4_Buffer0_b[0];\r\n    rtb_TraceVelocityTargetActualmp[1] =\r\n      FCEvReferenceApplication_DW.RateTransition4_Buffer0_b[1];\r\n    FCEvReferenceApplication_DW.RateTransition4_semaphoreTake_d = 0;\r\n  }\r\n\r\n  /* End of RateTransition: '<S6>/Rate Transition4' */\r\n\r\n  /* Gain: '<S6>/rad//s to RPM' */\r\n  FCEvReferenceApplication_B.radstoRPM =\r\n    FCEvReferenceApplication_P.radstoRPM_Gain *\r\n    FCEvReferenceApplication_B.MotSpd;\r\n\r\n  /* RateTransition: '<S6>/Rate Transition2' incorporates:\r\n   *  RateTransition: '<S6>/Rate Transition5'\r\n   */\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    if (FCEvReferenceApplication_DW.RateTransition2_semaphoreTake_p == 0) {\r\n      FCEvReferenceApplication_DW.RateTransition2_Buffer0_k =\r\n        FCEvReferenceApplication_B.radstoRPM;\r\n    }\r\n\r\n    if (FCEvReferenceApplication_DW.RateTransition5_semaphoreTake_i == 0) {\r\n      FCEvReferenceApplication_DW.RateTransition5_Buffer0_d =\r\n        FCEvReferenceApplication_B.MotTrq;\r\n    }\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition2_semaphoreTake_p = 1;\r\n    rtb_MotorSpeedRPM = FCEvReferenceApplication_DW.RateTransition2_Buffer0_k;\r\n    FCEvReferenceApplication_DW.RateTransition2_semaphoreTake_p = 0;\r\n  }\r\n\r\n  /* End of RateTransition: '<S6>/Rate Transition2' */\r\n\r\n  /* RateTransition: '<S6>/Rate Transition6' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition6_semaphoreTake_e == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition6_Buffer0_e =\r\n      FCEvReferenceApplication_B.BattCurr;\r\n  }\r\n\r\n  /* RateTransition: '<S6>/Rate Transition5' */\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition5_semaphoreTake_i = 1;\r\n    rtb_MotorTorqueNm = FCEvReferenceApplication_DW.RateTransition5_Buffer0_d;\r\n    FCEvReferenceApplication_DW.RateTransition5_semaphoreTake_i = 0;\r\n  }\r\n\r\n  /* RateTransition: '<S6>/Rate Transition3' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition3_semaphoreTake_e == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition3_Buffer0_d =\r\n      FCEvReferenceApplication_B.ElectricPlant_o5;\r\n  }\r\n\r\n  /* RateTransition: '<S6>/Rate Transition6' */\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition6_semaphoreTake_e = 1;\r\n    rtb_BatteryCurrentA = FCEvReferenceApplication_DW.RateTransition6_Buffer0_e;\r\n    FCEvReferenceApplication_DW.RateTransition6_semaphoreTake_e = 0;\r\n  }\r\n\r\n  /* RateTransition: '<S6>/Rate Transition7' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition7_semaphoreTake_h == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition7_Buffer0_j =\r\n      FCEvReferenceApplication_B.FCCurr;\r\n  }\r\n\r\n  /* RateTransition: '<S6>/Rate Transition3' incorporates:\r\n   *  RateTransition: '<S6>/Rate Transition7'\r\n   */\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition3_semaphoreTake_e = 1;\r\n    rtb_FuelCellVoltageV = FCEvReferenceApplication_DW.RateTransition3_Buffer0_d;\r\n    FCEvReferenceApplication_DW.RateTransition3_semaphoreTake_e = 0;\r\n    FCEvReferenceApplication_DW.RateTransition7_semaphoreTake_h = 1;\r\n    rtb_FuelCellCurrentA = FCEvReferenceApplication_DW.RateTransition7_Buffer0_j;\r\n    FCEvReferenceApplication_DW.RateTransition7_semaphoreTake_h = 0;\r\n  }\r\n\r\n  /* Integrator: '<S48>/Integrator' */\r\n  FCEvReferenceApplication_B.Integrator =\r\n    FCEvReferenceApplication_X.Integrator_CSTATE;\r\n\r\n  /* Integrator: '<S48>/Integrator1' */\r\n  FCEvReferenceApplication_B.Integrator1_d =\r\n    FCEvReferenceApplication_X.Integrator1_CSTATE_j;\r\n\r\n  /* Gain: '<S48>/m^3 to US Gal' */\r\n  FCEvReferenceApplication_B.m3toUSGal =\r\n    FCEvReferenceApplication_P.m3toUSGal_Gain *\r\n    FCEvReferenceApplication_B.Integrator1_d;\r\n\r\n  /* Saturate: '<S48>/Saturation1' */\r\n  if (ssIsModeUpdateTimeStep(rtS)) {\r\n    FCEvReferenceApplication_DW.Saturation1_MODE =\r\n      FCEvReferenceApplication_B.m3toUSGal >=\r\n      FCEvReferenceApplication_P.Saturation1_UpperSat ? 1 :\r\n      FCEvReferenceApplication_B.m3toUSGal >\r\n      FCEvReferenceApplication_P.Saturation1_LowerSat ? 0 : -1;\r\n  }\r\n\r\n  /* Product: '<S48>/US MPG Calc' incorporates:\r\n   *  Gain: '<S48>/m to mile'\r\n   *  Saturate: '<S48>/Saturation1'\r\n   */\r\n  FCEvReferenceApplication_B.USMPGCalc = FCEvReferenceApplication_P.mtomile_Gain\r\n    * FCEvReferenceApplication_B.Integrator /\r\n    (FCEvReferenceApplication_DW.Saturation1_MODE == 1 ?\r\n     FCEvReferenceApplication_P.Saturation1_UpperSat :\r\n     FCEvReferenceApplication_DW.Saturation1_MODE == -1 ?\r\n     FCEvReferenceApplication_P.Saturation1_LowerSat :\r\n     FCEvReferenceApplication_B.m3toUSGal);\r\n\r\n  /* RateTransition: '<S48>/Rate Transition3' */\r\n  if (ssIsSampleHit(rtS, 1, 0) &&\r\n      (FCEvReferenceApplication_DW.RateTransition3_semaphoreTake_g == 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition3_Buffer0_g =\r\n      FCEvReferenceApplication_B.USMPGCalc;\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    FCEvReferenceApplication_DW.RateTransition3_semaphoreTake_g = 1;\r\n    rtb_USMPG = FCEvReferenceApplication_DW.RateTransition3_Buffer0_g;\r\n    FCEvReferenceApplication_DW.RateTransition3_semaphoreTake_g = 0;\r\n\r\n    /* Product: '<S6>/Product' */\r\n    rtb_MotorSpeedRPM = rtb_FuelCellVoltageV * rtb_FuelCellCurrentA;\r\n  }\r\n\r\n  /* End of RateTransition: '<S48>/Rate Transition3' */\r\n\r\n  /* Gain: '<S48>/m to 100Km' */\r\n  FCEvReferenceApplication_B.mto100Km = FCEvReferenceApplication_P.mto100Km_Gain\r\n    * FCEvReferenceApplication_B.Integrator;\r\n\r\n  /* Saturate: '<S48>/Saturation' */\r\n  if (ssIsModeUpdateTimeStep(rtS)) {\r\n    FCEvReferenceApplication_DW.Saturation_MODE_k =\r\n      FCEvReferenceApplication_B.mto100Km >=\r\n      FCEvReferenceApplication_P.Saturation_UpperSat_d ? 1 :\r\n      FCEvReferenceApplication_B.mto100Km >\r\n      FCEvReferenceApplication_P.Saturation_LowerSat_ln ? 0 : -1;\r\n  }\r\n\r\n  /* Product: '<S48>/L//100 Km Calc' incorporates:\r\n   *  Gain: '<S48>/m^3 to L'\r\n   *  Saturate: '<S48>/Saturation'\r\n   */\r\n  FCEvReferenceApplication_B.L100Km = 1.0 /\r\n    (FCEvReferenceApplication_DW.Saturation_MODE_k == 1 ?\r\n     FCEvReferenceApplication_P.Saturation_UpperSat_d :\r\n     FCEvReferenceApplication_DW.Saturation_MODE_k == -1 ?\r\n     FCEvReferenceApplication_P.Saturation_LowerSat_ln :\r\n     FCEvReferenceApplication_B.mto100Km) *\r\n    (FCEvReferenceApplication_P.m3toL_Gain *\r\n     FCEvReferenceApplication_B.Integrator1_d);\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    /* ToWorkspace: '<S6>/To Workspace1' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace1_PWORK_c.LoggedData),\r\n                      &FCEvReferenceApplication_B.L100Km, 0);\r\n    }\r\n\r\n    /* ToWorkspace: '<S6>/To Workspace2' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace2_PWORK_i.LoggedData),\r\n                      &rtb_BatterySOC, 0);\r\n    }\r\n\r\n    /* ToWorkspace: '<S6>/To Workspace3' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace3_PWORK.LoggedData),\r\n                      &FCEvReferenceApplication_B.Gain, 0);\r\n    }\r\n\r\n    /* ToWorkspace: '<S6>/To Workspace4' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace4_PWORK.LoggedData),\r\n                      &FCEvReferenceApplication_B.Derivative, 0);\r\n    }\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Constant: '<S48>/w to kw' */\r\n    FCEvReferenceApplication_B.wtokw = FCEvReferenceApplication_P.wtokw_Value;\r\n\r\n    /* Constant: '<S48>/US EPA kwh//USgal equivalent' */\r\n    FCEvReferenceApplication_B.USEPAkwhUSgalequivalent =\r\n      FCEvReferenceApplication_P.USEPAkwhUSgalequivalent_Value;\r\n  }\r\n\r\n  /* Product: '<S48>/Divide' */\r\n  FCEvReferenceApplication_B.Divide_c = FCEvReferenceApplication_B.BattPwr /\r\n    FCEvReferenceApplication_B.wtokw;\r\n\r\n  /* Product: '<S48>/Divide2' */\r\n  FCEvReferenceApplication_B.Divide2 = FCEvReferenceApplication_B.Divide_c /\r\n    FCEvReferenceApplication_B.USEPAkwhUSgalequivalent;\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* Constant: '<S48>/s per h' */\r\n    FCEvReferenceApplication_B.sperh = FCEvReferenceApplication_P.sperh_Value;\r\n  }\r\n\r\n  /* Product: '<S48>/Divide1' */\r\n  FCEvReferenceApplication_B.GasGallonss = FCEvReferenceApplication_B.Divide2 /\r\n    FCEvReferenceApplication_B.sperh;\r\n\r\n  /* Gain: '<S48>/kg//s to Gas gal//s' */\r\n  FCEvReferenceApplication_B.Gasgals =\r\n    FCEvReferenceApplication_P.kgstoGasgals_Gain *\r\n    FCEvReferenceApplication_B.H2Flow;\r\n\r\n  /* Sum: '<S48>/Add' */\r\n  FCEvReferenceApplication_B.Add_b = FCEvReferenceApplication_B.GasGallonss +\r\n    FCEvReferenceApplication_B.Gasgals;\r\n\r\n  /* Product: '<S48>/Product' */\r\n  FCEvReferenceApplication_B.Product_e = FCEvReferenceApplication_B.xdot *\r\n    FCEvReferenceApplication_B.xdot;\r\n\r\n  /* Sqrt: '<S48>/Sqrt' */\r\n  if (ssIsMajorTimeStep(rtS)) {\r\n    if (FCEvReferenceApplication_DW.Sqrt_DWORK1 != 0) {\r\n      ssSetBlockStateForSolverChangedAtMajorStep(rtS);\r\n      ssSetContTimeOutputInconsistentWithStateAtMajorStep(rtS);\r\n      FCEvReferenceApplication_DW.Sqrt_DWORK1 = 0;\r\n    }\r\n\r\n    /* Sqrt: '<S48>/Sqrt' */\r\n    FCEvReferenceApplication_B.Sqrt = sqrt(FCEvReferenceApplication_B.Product_e);\r\n  } else {\r\n    if (FCEvReferenceApplication_B.Product_e < 0.0) {\r\n      /* Sqrt: '<S48>/Sqrt' */\r\n      FCEvReferenceApplication_B.Sqrt = -sqrt(fabs\r\n        (FCEvReferenceApplication_B.Product_e));\r\n    } else {\r\n      /* Sqrt: '<S48>/Sqrt' */\r\n      FCEvReferenceApplication_B.Sqrt = sqrt\r\n        (FCEvReferenceApplication_B.Product_e);\r\n    }\r\n\r\n    if (FCEvReferenceApplication_B.Product_e < 0.0) {\r\n      FCEvReferenceApplication_DW.Sqrt_DWORK1 = 1;\r\n    }\r\n  }\r\n\r\n  /* End of Sqrt: '<S48>/Sqrt' */\r\n\r\n  /* Gain: '<S48>/m^3 per gal' */\r\n  FCEvReferenceApplication_B.m3pergal = FCEvReferenceApplication_P.m3pergal_Gain\r\n    * FCEvReferenceApplication_B.Add_b;\r\n\r\n  /* Clock: '<Root>/Clock' */\r\n  FCEvReferenceApplication_B.Clock = rtb_USMPG_tmp;\r\n  if (ssIsSampleHit(rtS, 1, 0)) {\r\n    /* RelationalOperator: '<Root>/Relational Operator' incorporates:\r\n     *  Constant: '<Root>/pause_time'\r\n     */\r\n    if (ssIsModeUpdateTimeStep(rtS)) {\r\n      FCEvReferenceApplication_DW.RelationalOperator_Mode =\r\n        (FCEvReferenceApplication_B.Clock <=\r\n         FCEvReferenceApplication_P.pause_time_Value);\r\n    }\r\n\r\n    /* Assertion: '<Root>/Assertion' incorporates:\r\n     *  RelationalOperator: '<Root>/Relational Operator'\r\n     */\r\n    utAssert(FCEvReferenceApplication_DW.RelationalOperator_Mode);\r\n  }\r\n\r\n  if (ssIsSampleHit(rtS, 4, 0)) {\r\n    /* ToWorkspace: '<Root>/To Workspace3' */\r\n    if (ssGetLogOutput(rtS)) {\r\n      rt_UpdateLogVar((LogVar *)(LogVar*)\r\n                      (FCEvReferenceApplication_DW.ToWorkspace3_PWORK_j.LoggedData),\r\n                      &FCEvReferenceApplication_B.Clock, 0);\r\n    }\r\n  }\r\n\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\nvoid MdlUpdate(int_T tid)\r\n{\r\n  real_T err;\r\n  real_T tol;\r\n  real_T *lastU;\r\n  boolean_T guard1 = false;\r\n\r\n  /* Update for FirstOrderHold: '<S46>/First Order Hold' */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    guard1 = false;\r\n    if (!(FCEvReferenceApplication_DW.Tk == (rtInf))) {\r\n      if ((FCEvReferenceApplication_B.MotTrqCmd_j >= -1.0) &&\r\n          (FCEvReferenceApplication_B.MotTrqCmd_j <= 1.0)) {\r\n        tol = FCEvReferenceApplication_P.FirstOrderHold_ErrTol;\r\n      } else if (FCEvReferenceApplication_B.MotTrqCmd_j > 1.0) {\r\n        tol = FCEvReferenceApplication_B.MotTrqCmd_j *\r\n          FCEvReferenceApplication_P.FirstOrderHold_ErrTol;\r\n      } else {\r\n        tol = -(FCEvReferenceApplication_B.MotTrqCmd_j *\r\n                FCEvReferenceApplication_P.FirstOrderHold_ErrTol);\r\n      }\r\n\r\n      err = FCEvReferenceApplication_B.MotTrqCmd -\r\n        FCEvReferenceApplication_B.MotTrqCmd_j;\r\n      if ((err > tol) || (err < -tol)) {\r\n        guard1 = true;\r\n      } else {\r\n        FCEvReferenceApplication_DW.Mk = (FCEvReferenceApplication_B.MotTrqCmd_j\r\n          - FCEvReferenceApplication_DW.Uk) / (ssGetT(rtS) -\r\n          FCEvReferenceApplication_DW.Tk);\r\n        FCEvReferenceApplication_DW.Ck = FCEvReferenceApplication_B.MotTrqCmd;\r\n      }\r\n    } else {\r\n      guard1 = true;\r\n    }\r\n\r\n    if (guard1) {\r\n      if (FCEvReferenceApplication_B.MotTrqCmd_j !=\r\n          FCEvReferenceApplication_B.MotTrqCmd) {\r\n        ssSetBlockStateForSolverChangedAtMajorStep(rtS);\r\n        ssSetContTimeOutputInconsistentWithStateAtMajorStep(rtS);\r\n      }\r\n\r\n      FCEvReferenceApplication_DW.Ck = FCEvReferenceApplication_B.MotTrqCmd_j;\r\n      FCEvReferenceApplication_DW.Mk = 0.0;\r\n    }\r\n\r\n    FCEvReferenceApplication_DW.Uk = FCEvReferenceApplication_B.MotTrqCmd_j;\r\n    FCEvReferenceApplication_DW.Tk = ssGetT(rtS);\r\n  }\r\n\r\n  /* End of Update for FirstOrderHold: '<S46>/First Order Hold' */\r\n\r\n  /* Update for ModelReference: '<S5>/Drivetrain' */\r\n  DrivetrainEv_Update(&(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtm),\r\n                      &FCEvReferenceApplication_B.MotTrq_f,\r\n                      &FCEvReferenceApplication_B.BrkCmd_f,\r\n                      &FCEvReferenceApplication_B.Grade,\r\n                      &FCEvReferenceApplication_B.wind_x,\r\n                      &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n                      &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw),\r\n                      &(FCEvReferenceApplication_X.Drivetrain_CSTATE),\r\n                      &(((XDis_FCEvReferenceApplication_T *)\r\n    ssGetContStateDisabled(rtS))->Drivetrain_CSTATE));\r\n\r\n  /* Update for FirstOrderHold: '<S46>/First Order Hold1' */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    guard1 = false;\r\n    if (!(FCEvReferenceApplication_DW.Tk_o == (rtInf))) {\r\n      if ((FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 >= -1.0) &&\r\n          (FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 <= 1.0)) {\r\n        tol = FCEvReferenceApplication_P.FirstOrderHold1_ErrTol;\r\n      } else if (FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 > 1.0)\r\n      {\r\n        tol = FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 *\r\n          FCEvReferenceApplication_P.FirstOrderHold1_ErrTol;\r\n      } else {\r\n        tol = -(FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 *\r\n                FCEvReferenceApplication_P.FirstOrderHold1_ErrTol);\r\n      }\r\n\r\n      err = FCEvReferenceApplication_B.FCCurrCmd -\r\n        FCEvReferenceApplication_B.PowertrainControlModulePCM_o3;\r\n      if ((err > tol) || (err < -tol)) {\r\n        guard1 = true;\r\n      } else {\r\n        FCEvReferenceApplication_DW.Mk_e =\r\n          (FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 -\r\n           FCEvReferenceApplication_DW.Uk_j) / (ssGetT(rtS) -\r\n          FCEvReferenceApplication_DW.Tk_o);\r\n        FCEvReferenceApplication_DW.Ck_d = FCEvReferenceApplication_B.FCCurrCmd;\r\n      }\r\n    } else {\r\n      guard1 = true;\r\n    }\r\n\r\n    if (guard1) {\r\n      if (FCEvReferenceApplication_B.PowertrainControlModulePCM_o3 !=\r\n          FCEvReferenceApplication_B.FCCurrCmd) {\r\n        ssSetBlockStateForSolverChangedAtMajorStep(rtS);\r\n        ssSetContTimeOutputInconsistentWithStateAtMajorStep(rtS);\r\n      }\r\n\r\n      FCEvReferenceApplication_DW.Ck_d =\r\n        FCEvReferenceApplication_B.PowertrainControlModulePCM_o3;\r\n      FCEvReferenceApplication_DW.Mk_e = 0.0;\r\n    }\r\n\r\n    FCEvReferenceApplication_DW.Uk_j =\r\n      FCEvReferenceApplication_B.PowertrainControlModulePCM_o3;\r\n    FCEvReferenceApplication_DW.Tk_o = ssGetT(rtS);\r\n  }\r\n\r\n  /* End of Update for FirstOrderHold: '<S46>/First Order Hold1' */\r\n\r\n  /* Update for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_Update\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE));\r\n\r\n  /* Update for Derivative: '<S6>/Derivative' */\r\n  if (FCEvReferenceApplication_DW.TimeStampA == (rtInf)) {\r\n    FCEvReferenceApplication_DW.TimeStampA = ssGetT(rtS);\r\n    lastU = &FCEvReferenceApplication_DW.LastUAtTimeA;\r\n  } else if (FCEvReferenceApplication_DW.TimeStampB == (rtInf)) {\r\n    FCEvReferenceApplication_DW.TimeStampB = ssGetT(rtS);\r\n    lastU = &FCEvReferenceApplication_DW.LastUAtTimeB;\r\n  } else if (FCEvReferenceApplication_DW.TimeStampA <\r\n             FCEvReferenceApplication_DW.TimeStampB) {\r\n    FCEvReferenceApplication_DW.TimeStampA = ssGetT(rtS);\r\n    lastU = &FCEvReferenceApplication_DW.LastUAtTimeA;\r\n  } else {\r\n    FCEvReferenceApplication_DW.TimeStampB = ssGetT(rtS);\r\n    lastU = &FCEvReferenceApplication_DW.LastUAtTimeB;\r\n  }\r\n\r\n  *lastU = FCEvReferenceApplication_B.Gain;\r\n\r\n  /* End of Update for Derivative: '<S6>/Derivative' */\r\n  if (ssIsSampleHit(rtS, 2, 0)) {\r\n    /* Update for ModelReference: '<S1>/Powertrain Control Module (PCM)' */\r\n    FCEvPowertrainController_Update\r\n      (&(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtb),\r\n       &(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtdw));\r\n\r\n    /* Update for UnitDelay: '<S38>/Unit Delay' */\r\n    FCEvReferenceApplication_DW.UnitDelay_DSTATE[0] =\r\n      FCEvReferenceApplication_B.Switch_p[0];\r\n    FCEvReferenceApplication_DW.UnitDelay_DSTATE[1] =\r\n      FCEvReferenceApplication_B.Switch_p[1];\r\n\r\n    /* Update for FirstOrderHold: '<S45>/First Order Hold' */\r\n    guard1 = false;\r\n    if (!(FCEvReferenceApplication_DW.Tk_a == (rtInf))) {\r\n      if ((FCEvReferenceApplication_B.BrkCmd >= -1.0) &&\r\n          (FCEvReferenceApplication_B.BrkCmd <= 1.0)) {\r\n        tol = FCEvReferenceApplication_P.FirstOrderHold_ErrTol_e;\r\n      } else if (FCEvReferenceApplication_B.BrkCmd > 1.0) {\r\n        tol = FCEvReferenceApplication_B.BrkCmd *\r\n          FCEvReferenceApplication_P.FirstOrderHold_ErrTol_e;\r\n      } else {\r\n        tol = -(FCEvReferenceApplication_B.BrkCmd *\r\n                FCEvReferenceApplication_P.FirstOrderHold_ErrTol_e);\r\n      }\r\n\r\n      err = FCEvReferenceApplication_B.BrkCmd_f -\r\n        FCEvReferenceApplication_B.BrkCmd;\r\n      if ((err > tol) || (err < -tol)) {\r\n        guard1 = true;\r\n      } else {\r\n        FCEvReferenceApplication_DW.Mk_h = (FCEvReferenceApplication_B.BrkCmd -\r\n          FCEvReferenceApplication_DW.Uk_h) / (ssGetT(rtS) -\r\n          FCEvReferenceApplication_DW.Tk_a);\r\n        FCEvReferenceApplication_DW.Ck_g = FCEvReferenceApplication_B.BrkCmd_f;\r\n      }\r\n    } else {\r\n      guard1 = true;\r\n    }\r\n\r\n    if (guard1) {\r\n      if (FCEvReferenceApplication_B.BrkCmd !=\r\n          FCEvReferenceApplication_B.BrkCmd_f) {\r\n        ssSetBlockStateForSolverChangedAtMajorStep(rtS);\r\n        ssSetContTimeOutputInconsistentWithStateAtMajorStep(rtS);\r\n      }\r\n\r\n      FCEvReferenceApplication_DW.Ck_g = FCEvReferenceApplication_B.BrkCmd;\r\n      FCEvReferenceApplication_DW.Mk_h = 0.0;\r\n    }\r\n\r\n    FCEvReferenceApplication_DW.Uk_h = FCEvReferenceApplication_B.BrkCmd;\r\n    FCEvReferenceApplication_DW.Tk_a = ssGetT(rtS);\r\n\r\n    /* End of Update for FirstOrderHold: '<S45>/First Order Hold' */\r\n  }\r\n\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid MdlDerivatives(void)\r\n{\r\n  XDot_FCEvReferenceApplication_T *_rtXdot;\r\n  _rtXdot = ((XDot_FCEvReferenceApplication_T *) ssGetdX(rtS));\r\n\r\n  /* Derivatives for ModelReference: '<S5>/Drivetrain' */\r\n  DrivetrainEv_Deriv(&(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtm),\r\n                     &FCEvReferenceApplication_B.MotTrq_f,\r\n                     &FCEvReferenceApplication_B.BrkCmd_f,\r\n                     &FCEvReferenceApplication_B.Grade,\r\n                     &FCEvReferenceApplication_B.wind_x,\r\n                     &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n                     &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw),\r\n                     &(FCEvReferenceApplication_X.Drivetrain_CSTATE),\r\n                     &(((XDot_FCEvReferenceApplication_T *) ssGetdX(rtS))\r\n                       ->Drivetrain_CSTATE), &(((XDis_FCEvReferenceApplication_T\r\n    *) ssGetContStateDisabled(rtS))->Drivetrain_CSTATE));\r\n\r\n  /* Derivatives for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_Deriv\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &FCEvReferenceApplication_B.MotSpd,\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE),\r\n     &(((XDot_FCEvReferenceApplication_T *) ssGetdX(rtS))->ElectricPlant_CSTATE));\r\n\r\n  /* Derivatives for Integrator: '<S27>/Integrator1' */\r\n  _rtXdot->Integrator1_CSTATE = FCEvReferenceApplication_B.Divide_j;\r\n\r\n  /* Derivatives for Integrator: '<S38>/Integrator2' */\r\n  _rtXdot->Integrator2_CSTATE = FCEvReferenceApplication_B.Product_m;\r\n\r\n  /* Derivatives for TransferFcn: '<S45>/Motor Coupling Dynamics' */\r\n  _rtXdot->MotorCouplingDynamics_CSTATE = 0.0;\r\n  _rtXdot->MotorCouplingDynamics_CSTATE +=\r\n    FCEvReferenceApplication_P.MotorCouplingDynamics_A *\r\n    FCEvReferenceApplication_X.MotorCouplingDynamics_CSTATE;\r\n  _rtXdot->MotorCouplingDynamics_CSTATE += FCEvReferenceApplication_B.MotTrq;\r\n\r\n  /* Derivatives for Integrator: '<S48>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = FCEvReferenceApplication_B.Sqrt;\r\n\r\n  /* Derivatives for Integrator: '<S48>/Integrator1' */\r\n  _rtXdot->Integrator1_CSTATE_j = FCEvReferenceApplication_B.m3pergal;\r\n}\r\n\r\n/* Projection for root system: '<Root>' */\r\nvoid MdlProjection(void)\r\n{\r\n  /* Projection for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_Projection\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE));\r\n}\r\n\r\n/* ForcingFunction for root system: '<Root>' */\r\nvoid MdlForcingFunction(void)\r\n{\r\n  XDot_FCEvReferenceApplication_T *_rtXdot;\r\n  _rtXdot = ((XDot_FCEvReferenceApplication_T *) ssGetdX(rtS));\r\n\r\n  /* ForcingFunction for ModelReference: '<S5>/Drivetrain' */\r\n  DrivetrainEv_Deriv(&(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtm),\r\n                     &FCEvReferenceApplication_B.MotTrq_f,\r\n                     &FCEvReferenceApplication_B.BrkCmd_f,\r\n                     &FCEvReferenceApplication_B.Grade,\r\n                     &FCEvReferenceApplication_B.wind_x,\r\n                     &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n                     &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw),\r\n                     &(FCEvReferenceApplication_X.Drivetrain_CSTATE),\r\n                     &(((XDot_FCEvReferenceApplication_T *) ssGetdX(rtS))\r\n                       ->Drivetrain_CSTATE), &(((XDis_FCEvReferenceApplication_T\r\n    *) ssGetContStateDisabled(rtS))->Drivetrain_CSTATE));\r\n\r\n  /* ForcingFunction for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_ForcingFunction\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &FCEvReferenceApplication_B.MotSpd,\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE),\r\n     &(((XDot_FCEvReferenceApplication_T *) ssGetdX(rtS))->ElectricPlant_CSTATE));\r\n\r\n  /* ForcingFunction for Integrator: '<S27>/Integrator1' */\r\n  _rtXdot->Integrator1_CSTATE = FCEvReferenceApplication_B.Divide_j;\r\n\r\n  /* ForcingFunction for Integrator: '<S38>/Integrator2' */\r\n  _rtXdot->Integrator2_CSTATE = FCEvReferenceApplication_B.Product_m;\r\n\r\n  /* ForcingFunction for TransferFcn: '<S45>/Motor Coupling Dynamics' */\r\n  _rtXdot->MotorCouplingDynamics_CSTATE = 0.0;\r\n  _rtXdot->MotorCouplingDynamics_CSTATE +=\r\n    FCEvReferenceApplication_P.MotorCouplingDynamics_A *\r\n    FCEvReferenceApplication_X.MotorCouplingDynamics_CSTATE;\r\n  _rtXdot->MotorCouplingDynamics_CSTATE += FCEvReferenceApplication_B.MotTrq;\r\n\r\n  /* ForcingFunction for Integrator: '<S48>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = FCEvReferenceApplication_B.Sqrt;\r\n\r\n  /* ForcingFunction for Integrator: '<S48>/Integrator1' */\r\n  _rtXdot->Integrator1_CSTATE_j = FCEvReferenceApplication_B.m3pergal;\r\n}\r\n\r\n/* MassMatrix for root system: '<Root>' */\r\nvoid MdlMassMatrix(void)\r\n{\r\n  /* MassMatrix for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_l_MassMatrix\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE));\r\n}\r\n\r\n/* ZeroCrossings for root system: '<Root>' */\r\nvoid MdlZeroCrossings(void)\r\n{\r\n  ZCV_FCEvReferenceApplication_T *_rtZCSV;\r\n  _rtZCSV = ((ZCV_FCEvReferenceApplication_T *) ssGetSolverZcSignalVector(rtS));\r\n\r\n  /* ZeroCrossings for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_ZC\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n     &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n     &(FCEvReferenceApplication_X.ElectricPlant_CSTATE),\r\n     &(((ZCV_FCEvReferenceApplication_T *) ssGetSolverZcSignalVector(rtS))\r\n       ->ElectricPlant_Reset_ZC));\r\n\r\n  /* ZeroCrossings for Saturate: '<S6>/Saturation' */\r\n  _rtZCSV->Saturation_UprLim_ZC = FCEvReferenceApplication_B.xdot -\r\n    FCEvReferenceApplication_P.Saturation_UpperSat;\r\n  _rtZCSV->Saturation_LwrLim_ZC = FCEvReferenceApplication_B.xdot -\r\n    FCEvReferenceApplication_P.Saturation_LowerSat;\r\n\r\n  /* ZeroCrossings for RelationalOperator: '<S42>/Compare' incorporates:\r\n   *  Constant: '<S42>/Constant'\r\n   */\r\n  _rtZCSV->Compare_RelopInput_ZC = FCEvReferenceApplication_B.uDLookupTable -\r\n    FCEvReferenceApplication_P.Constant_Value;\r\n\r\n  /* ZeroCrossings for HitCross: '<S11>/Hit  Crossing' */\r\n  _rtZCSV->HitCrossing_HitNoOutput_ZC = FCEvReferenceApplication_B.Add1 -\r\n    FCEvReferenceApplication_P.HitCrossing_Offset;\r\n\r\n  /* ZeroCrossings for Saturate: '<S48>/Saturation1' */\r\n  _rtZCSV->Saturation1_UprLim_ZC = FCEvReferenceApplication_B.m3toUSGal -\r\n    FCEvReferenceApplication_P.Saturation1_UpperSat;\r\n  _rtZCSV->Saturation1_LwrLim_ZC = FCEvReferenceApplication_B.m3toUSGal -\r\n    FCEvReferenceApplication_P.Saturation1_LowerSat;\r\n\r\n  /* ZeroCrossings for Saturate: '<S48>/Saturation' */\r\n  _rtZCSV->Saturation_UprLim_ZC_f = FCEvReferenceApplication_B.mto100Km -\r\n    FCEvReferenceApplication_P.Saturation_UpperSat_d;\r\n  _rtZCSV->Saturation_LwrLim_ZC_h = FCEvReferenceApplication_B.mto100Km -\r\n    FCEvReferenceApplication_P.Saturation_LowerSat_ln;\r\n\r\n  /* ZeroCrossings for RelationalOperator: '<Root>/Relational Operator' incorporates:\r\n   *  Constant: '<Root>/pause_time'\r\n   */\r\n  _rtZCSV->RelationalOperator_RelopInput_Z = FCEvReferenceApplication_B.Clock -\r\n    FCEvReferenceApplication_P.pause_time_Value;\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nvoid MdlTerminate(void)\r\n{\r\n  /* Terminate for ModelReference: '<S5>/Electric Plant' */\r\n  FCElectricPlant_Term\r\n    (&(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw));\r\n}\r\n\r\n/* Function to initialize sizes */\r\nvoid MdlInitializeSizes(void)\r\n{\r\n  ssSetNumContStates(rtS, 528);        /* Number of continuous states */\r\n  ssSetNumPeriodicContStates(rtS, 1); /* Number of periodic continuous states */\r\n  ssSetNumY(rtS, 3);                   /* Number of model outputs */\r\n  ssSetNumU(rtS, 1);                   /* Number of model inputs */\r\n  ssSetDirectFeedThrough(rtS, 1);      /* The model is direct feedthrough */\r\n  ssSetNumSampleTimes(rtS, 5);         /* Number of sample times */\r\n  ssSetNumBlocks(rtS, 156);            /* Number of blocks */\r\n  ssSetNumBlockIO(rtS, 89);            /* Number of block outputs */\r\n  ssSetNumBlockParams(rtS, 2810);      /* Sum of parameter \"widths\" */\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nvoid MdlInitializeSampleTimes(void)\r\n{\r\n  /* task periods */\r\n  ssSetSampleTime(rtS, 0, 0.0);\r\n  ssSetSampleTime(rtS, 1, 0.0);\r\n  ssSetSampleTime(rtS, 2, 0.01);\r\n  ssSetSampleTime(rtS, 3, 0.5);\r\n  ssSetSampleTime(rtS, 4, 1.0);\r\n\r\n  /* task offsets */\r\n  ssSetOffsetTime(rtS, 0, 0.0);\r\n  ssSetOffsetTime(rtS, 1, 1.0);\r\n  ssSetOffsetTime(rtS, 2, 0.0);\r\n  ssSetOffsetTime(rtS, 3, 0.0);\r\n  ssSetOffsetTime(rtS, 4, 0.0);\r\n}\r\n\r\n/* Function to register the model */\r\n/* Turns off all optimizations on Windows because of issues with VC 2015 compiler.\r\n   This function is not performance-critical, hence this is not a problem.\r\n */\r\n#if defined(_MSC_VER)\r\n\r\n#pragma optimize( \"\", off )\r\n\r\n#endif\r\n\r\nSimStruct * FCEvReferenceApplication(void)\r\n{\r\n  static struct _ssMdlInfo mdlInfo;\r\n  static struct _ssBlkInfo2 blkInfo2;\r\n  static struct _ssBlkInfoSLSize blkInfoSLSize;\r\n  (void) memset((char *)rtS, 0,\r\n                sizeof(SimStruct));\r\n  (void) memset((char *)&mdlInfo, 0,\r\n                sizeof(struct _ssMdlInfo));\r\n  (void) memset((char *)&blkInfo2, 0,\r\n                sizeof(struct _ssBlkInfo2));\r\n  (void) memset((char *)&blkInfoSLSize, 0,\r\n                sizeof(struct _ssBlkInfoSLSize));\r\n  ssSetBlkInfo2Ptr(rtS, &blkInfo2);\r\n  ssSetBlkInfoSLSizePtr(rtS, &blkInfoSLSize);\r\n  ssSetMdlInfoPtr(rtS, &mdlInfo);\r\n\r\n  /* timing info */\r\n  {\r\n    static time_T mdlPeriod[NSAMPLE_TIMES];\r\n    static time_T mdlOffset[NSAMPLE_TIMES];\r\n    static time_T mdlTaskTimes[NSAMPLE_TIMES];\r\n    static int_T mdlTsMap[NSAMPLE_TIMES];\r\n    static int_T mdlSampleHits[NSAMPLE_TIMES];\r\n    static boolean_T mdlTNextWasAdjustedPtr[NSAMPLE_TIMES];\r\n    static int_T mdlPerTaskSampleHits[NSAMPLE_TIMES * NSAMPLE_TIMES];\r\n    static time_T mdlTimeOfNextSampleHit[NSAMPLE_TIMES];\r\n\r\n    {\r\n      int_T i;\r\n      for (i = 0; i < NSAMPLE_TIMES; i++) {\r\n        mdlPeriod[i] = 0.0;\r\n        mdlOffset[i] = 0.0;\r\n        mdlTaskTimes[i] = 0.0;\r\n        mdlTsMap[i] = i;\r\n        mdlSampleHits[i] = 1;\r\n      }\r\n    }\r\n\r\n    ssSetSampleTimePtr(rtS, &mdlPeriod[0]);\r\n    ssSetOffsetTimePtr(rtS, &mdlOffset[0]);\r\n    ssSetSampleTimeTaskIDPtr(rtS, &mdlTsMap[0]);\r\n    ssSetTPtr(rtS, &mdlTaskTimes[0]);\r\n    ssSetSampleHitPtr(rtS, &mdlSampleHits[0]);\r\n    ssSetTNextWasAdjustedPtr(rtS, &mdlTNextWasAdjustedPtr[0]);\r\n    ssSetPerTaskSampleHitsPtr(rtS, &mdlPerTaskSampleHits[0]);\r\n    ssSetTimeOfNextSampleHitPtr(rtS, &mdlTimeOfNextSampleHit[0]);\r\n  }\r\n\r\n  ssSetSolverMode(rtS, SOLVER_MODE_SINGLETASKING);\r\n\r\n  /*\r\n   * initialize model vectors and cache them in SimStruct\r\n   */\r\n\r\n  /* block I/O */\r\n  {\r\n    ssSetBlockIO(rtS, ((void *) &FCEvReferenceApplication_B));\r\n    (void) memset(((void *) &FCEvReferenceApplication_B), 0,\r\n                  sizeof(B_FCEvReferenceApplication_T));\r\n  }\r\n\r\n  /* external inputs */\r\n  {\r\n    ssSetU(rtS, ((void*) &FCEvReferenceApplication_U));\r\n    FCEvReferenceApplication_U.pfc = 0.0;\r\n  }\r\n\r\n  /* external outputs */\r\n  {\r\n    ssSetY(rtS, &FCEvReferenceApplication_Y);\r\n    (void)memset(&FCEvReferenceApplication_Y, 0, sizeof\r\n                 (ExtY_FCEvReferenceApplication_T));\r\n  }\r\n\r\n  /* states (continuous)*/\r\n  {\r\n    real_T *x = (real_T *) &FCEvReferenceApplication_X;\r\n    ssSetContStates(rtS, x);\r\n    (void) memset((void *)x, 0,\r\n                  sizeof(X_FCEvReferenceApplication_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  {\r\n    void *dwork = (void *) &FCEvReferenceApplication_DW;\r\n    ssSetRootDWork(rtS, dwork);\r\n    (void) memset(dwork, 0,\r\n                  sizeof(DW_FCEvReferenceApplication_T));\r\n  }\r\n\r\n  /* Root-level init GlobalMassMatrixPr offset */\r\n  {\r\n    FCEvReferenceApplication_DW.ElectricPlant_MASS_MATRIX_PR = 20;/* '<S5>/Electric Plant' */\r\n  }\r\n\r\n  /* data type transition information */\r\n  {\r\n    static DataTypeTransInfo dtInfo;\r\n    (void) memset((char_T *) &dtInfo, 0,\r\n                  sizeof(dtInfo));\r\n    ssSetModelMappingInfo(rtS, &dtInfo);\r\n    dtInfo.numDataTypes = 26;\r\n    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];\r\n    dtInfo.dataTypeNames = &rtDataTypeNames[0];\r\n\r\n    /* Block I/O transition table */\r\n    dtInfo.BTransTable = &rtBTransTable;\r\n\r\n    /* Parameters transition table */\r\n    dtInfo.PTransTable = &rtPTransTable;\r\n  }\r\n\r\n  /* Model specific registration */\r\n  ssSetRootSS(rtS, rtS);\r\n  ssSetVersion(rtS, SIMSTRUCT_VERSION_LEVEL2);\r\n  ssSetModelName(rtS, \"FCEvReferenceApplication\");\r\n  ssSetPath(rtS, \"FCEvReferenceApplication\");\r\n  ssSetTStart(rtS, 0.0);\r\n  ssSetTFinal(rtS, 1369.0);\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S1>/Powertrain Control Module (PCM)' */\r\n  FCEvPowertrainContro_initialize(rtS, 2,\r\n    &(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtm),\r\n    &(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtb),\r\n    &(FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst.rtdw));\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S5>/Drivetrain' */\r\n  DrivetrainEv_initialize(rtS, 0, 1,\r\n    &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtm),\r\n    &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtb),\r\n    &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtdw),\r\n    &(FCEvReferenceApplication_DW.Drivetrain_InstanceData.rtzce));\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S5>/Electric Plant' */\r\n  FCElectricPlant_initialize(rtS, 0, 1,\r\n    &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtm),\r\n    &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtb),\r\n    &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtdw),\r\n    &(FCEvReferenceApplication_DW.ElectricPlant_InstanceData.rtzce),\r\n    &(FCEvReferenceApplica_MassMatrix.pr[FCEvReferenceApplication_DW.ElectricPlant_MASS_MATRIX_PR]));\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    ssSetRTWLogInfo(rtS, &rt_DataLoggingInfo);\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(ssGetRTWLogInfo(rtS), (NULL));\r\n    rtliSetLogXSignalPtrs(ssGetRTWLogInfo(rtS), (NULL));\r\n    rtliSetLogT(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogX(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogXFinal(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogVarNameModifier(ssGetRTWLogInfo(rtS), \"rt_\");\r\n    rtliSetLogFormat(ssGetRTWLogInfo(rtS), 4);\r\n    rtliSetLogMaxRows(ssGetRTWLogInfo(rtS), 0);\r\n    rtliSetLogDecimation(ssGetRTWLogInfo(rtS), 1);\r\n    rtliSetLogY(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogYSignalInfo(ssGetRTWLogInfo(rtS), (NULL));\r\n    rtliSetLogYSignalPtrs(ssGetRTWLogInfo(rtS), (NULL));\r\n  }\r\n\r\n  {\r\n    static struct _ssStatesInfo2 statesInfo2;\r\n    ssSetStatesInfo2(rtS, &statesInfo2);\r\n  }\r\n\r\n  {\r\n    static ssPeriodicStatesInfo periodicStatesInfo;\r\n    ssSetPeriodicStatesInfo(rtS, &periodicStatesInfo);\r\n    ssSetPeriodicContStateIndices(rtS, FCEvReferenceAppli_PeriodicIndX);\r\n    (void) memset((void*) FCEvReferenceAppli_PeriodicIndX, 0,\r\n                  1*sizeof(int_T));\r\n    ssSetPeriodicContStateRanges(rtS, FCEvReferenceAppli_PeriodicRngX);\r\n    (void) memset((void*) FCEvReferenceAppli_PeriodicRngX, 0,\r\n                  2*sizeof(real_T));\r\n  }\r\n\r\n  {\r\n    static ssJacobianPerturbationBounds jacobianPerturbationBounds;\r\n    ssSetJacobianPerturbationBounds(rtS, &jacobianPerturbationBounds);\r\n  }\r\n\r\n  {\r\n    static ssSolverInfo slvrInfo;\r\n    static struct _ssSFcnModelMethods3 mdlMethods3;\r\n    static struct _ssSFcnModelMethods2 mdlMethods2;\r\n    static boolean_T contStatesDisabled[528];\r\n    static real_T absTol[528] = { 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6,\r\n      1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6, 1.0E-6 };\r\n\r\n    static uint8_T absTolControl[528] = { 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\r\n      0U, 0U, 0U, 0U, 0U };\r\n\r\n    static real_T contStateJacPerturbBoundMinVec[528];\r\n    static real_T contStateJacPerturbBoundMaxVec[528];\r\n    static uint8_T zcAttributes[299] = { (0x40|ZC_EVENT_ALL_UP), (0x40|\r\n      ZC_EVENT_ALL_UP), (0x40|ZC_EVENT_ALL_DN), (0x40|ZC_EVENT_ALL_DN),\r\n      (ZC_EVENT_ALL), (ZC_EVENT_ALL), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P),\r\n      (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (ZC_EVENT_P2Z|\r\n      ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|\r\n      ZC_EVENT_N2P), (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P),\r\n      (ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (ZC_EVENT_ALL),\r\n      (ZC_EVENT_ALL), (ZC_EVENT_ALL), (ZC_EVENT_ALL), (ZC_EVENT_ALL),\r\n      (ZC_EVENT_ALL), (ZC_EVENT_ALL), (ZC_EVENT_ALL), (ZC_EVENT_ALL),\r\n      (ZC_EVENT_ALL_DN), (ZC_EVENT_ALL), (ZC_EVENT_ALL), (ZC_EVENT_ALL),\r\n      (ZC_EVENT_ALL), (ZC_EVENT_ALL) };\r\n\r\n    static uint8_T zcEvents[299] = { (0x40|ZC_EVENT_ALL_UP), (0x40|\r\n      ZC_EVENT_ALL_UP), (0x40|ZC_EVENT_ALL_DN), (0x40|ZC_EVENT_ALL_DN), (0x40|\r\n      ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|\r\n      ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|\r\n      ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|ZC_EVENT_P2N|\r\n      ZC_EVENT_Z2P|ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_P2Z|ZC_EVENT_P2N|ZC_EVENT_Z2P|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P),\r\n      (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|\r\n      ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|\r\n      ZC_EVENT_P2N|ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|\r\n      ZC_EVENT_N2Z|ZC_EVENT_N2P), (0x40|ZC_EVENT_Z2N|ZC_EVENT_P2N|ZC_EVENT_N2Z|\r\n      ZC_EVENT_N2P), (0x40|ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|\r\n      ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|\r\n      ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|\r\n      ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL_DN), (0x40|ZC_EVENT_ALL), (0x40|\r\n      ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (0x40|ZC_EVENT_ALL), (ZC_EVENT_ALL) };\r\n\r\n    static ssNonContDerivSigInfo nonContDerivSigInfo[1] = {\r\n      { 1*sizeof(real_T), (char*)(&FCEvReferenceApplication_B.Gain_a), (NULL) }\r\n    };\r\n\r\n    /* Initialize cont state perturbation bound */\r\n    {\r\n      int i;\r\n      for (i = 0; i < 528; ++i) {\r\n        contStateJacPerturbBoundMinVec[i] = 0;\r\n        contStateJacPerturbBoundMaxVec[i] = rtGetInf();\r\n      }\r\n    }\r\n\r\n    ssSetSolverRelTol(rtS, 0.01);\r\n    ssSetStepSize(rtS, 0.0);\r\n    ssSetMinStepSize(rtS, 0.0);\r\n    ssSetMaxNumMinSteps(rtS, -1);\r\n    ssSetMinStepViolatedError(rtS, 0);\r\n    ssSetMaxStepSize(rtS, 0.01);\r\n    ssSetSolverMaxOrder(rtS, -1);\r\n    ssSetSolverRefineFactor(rtS, 1);\r\n    ssSetOutputTimes(rtS, (NULL));\r\n    ssSetNumOutputTimes(rtS, 0);\r\n    ssSetOutputTimesOnly(rtS, 0);\r\n    ssSetOutputTimesIndex(rtS, 0);\r\n    ssSetZCCacheNeedsReset(rtS, 1);\r\n    ssSetDerivCacheNeedsReset(rtS, 0);\r\n    ssSetNumNonContDerivSigInfos(rtS, 1);\r\n    ssSetNonContDerivSigInfos(rtS, nonContDerivSigInfo);\r\n    ssSetSolverInfo(rtS, &slvrInfo);\r\n    ssSetSolverName(rtS, \"ode23t\");\r\n    ssSetVariableStepSolver(rtS, 1);\r\n    ssSetSolverConsistencyChecking(rtS, 0);\r\n    ssSetSolverAdaptiveZcDetection(rtS, 1);\r\n    ssSetSolverRobustResetMethod(rtS, 0);\r\n    _ssSetSolverUpdateJacobianAtReset(rtS, true);\r\n    ssSetAbsTolVector(rtS, absTol);\r\n    ssSetAbsTolControlVector(rtS, absTolControl);\r\n    ssSetSolverAbsTol_Obsolete(rtS, absTol);\r\n    ssSetSolverAbsTolControl_Obsolete(rtS, absTolControl);\r\n    ssSetJacobianPerturbationBoundsMinVec(rtS, contStateJacPerturbBoundMinVec);\r\n    ssSetJacobianPerturbationBoundsMaxVec(rtS, contStateJacPerturbBoundMaxVec);\r\n    ssSetSolverStateProjection(rtS, 1);\r\n    (void) memset((void *)&mdlMethods2, 0,\r\n                  sizeof(mdlMethods2));\r\n    ssSetModelMethods2(rtS, &mdlMethods2);\r\n    (void) memset((void *)&mdlMethods3, 0,\r\n                  sizeof(mdlMethods3));\r\n    ssSetModelMethods3(rtS, &mdlMethods3);\r\n    ssSetModelProjection(rtS, MdlProjection);\r\n    ssSetMassMatrixType(rtS, (ssMatrixType)3);\r\n    ssSetMassMatrixNzMax(rtS, 129);\r\n    ssSetModelMassMatrix(rtS, MdlMassMatrix);\r\n    ssSetModelForcingFunction(rtS, MdlForcingFunction);\r\n    ssSetSolverMassMatrixType(rtS, (ssMatrixType)3);\r\n    ssSetSolverMassMatrixNzMax(rtS, 129);\r\n    ssSetModelOutputs(rtS, MdlOutputs);\r\n    ssSetModelLogData(rtS, rt_UpdateTXYLogVars);\r\n    ssSetModelLogDataIfInInterval(rtS, rt_UpdateTXXFYLogVars);\r\n    ssSetModelUpdate(rtS, MdlUpdate);\r\n    ssSetModelDerivatives(rtS, MdlDerivatives);\r\n    ssSetSolverZcSignalAttrib(rtS, zcAttributes);\r\n    ssSetSolverNumZcSignals(rtS, 299);\r\n    ssSetModelZeroCrossings(rtS, MdlZeroCrossings);\r\n    ssSetSolverZcEventsVector(rtS, zcEvents);\r\n    ssSetSolverConsecutiveZCsStepRelTol(rtS, 2.8421709430404007E-13);\r\n    ssSetSolverMaxConsecutiveZCs(rtS, 1000);\r\n    ssSetSolverConsecutiveZCsError(rtS, 2);\r\n    ssSetSolverMaskedZcDiagnostic(rtS, 1);\r\n    ssSetSolverIgnoredZcDiagnostic(rtS, 0);\r\n    ssSetSolverZcThreshold(rtS, 0.01);\r\n    ssSetSolverMaxConsecutiveMinStep(rtS, 10);\r\n    ssSetSolverShapePreserveControl(rtS, 2);\r\n    ssSetTNextTid(rtS, INT_MIN);\r\n    ssSetTNext(rtS, rtMinusInf);\r\n    ssSetSolverNeedsReset(rtS);\r\n    ssSetNumNonsampledZCs(rtS, 295);\r\n    ssSetContStateDisabled(rtS, contStatesDisabled);\r\n    ssSetSolverMaxConsecutiveMinStep(rtS, 10);\r\n\r\n    /* global mass matrix */\r\n    {\r\n      int_T *ir = FCEvReferenceApplica_MassMatrix.ir;\r\n      int_T *jc = FCEvReferenceApplica_MassMatrix.jc;\r\n      real_T *pr = FCEvReferenceApplica_MassMatrix.pr;\r\n      ssSetMassMatrixIr(rtS, ir);\r\n      ssSetMassMatrixJc(rtS, jc);\r\n      ssSetMassMatrixPr(rtS, pr);\r\n      (void) memset((void *)ir, 0,\r\n                    129*sizeof(int_T));\r\n      (void) memset((void *)jc, 0,\r\n                    (528+1)*sizeof(int_T));\r\n      (void) memset((void *)pr, 0,\r\n                    129*sizeof(real_T));\r\n    }\r\n  }\r\n\r\n  ssSetChecksumVal(rtS, 0, 2287748902U);\r\n  ssSetChecksumVal(rtS, 1, 2603615125U);\r\n  ssSetChecksumVal(rtS, 2, 1712206550U);\r\n  ssSetChecksumVal(rtS, 3, 680897979U);\r\n\r\n  /* non-finite (run-time) assignments */\r\n  FCEvReferenceApplication_P.FirstOrderHold_ErrTol = rtInf;\r\n  FCEvReferenceApplication_P.FirstOrderHold1_ErrTol = rtInf;\r\n  FCEvReferenceApplication_P.Saturation_UpperSat = rtInf;\r\n  FCEvReferenceApplication_P.Saturation_UpperSat_eq = rtInf;\r\n  FCEvReferenceApplication_P.FirstOrderHold_ErrTol_e = rtInf;\r\n  FCEvReferenceApplication_P.Saturation1_UpperSat = rtInf;\r\n  FCEvReferenceApplication_P.Saturation_UpperSat_d = rtInf;\r\n  return rtS;\r\n}\r\n\r\n/* When you use the on parameter, it resets the optimizations to those that you\r\n   specified with the /O compiler option. */\r\n#if defined(_MSC_VER)\r\n\r\n#pragma optimize( \"\", on )\r\n\r\n#endif\r\n"},{"name":"FCEvReferenceApplication.h","type":"header","group":"model","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * FCEvReferenceApplication.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FCEvReferenceApplication_h_\r\n#define RTW_HEADER_FCEvReferenceApplication_h_\r\n#ifndef FCEvReferenceApplication_COMMON_INCLUDES_\r\n#define FCEvReferenceApplication_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#include \"rsim.h\"\r\n#include \"rt_logging.h\"\r\n#include \"dt_info.h\"\r\n#endif                           /* FCEvReferenceApplication_COMMON_INCLUDES_ */\r\n\r\n#include \"FCEvReferenceApplication_types.h\"\r\n#include \"DrivetrainEv.h\"\r\n#include \"FCElectricPlant.h\"\r\n#include \"FCEvPowertrainController.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <string.h>\r\n#include <stddef.h>\r\n#include \"model_reference_types.h\"\r\n#include \"rt_defines.h\"\r\n#include \"rtGetInf.h\"\r\n#include \"zero_crossing_types.h\"\r\n#define MODEL_NAME                     FCEvReferenceApplication\r\n#define NSAMPLE_TIMES                  (5)                       /* Number of sample times */\r\n#define NINPUTS                        (1)                       /* Number of model inputs */\r\n#define NOUTPUTS                       (3)                       /* Number of model outputs */\r\n#define NBLOCKIO                       (89)                      /* Number of data output port signals */\r\n#define NUM_ZC_EVENTS                  (0)                       /* Number of zero-crossing events */\r\n#ifndef NCSTATES\r\n#define NCSTATES                       (528)                     /* Number of continuous states */\r\n#elif NCSTATES != 528\r\n# error Invalid specification of NCSTATES defined in compiler command\r\n#endif\r\n\r\n#ifndef rtmGetDataMapInfo\r\n#define rtmGetDataMapInfo(rtm)         (NULL)\r\n#endif\r\n\r\n#ifndef rtmSetDataMapInfo\r\n#define rtmSetDataMapInfo(rtm, val)\r\n#endif\r\n\r\n/* Block signals for system '<S32>/Pass Through' */\r\ntypedef struct {\r\n  real_T u;                            /* '<S33>/u' */\r\n} B_PassThrough_FCEvReferenceAp_T;\r\n\r\n/* Block states (default storage) for system '<S32>/Pass Through' */\r\ntypedef struct {\r\n  boolean_T PassThrough_MODE;          /* '<S32>/Pass Through' */\r\n} DW_PassThrough_FCEvReferenceA_T;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T MotTrqCmd;                    /* '<S46>/First Order Hold' */\r\n  real_T xdot;                         /* '<S5>/Drivetrain' */\r\n  real_T MotSpd;                       /* '<S5>/Drivetrain' */\r\n  real_T FCCurrCmd;                    /* '<S46>/First Order Hold1' */\r\n  real_T BattSoc;                      /* '<S5>/Electric Plant' */\r\n  real_T BattPwr;                      /* '<S5>/Electric Plant' */\r\n  real_T BattCurr;                     /* '<S5>/Electric Plant' */\r\n  real_T MotTrq;                       /* '<S5>/Electric Plant' */\r\n  real_T ElectricPlant_o5;             /* '<S5>/Electric Plant' */\r\n  real_T FCCurr;                       /* '<S5>/Electric Plant' */\r\n  real_T TotPwr;                       /* '<S5>/Electric Plant' */\r\n  real_T H2Flow;                       /* '<S5>/Electric Plant' */\r\n  real_T ElectricPlant_o9;             /* '<S5>/Electric Plant' */\r\n  real_T Saturation;                   /* '<S6>/Saturation' */\r\n  real_T Gain;                         /* '<S6>/Gain' */\r\n  real_T Derivative;                   /* '<S6>/Derivative' */\r\n  real_T Gain_g;                       /* '<Root>/Gain' */\r\n  real_T Constant;                     /* '<S26>/Constant' */\r\n  real_T Integrator1;                  /* '<S27>/Integrator1' */\r\n  real_T Gain_a;                       /* '<S25>/Gain' */\r\n  real_T Add;                          /* '<S25>/Add' */\r\n  real_T Constant_d;                   /* '<S28>/Constant' */\r\n  real_T tFinal;                       /* '<S11>/tFinal' */\r\n  real_T repeat;                       /* '<S11>/repeat' */\r\n  real_T Switch;                       /* '<S11>/Switch' */\r\n  real_T uDLookupTable;                /* '<S11>/1-D Lookup Table' */\r\n  real_T Constant1;                    /* '<S40>/Constant1' */\r\n  real_T Constant_l;                   /* '<S40>/Constant' */\r\n  real_T Switch_b[2];                  /* '<S40>/Switch' */\r\n  real_T RateTransition;               /* '<S7>/Rate Transition' */\r\n  real_T RateTransition1;              /* '<S7>/Rate Transition1' */\r\n  real_T RateTransition2;              /* '<S7>/Rate Transition2' */\r\n  real_T RateTransition3;              /* '<S7>/Rate Transition3' */\r\n  real_T RateTransition6;              /* '<S7>/Rate Transition6' */\r\n  real_T RateTransition7;              /* '<S7>/Rate Transition7' */\r\n  real_T MotTrqCmd_j;               /* '<S1>/Powertrain Control Module (PCM)' */\r\n  real_T BrkCmd;                    /* '<S1>/Powertrain Control Module (PCM)' */\r\n  real_T PowertrainControlModulePCM_o3;\r\n                                    /* '<S1>/Powertrain Control Module (PCM)' */\r\n  real_T Gain2;                        /* '<Root>/Gain2' */\r\n  real_T Gain1;                        /* '<Root>/Gain1' */\r\n  real_T RateTransition4;              /* '<S7>/Rate Transition4' */\r\n  real_T RateTransition5;              /* '<S7>/Rate Transition5' */\r\n  real_T DigitalClock;                 /* '<S11>/Digital Clock' */\r\n  real_T Add1;                         /* '<S11>/Add1' */\r\n  real_T Grade;                        /* '<S3>/Constant2' */\r\n  real_T wind_x;                       /* '<S3>/Constant3' */\r\n  real_T Product1;                     /* '<S25>/Product1' */\r\n  real_T Product;                      /* '<S25>/Product' */\r\n  real_T ytT;                          /* '<S25>/Add2' */\r\n  real_T etT;                          /* '<S25>/Add4' */\r\n  real_T Divide;                       /* '<S25>/Divide' */\r\n  real_T u_ot;                         /* '<S25>/Add1' */\r\n  real_T Constant_a;                   /* '<S27>/Constant' */\r\n  real_T Sum;                          /* '<S27>/Sum' */\r\n  real_T Divide_j;                     /* '<S27>/Divide' */\r\n  real_T Sum7;                         /* '<S20>/Sum7' */\r\n  real_T Product_m;                    /* '<S38>/Product' */\r\n  real_T UnitDelay[2];                 /* '<S38>/Unit Delay' */\r\n  real_T Switch_p[2];                  /* '<S38>/Switch' */\r\n  real_T MotTrq_f;                     /* '<S45>/Motor Coupling Dynamics' */\r\n  real_T BrkCmd_f;                     /* '<S45>/First Order Hold' */\r\n  real_T mstomph[2];                   /* '<S6>/m//s to mph' */\r\n  real_T radstoRPM;                    /* '<S6>/rad//s to RPM' */\r\n  real_T Integrator;                   /* '<S48>/Integrator' */\r\n  real_T Integrator1_d;                /* '<S48>/Integrator1' */\r\n  real_T m3toUSGal;                    /* '<S48>/m^3 to US Gal' */\r\n  real_T USMPGCalc;                    /* '<S48>/US MPG Calc' */\r\n  real_T mto100Km;                     /* '<S48>/m to 100Km' */\r\n  real_T L100Km;                       /* '<S48>/L//100 Km Calc' */\r\n  real_T wtokw;                        /* '<S48>/w to kw' */\r\n  real_T Divide_c;                     /* '<S48>/Divide' */\r\n  real_T USEPAkwhUSgalequivalent;     /* '<S48>/US EPA kwh//USgal equivalent' */\r\n  real_T Divide2;                      /* '<S48>/Divide2' */\r\n  real_T sperh;                        /* '<S48>/s per h' */\r\n  real_T GasGallonss;                  /* '<S48>/Divide1' */\r\n  real_T Gasgals;                      /* '<S48>/kg//s to Gas gal//s' */\r\n  real_T Add_b;                        /* '<S48>/Add' */\r\n  real_T Product_e;                    /* '<S48>/Product' */\r\n  real_T Sqrt;                         /* '<S48>/Sqrt' */\r\n  real_T m3pergal;                     /* '<S48>/m^3 per gal' */\r\n  real_T Clock;                        /* '<Root>/Clock' */\r\n  real_T Gear;                         /* '<S39>/Shift Controller' */\r\n  boolean_T LogicalOperator2;          /* '<S26>/Logical Operator2' */\r\n  boolean_T NOT;                       /* '<S32>/NOT' */\r\n  boolean_T LogicalOperator2_j;        /* '<S28>/Logical Operator2' */\r\n  boolean_T NOT_g;                     /* '<S34>/NOT' */\r\n  boolean_T LogicalOperator;           /* '<S40>/Logical Operator' */\r\n  B_PassThrough_FCEvReferenceAp_T PassThrough_b;/* '<S34>/Pass Through' */\r\n  B_PassThrough_FCEvReferenceAp_T PassThrough;/* '<S32>/Pass Through' */\r\n} B_FCEvReferenceApplication_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T UnitDelay_DSTATE[2];          /* '<S38>/Unit Delay' */\r\n  real_T Tk;                           /* '<S46>/First Order Hold' */\r\n  real_T Ck;                           /* '<S46>/First Order Hold' */\r\n  real_T Mk;                           /* '<S46>/First Order Hold' */\r\n  real_T Uk;                           /* '<S46>/First Order Hold' */\r\n  real_T Tk_o;                         /* '<S46>/First Order Hold1' */\r\n  real_T Ck_d;                         /* '<S46>/First Order Hold1' */\r\n  real_T Mk_e;                         /* '<S46>/First Order Hold1' */\r\n  real_T Uk_j;                         /* '<S46>/First Order Hold1' */\r\n  volatile real_T RateTransition1_Buffer0;/* '<S6>/Rate Transition1' */\r\n  real_T TimeStampA;                   /* '<S6>/Derivative' */\r\n  real_T LastUAtTimeA;                 /* '<S6>/Derivative' */\r\n  real_T TimeStampB;                   /* '<S6>/Derivative' */\r\n  real_T LastUAtTimeB;                 /* '<S6>/Derivative' */\r\n  volatile real_T RateTransition_Buffer0;/* '<S7>/Rate Transition' */\r\n  volatile real_T RateTransition1_Buffer0_m;/* '<S7>/Rate Transition1' */\r\n  volatile real_T RateTransition2_Buffer0;/* '<S7>/Rate Transition2' */\r\n  volatile real_T RateTransition3_Buffer0;/* '<S7>/Rate Transition3' */\r\n  volatile real_T RateTransition6_Buffer0;/* '<S7>/Rate Transition6' */\r\n  volatile real_T RateTransition7_Buffer0;/* '<S7>/Rate Transition7' */\r\n  volatile real_T RateTransition4_Buffer0;/* '<S7>/Rate Transition4' */\r\n  volatile real_T RateTransition5_Buffer0;/* '<S7>/Rate Transition5' */\r\n  real_T Tk_a;                         /* '<S45>/First Order Hold' */\r\n  real_T Ck_g;                         /* '<S45>/First Order Hold' */\r\n  real_T Mk_h;                         /* '<S45>/First Order Hold' */\r\n  real_T Uk_h;                         /* '<S45>/First Order Hold' */\r\n  volatile real_T RateTransition4_Buffer0_b[2];/* '<S6>/Rate Transition4' */\r\n  volatile real_T RateTransition2_Buffer0_k;/* '<S6>/Rate Transition2' */\r\n  volatile real_T RateTransition5_Buffer0_d;/* '<S6>/Rate Transition5' */\r\n  volatile real_T RateTransition6_Buffer0_e;/* '<S6>/Rate Transition6' */\r\n  volatile real_T RateTransition3_Buffer0_d;/* '<S6>/Rate Transition3' */\r\n  volatile real_T RateTransition7_Buffer0_j;/* '<S6>/Rate Transition7' */\r\n  volatile real_T RateTransition3_Buffer0_g;/* '<S48>/Rate Transition3' */\r\n  real_T GearState;                    /* '<S39>/Shift Controller' */\r\n  real_T temporalCounter_i1;           /* '<S39>/Shift Controller' */\r\n  real_T presentTime;                  /* '<S39>/Shift Controller' */\r\n  real_T elapsedTime;                  /* '<S39>/Shift Controller' */\r\n  real_T previousTime;                 /* '<S39>/Shift Controller' */\r\n  struct {\r\n    void *LoggedData;\r\n  } Scope_PWORK;                       /* '<Root>/Scope' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace_PWORK;                 /* '<Root>/To Workspace' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace1_PWORK;                /* '<Root>/To Workspace1' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace2_PWORK;                /* '<Root>/To Workspace2' */\r\n\r\n  struct {\r\n    void *LoggedData[8];\r\n  } PerformanceandFEScope_PWORK;       /* '<S6>/Performance and FE Scope' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } Scope_PWORK_k;                     /* '<S6>/Scope' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace1_PWORK_c;              /* '<S6>/To Workspace1' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace2_PWORK_i;              /* '<S6>/To Workspace2' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace3_PWORK;                /* '<S6>/To Workspace3' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace4_PWORK;                /* '<S6>/To Workspace4' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace3_PWORK_j;              /* '<Root>/To Workspace3' */\r\n\r\n  uint32_T m_bpIndex;                  /* '<S11>/1-D Lookup Table' */\r\n  int_T Saturation_MODE;               /* '<S6>/Saturation' */\r\n  int_T Saturation1_MODE;              /* '<S48>/Saturation1' */\r\n  int_T Saturation_MODE_k;             /* '<S48>/Saturation' */\r\n  volatile int8_T RateTransition1_semaphoreTaken;/* '<S6>/Rate Transition1' */\r\n  volatile int8_T RateTransition_semaphoreTaken;/* '<S7>/Rate Transition' */\r\n  volatile int8_T RateTransition1_semaphoreTake_h;/* '<S7>/Rate Transition1' */\r\n  volatile int8_T RateTransition2_semaphoreTaken;/* '<S7>/Rate Transition2' */\r\n  volatile int8_T RateTransition3_semaphoreTaken;/* '<S7>/Rate Transition3' */\r\n  volatile int8_T RateTransition6_semaphoreTaken;/* '<S7>/Rate Transition6' */\r\n  volatile int8_T RateTransition7_semaphoreTaken;/* '<S7>/Rate Transition7' */\r\n  volatile int8_T RateTransition4_semaphoreTaken;/* '<S7>/Rate Transition4' */\r\n  volatile int8_T RateTransition5_semaphoreTaken;/* '<S7>/Rate Transition5' */\r\n  volatile int8_T RateTransition4_semaphoreTake_d;/* '<S6>/Rate Transition4' */\r\n  volatile int8_T RateTransition2_semaphoreTake_p;/* '<S6>/Rate Transition2' */\r\n  volatile int8_T RateTransition5_semaphoreTake_i;/* '<S6>/Rate Transition5' */\r\n  volatile int8_T RateTransition6_semaphoreTake_e;/* '<S6>/Rate Transition6' */\r\n  volatile int8_T RateTransition3_semaphoreTake_e;/* '<S6>/Rate Transition3' */\r\n  volatile int8_T RateTransition7_semaphoreTake_h;/* '<S6>/Rate Transition7' */\r\n  volatile int8_T RateTransition3_semaphoreTake_g;/* '<S48>/Rate Transition3' */\r\n  int8_T Sqrt_DWORK1;                  /* '<S48>/Sqrt' */\r\n  uint8_T is_GearSelect;               /* '<S39>/Shift Controller' */\r\n  uint8_T is_active_c6_autolibsharedcommo;/* '<S39>/Shift Controller' */\r\n  boolean_T Compare_Mode;              /* '<S42>/Compare' */\r\n  boolean_T RelationalOperator_Mode;   /* '<Root>/Relational Operator' */\r\n  MdlrefDW_DrivetrainEv_T Drivetrain_InstanceData;/* '<S5>/Drivetrain' */\r\n  MdlrefDW_FCElectricPlant_T ElectricPlant_InstanceData;/* '<S5>/Electric Plant' */\r\n  int32_T ElectricPlant_MASS_MATRIX_PR;/* '<S5>/Electric Plant' */\r\n  MdlrefDW_FCEvPowertrainContro_T PowertrainControlModulePCM_Inst;\r\n                                    /* '<S1>/Powertrain Control Module (PCM)' */\r\n  DW_PassThrough_FCEvReferenceA_T PassThrough_b;/* '<S34>/Pass Through' */\r\n  DW_PassThrough_FCEvReferenceA_T PassThrough;/* '<S32>/Pass Through' */\r\n} DW_FCEvReferenceApplication_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  X_DrivetrainEv_n_T Drivetrain_CSTATE;/* '<S5>/Drivetrain' */\r\n  X_FCElectricPlant_n_T ElectricPlant_CSTATE;/* '<S5>/Electric Plant' */\r\n  real_T Integrator1_CSTATE;           /* '<S27>/Integrator1' */\r\n  real_T Integrator2_CSTATE;           /* '<S38>/Integrator2' */\r\n  real_T MotorCouplingDynamics_CSTATE; /* '<S45>/Motor Coupling Dynamics' */\r\n  real_T Integrator_CSTATE;            /* '<S48>/Integrator' */\r\n  real_T Integrator1_CSTATE_j;         /* '<S48>/Integrator1' */\r\n} X_FCEvReferenceApplication_T;\r\n\r\n/* Periodic continuous state vector (global) */\r\ntypedef int_T PeriodicIndX_FCEvReferenceApp_T[1];\r\ntypedef real_T PeriodicRngX_FCEvReferenceApp_T[2];\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  XDot_DrivetrainEv_n_T Drivetrain_CSTATE;/* '<S5>/Drivetrain' */\r\n  XDot_FCElectricPlant_n_T ElectricPlant_CSTATE;/* '<S5>/Electric Plant' */\r\n  real_T Integrator1_CSTATE;           /* '<S27>/Integrator1' */\r\n  real_T Integrator2_CSTATE;           /* '<S38>/Integrator2' */\r\n  real_T MotorCouplingDynamics_CSTATE; /* '<S45>/Motor Coupling Dynamics' */\r\n  real_T Integrator_CSTATE;            /* '<S48>/Integrator' */\r\n  real_T Integrator1_CSTATE_j;         /* '<S48>/Integrator1' */\r\n} XDot_FCEvReferenceApplication_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  XDis_DrivetrainEv_n_T Drivetrain_CSTATE;/* '<S5>/Drivetrain' */\r\n  XDis_FCElectricPlant_n_T ElectricPlant_CSTATE;/* '<S5>/Electric Plant' */\r\n  boolean_T Integrator1_CSTATE;        /* '<S27>/Integrator1' */\r\n  boolean_T Integrator2_CSTATE;        /* '<S38>/Integrator2' */\r\n  boolean_T MotorCouplingDynamics_CSTATE;/* '<S45>/Motor Coupling Dynamics' */\r\n  boolean_T Integrator_CSTATE;         /* '<S48>/Integrator' */\r\n  boolean_T Integrator1_CSTATE_j;      /* '<S48>/Integrator1' */\r\n} XDis_FCEvReferenceApplication_T;\r\n\r\n/* Continuous State Absolute Tolerance  */\r\ntypedef struct {\r\n  XAbsTol_DrivetrainEv_T Drivetrain_CSTATE;/* '<S5>/Drivetrain' */\r\n  XAbsTol_FCElectricPlant_T ElectricPlant_CSTATE;/* '<S5>/Electric Plant' */\r\n  real_T Integrator1_CSTATE;           /* '<S27>/Integrator1' */\r\n  real_T Integrator2_CSTATE;           /* '<S38>/Integrator2' */\r\n  real_T MotorCouplingDynamics_CSTATE; /* '<S45>/Motor Coupling Dynamics' */\r\n  real_T Integrator_CSTATE;            /* '<S48>/Integrator' */\r\n  real_T Integrator1_CSTATE_j;         /* '<S48>/Integrator1' */\r\n} CStateAbsTol_FCEvReferenceApp_T;\r\n\r\n/* Continuous State Perturb Min  */\r\ntypedef struct {\r\n  XPtMin_DrivetrainEv_T Drivetrain_CSTATE;/* '<S5>/Drivetrain' */\r\n  XPtMin_FCElectricPlant_T ElectricPlant_CSTATE;/* '<S5>/Electric Plant' */\r\n  real_T Integrator1_CSTATE;           /* '<S27>/Integrator1' */\r\n  real_T Integrator2_CSTATE;           /* '<S38>/Integrator2' */\r\n  real_T MotorCouplingDynamics_CSTATE; /* '<S45>/Motor Coupling Dynamics' */\r\n  real_T Integrator_CSTATE;            /* '<S48>/Integrator' */\r\n  real_T Integrator1_CSTATE_j;         /* '<S48>/Integrator1' */\r\n} CXPtMin_FCEvReferenceApplicat_T;\r\n\r\n/* Continuous State Perturb Max  */\r\ntypedef struct {\r\n  XPtMax_DrivetrainEv_T Drivetrain_CSTATE;/* '<S5>/Drivetrain' */\r\n  XPtMax_FCElectricPlant_T ElectricPlant_CSTATE;/* '<S5>/Electric Plant' */\r\n  real_T Integrator1_CSTATE;           /* '<S27>/Integrator1' */\r\n  real_T Integrator2_CSTATE;           /* '<S38>/Integrator2' */\r\n  real_T MotorCouplingDynamics_CSTATE; /* '<S45>/Motor Coupling Dynamics' */\r\n  real_T Integrator_CSTATE;            /* '<S48>/Integrator' */\r\n  real_T Integrator1_CSTATE_j;         /* '<S48>/Integrator1' */\r\n} CXPtMax_FCEvReferenceApplicat_T;\r\n\r\n/* Zero-crossing (trigger) state */\r\ntypedef struct {\r\n  ZCV_DrivetrainEv_g_T Drivetrain_Reset_ZC;/* '<S5>/Drivetrain' */\r\n  ZCV_FCElectricPlant_g_T ElectricPlant_Reset_ZC;/* '<S5>/Electric Plant' */\r\n  real_T Saturation_UprLim_ZC;         /* '<S6>/Saturation' */\r\n  real_T Saturation_LwrLim_ZC;         /* '<S6>/Saturation' */\r\n  real_T Compare_RelopInput_ZC;        /* '<S42>/Compare' */\r\n  real_T HitCrossing_HitNoOutput_ZC;   /* '<S11>/Hit  Crossing' */\r\n  real_T Saturation1_UprLim_ZC;        /* '<S48>/Saturation1' */\r\n  real_T Saturation1_LwrLim_ZC;        /* '<S48>/Saturation1' */\r\n  real_T Saturation_UprLim_ZC_f;       /* '<S48>/Saturation' */\r\n  real_T Saturation_LwrLim_ZC_h;       /* '<S48>/Saturation' */\r\n  real_T RelationalOperator_RelopInput_Z;/* '<Root>/Relational Operator' */\r\n} ZCV_FCEvReferenceApplication_T;\r\n\r\n/* Mass Matrix (global) */\r\ntypedef struct {\r\n  int_T ir[129];\r\n  int_T jc[529];\r\n  real_T pr[129];\r\n} MassMatrix_FCEvReferenceAppli_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T pfc;                          /* '<Root>/pfc' */\r\n} ExtU_FCEvReferenceApplication_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T soc;                          /* '<Root>/soc' */\r\n  real_T v;                            /* '<Root>/v' */\r\n  real_T a;                            /* '<Root>/a' */\r\n} ExtY_FCEvReferenceApplication_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_FCEvReferenceApplication_T_ {\r\n  real_T LongitudinalDriverModel_GearIni;\r\n                              /* Mask Parameter: LongitudinalDriverModel_GearIni\r\n                               * Referenced by: '<S39>/Shift Controller'\r\n                               */\r\n  real_T SignalHold_IC;                /* Mask Parameter: SignalHold_IC\r\n                                        * Referenced by: '<S32>/Pass Through'\r\n                                        */\r\n  real_T SignalHold_IC_k;              /* Mask Parameter: SignalHold_IC_k\r\n                                        * Referenced by: '<S34>/Pass Through'\r\n                                        */\r\n  real_T LongitudinalDriverModel_Kpt;\r\n                                  /* Mask Parameter: LongitudinalDriverModel_Kpt\r\n                                   * Referenced by:\r\n                                   *   '<S25>/Setup'\r\n                                   *   '<S25>/Gain'\r\n                                   */\r\n  real_T LongitudinalDriverModel_L; /* Mask Parameter: LongitudinalDriverModel_L\r\n                                     * Referenced by: '<S25>/Setup'\r\n                                     */\r\n  real_T LongitudinalDriverModel_aR;\r\n                                   /* Mask Parameter: LongitudinalDriverModel_aR\r\n                                    * Referenced by: '<S25>/Setup'\r\n                                    */\r\n  real_T LongitudinalDriverModel_bR;\r\n                                   /* Mask Parameter: LongitudinalDriverModel_bR\r\n                                    * Referenced by: '<S25>/Setup'\r\n                                    */\r\n  real_T LongitudinalDriverModel_cR;\r\n                                   /* Mask Parameter: LongitudinalDriverModel_cR\r\n                                    * Referenced by: '<S25>/Setup'\r\n                                    */\r\n  real_T LongitudinalDriverModel_g; /* Mask Parameter: LongitudinalDriverModel_g\r\n                                     * Referenced by: '<S25>/Gain'\r\n                                     */\r\n  real_T LongitudinalDriverModel_m; /* Mask Parameter: LongitudinalDriverModel_m\r\n                                     * Referenced by:\r\n                                     *   '<S25>/Setup'\r\n                                     *   '<S25>/Gain'\r\n                                     */\r\n  real_T LongitudinalDriverModel_tShift;\r\n                               /* Mask Parameter: LongitudinalDriverModel_tShift\r\n                                * Referenced by: '<S39>/Shift Controller'\r\n                                */\r\n  real_T LongitudinalDriverModel_tau;\r\n                                  /* Mask Parameter: LongitudinalDriverModel_tau\r\n                                   * Referenced by:\r\n                                   *   '<S25>/Setup'\r\n                                   *   '<S27>/Constant'\r\n                                   */\r\n  real_T u1_UpperSat;                  /* Expression: 1\r\n                                        * Referenced by: '<S26>/0~1'\r\n                                        */\r\n  real_T u1_LowerSat;                  /* Expression: 0\r\n                                        * Referenced by: '<S26>/0~1'\r\n                                        */\r\n  real_T u0_UpperSat;                  /* Expression: 0\r\n                                        * Referenced by: '<S28>/-1~0'\r\n                                        */\r\n  real_T u0_LowerSat;                  /* Expression: -1\r\n                                        * Referenced by: '<S28>/-1~0'\r\n                                        */\r\n  real_T Constant_Value;               /* Expression: 0\r\n                                        * Referenced by: '<S42>/Constant'\r\n                                        */\r\n  real_T Constant_Value_n;             /* Expression: 0\r\n                                        * Referenced by: '<S43>/Constant'\r\n                                        */\r\n  real_T FirstOrderHold_IniOut;        /* Expression: 0\r\n                                        * Referenced by: '<S46>/First Order Hold'\r\n                                        */\r\n  real_T FirstOrderHold_ErrTol;        /* Expression: inf\r\n                                        * Referenced by: '<S46>/First Order Hold'\r\n                                        */\r\n  real_T FirstOrderHold1_IniOut;       /* Expression: 0\r\n                                        * Referenced by: '<S46>/First Order Hold1'\r\n                                        */\r\n  real_T FirstOrderHold1_ErrTol;       /* Expression: inf\r\n                                        * Referenced by: '<S46>/First Order Hold1'\r\n                                        */\r\n  real_T Saturation_UpperSat;          /* Expression: Inf\r\n                                        * Referenced by: '<S6>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat;          /* Expression: 0\r\n                                        * Referenced by: '<S6>/Saturation'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 3.6\r\n                                        * Referenced by: '<S6>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_n;                  /* Expression: 1000\r\n                                        * Referenced by: '<Root>/Gain'\r\n                                        */\r\n  real_T Constant_Value_m;             /* Expression: 0\r\n                                        * Referenced by: '<S26>/Constant'\r\n                                        */\r\n  real_T Integrator1_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S27>/Integrator1'\r\n                                        */\r\n  real_T Saturation_UpperSat_e;        /* Expression: 1\r\n                                        * Referenced by: '<S26>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_j;        /* Expression: 0\r\n                                        * Referenced by: '<S26>/Saturation'\r\n                                        */\r\n  real_T Constant_Value_l;             /* Expression: 0\r\n                                        * Referenced by: '<S28>/Constant'\r\n                                        */\r\n  real_T Saturation_UpperSat_n;        /* Expression: 1\r\n                                        * Referenced by: '<S28>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_jd;       /* Expression: 0\r\n                                        * Referenced by: '<S28>/Saturation'\r\n                                        */\r\n  real_T tFinal_Value;                 /* Expression: DriveCycle.Time(end)\r\n                                        * Referenced by: '<S11>/tFinal'\r\n                                        */\r\n  real_T repeat_Value;                 /* Expression: cycleRepeat\r\n                                        * Referenced by: '<S11>/repeat'\r\n                                        */\r\n  real_T Switch_Threshold;             /* Expression: 0\r\n                                        * Referenced by: '<S11>/Switch'\r\n                                        */\r\n  real_T uDLookupTable_tableData[1370];/* Expression: DriveCycle.Data\r\n                                        * Referenced by: '<S11>/1-D Lookup Table'\r\n                                        */\r\n  real_T uDLookupTable_bp01Data[1370]; /* Expression: DriveCycle.Time\r\n                                        * Referenced by: '<S11>/1-D Lookup Table'\r\n                                        */\r\n  real_T Constant1_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S40>/Constant1'\r\n                                        */\r\n  real_T Constant_Value_f;             /* Expression: 0\r\n                                        * Referenced by: '<S40>/Constant'\r\n                                        */\r\n  real_T Gain2_Gain;                   /* Expression: 0.001\r\n                                        * Referenced by: '<Root>/Gain2'\r\n                                        */\r\n  real_T Saturation_UpperSat_eq;       /* Expression: Inf\r\n                                        * Referenced by: '<Root>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_l;        /* Expression: 0\r\n                                        * Referenced by: '<Root>/Saturation'\r\n                                        */\r\n  real_T Gain1_Gain;                   /* Expression: 0.001\r\n                                        * Referenced by: '<Root>/Gain1'\r\n                                        */\r\n  real_T HitCrossing_Offset;\r\n              /* Expression: min(0.5,(DriveCycle.Time(2)-DriveCycle.Time(1))./2)\r\n               * Referenced by: '<S11>/Hit  Crossing'\r\n               */\r\n  real_T Constant2_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S3>/Constant2'\r\n                                        */\r\n  real_T Constant3_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S3>/Constant3'\r\n                                        */\r\n  real_T Integrator2_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S38>/Integrator2'\r\n                                        */\r\n  real_T UnitDelay_InitialCondition[2];/* Expression: [0,0]\r\n                                        * Referenced by: '<S38>/Unit Delay'\r\n                                        */\r\n  real_T MotorCouplingDynamics_A; /* Computed Parameter: MotorCouplingDynamics_A\r\n                                   * Referenced by: '<S45>/Motor Coupling Dynamics'\r\n                                   */\r\n  real_T MotorCouplingDynamics_C; /* Computed Parameter: MotorCouplingDynamics_C\r\n                                   * Referenced by: '<S45>/Motor Coupling Dynamics'\r\n                                   */\r\n  real_T FirstOrderHold_IniOut_b;      /* Expression: 0\r\n                                        * Referenced by: '<S45>/First Order Hold'\r\n                                        */\r\n  real_T FirstOrderHold_ErrTol_e;      /* Expression: inf\r\n                                        * Referenced by: '<S45>/First Order Hold'\r\n                                        */\r\n  real_T mstomph_Gain;                 /* Expression: 2.23694\r\n                                        * Referenced by: '<S6>/m//s to mph'\r\n                                        */\r\n  real_T radstoRPM_Gain;               /* Expression: 30/pi\r\n                                        * Referenced by: '<S6>/rad//s to RPM'\r\n                                        */\r\n  real_T Integrator_IC;                /* Expression: 0\r\n                                        * Referenced by: '<S48>/Integrator'\r\n                                        */\r\n  real_T mtomile_Gain;                 /* Expression: 0.000621371\r\n                                        * Referenced by: '<S48>/m to mile'\r\n                                        */\r\n  real_T Integrator1_IC_o;             /* Expression: 0\r\n                                        * Referenced by: '<S48>/Integrator1'\r\n                                        */\r\n  real_T m3toUSGal_Gain;               /* Expression: 264.172\r\n                                        * Referenced by: '<S48>/m^3 to US Gal'\r\n                                        */\r\n  real_T Saturation1_UpperSat;         /* Expression: Inf\r\n                                        * Referenced by: '<S48>/Saturation1'\r\n                                        */\r\n  real_T Saturation1_LowerSat;         /* Expression: 1e-3\r\n                                        * Referenced by: '<S48>/Saturation1'\r\n                                        */\r\n  real_T mto100Km_Gain;                /* Expression: 1/1000/100\r\n                                        * Referenced by: '<S48>/m to 100Km'\r\n                                        */\r\n  real_T Saturation_UpperSat_d;        /* Expression: Inf\r\n                                        * Referenced by: '<S48>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_ln;       /* Expression: 0.001\r\n                                        * Referenced by: '<S48>/Saturation'\r\n                                        */\r\n  real_T m3toL_Gain;                   /* Expression: 1000\r\n                                        * Referenced by: '<S48>/m^3 to L'\r\n                                        */\r\n  real_T wtokw_Value;                  /* Expression: 1000\r\n                                        * Referenced by: '<S48>/w to kw'\r\n                                        */\r\n  real_T USEPAkwhUSgalequivalent_Value;/* Expression: 33.7\r\n                                        * Referenced by: '<S48>/US EPA kwh//USgal equivalent'\r\n                                        */\r\n  real_T sperh_Value;                  /* Expression: 3600\r\n                                        * Referenced by: '<S48>/s per h'\r\n                                        */\r\n  real_T kgstoGasgals_Gain;            /* Expression: 1/1.011\r\n                                        * Referenced by: '<S48>/kg//s to Gas gal//s'\r\n                                        */\r\n  real_T m3pergal_Gain;                /* Expression: 0.00378541\r\n                                        * Referenced by: '<S48>/m^3 per gal'\r\n                                        */\r\n  real_T pause_time_Value;             /* Expression: 1\r\n                                        * Referenced by: '<Root>/pause_time'\r\n                                        */\r\n};\r\n\r\n/* External data declarations for dependent source files */\r\nextern const char *RT_MEMORY_ALLOCATION_ERROR;\r\nextern B_FCEvReferenceApplication_T FCEvReferenceApplication_B;/* block i/o */\r\nextern X_FCEvReferenceApplication_T FCEvReferenceApplication_X;/* states (continuous) */\r\nextern DW_FCEvReferenceApplication_T FCEvReferenceApplication_DW;/* states (dwork) */\r\nextern ExtU_FCEvReferenceApplication_T FCEvReferenceApplication_U;/* external inputs */\r\nextern ExtY_FCEvReferenceApplication_T FCEvReferenceApplication_Y;/* external outputs */\r\nextern MassMatrix_FCEvReferenceAppli_T FCEvReferenceApplica_MassMatrix;/* global MassMatrix */\r\nextern P_FCEvReferenceApplication_T FCEvReferenceApplication_P;/* parameters */\r\n\r\n/* Simulation Structure */\r\nextern SimStruct *const rtS;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'FCEvReferenceApplication'\r\n * '<S1>'   : 'FCEvReferenceApplication/Controllers'\r\n * '<S2>'   : 'FCEvReferenceApplication/Drive Cycle Source'\r\n * '<S3>'   : 'FCEvReferenceApplication/Environment'\r\n * '<S4>'   : 'FCEvReferenceApplication/Longitudinal Driver'\r\n * '<S5>'   : 'FCEvReferenceApplication/Passenger Car'\r\n * '<S6>'   : 'FCEvReferenceApplication/Visualization'\r\n * '<S7>'   : 'FCEvReferenceApplication/Controllers/Powertrain Control Input'\r\n * '<S8>'   : 'FCEvReferenceApplication/Controllers/Powertrain Control Output'\r\n * '<S9>'   : 'FCEvReferenceApplication/Drive Cycle Source/Signal Routing'\r\n * '<S10>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode'\r\n * '<S11>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode/Continuous'\r\n * '<S12>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode/Continuous/FaultSystem'\r\n * '<S13>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode/Continuous/FaultSystem/Fault Mode'\r\n * '<S14>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode/Continuous/FaultSystem/TracePlot'\r\n * '<S15>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode/Continuous/FaultSystem/Fault Mode/Fault Off'\r\n * '<S16>'  : 'FCEvReferenceApplication/Drive Cycle Source/Timing Mode/Continuous/FaultSystem/TracePlot/SimPlotOff'\r\n * '<S17>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver'\r\n * '<S18>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model'\r\n * '<S19>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/External Action Routing'\r\n * '<S20>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver'\r\n * '<S21>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control'\r\n * '<S22>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/LPF'\r\n * '<S23>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Routing'\r\n * '<S24>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Shift'\r\n * '<S25>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive'\r\n * '<S26>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Accel Override'\r\n * '<S27>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Cont LPF'\r\n * '<S28>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Deccel Override'\r\n * '<S29>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Powertrain Response'\r\n * '<S30>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Setup'\r\n * '<S31>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Vehicle'\r\n * '<S32>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Accel Override/Signal Hold'\r\n * '<S33>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Accel Override/Signal Hold/Pass Through'\r\n * '<S34>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Deccel Override/Signal Hold'\r\n * '<S35>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Deccel Override/Signal Hold/Pass Through'\r\n * '<S36>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Control/Predictive/Powertrain Response/Unfiltered'\r\n * '<S37>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/LPF/pass'\r\n * '<S38>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Routing/Error Metrics'\r\n * '<S39>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Shift/Basic'\r\n * '<S40>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Shift/Basic/Reverse Change'\r\n * '<S41>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Shift/Basic/Shift Controller'\r\n * '<S42>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Shift/Basic/Reverse Change/Compare To Zero'\r\n * '<S43>'  : 'FCEvReferenceApplication/Longitudinal Driver/Longitudinal Driver/Longitudinal Driver Model/Longitudinal Driver/Shift/Basic/Reverse Change/Compare To Zero1'\r\n * '<S44>'  : 'FCEvReferenceApplication/Passenger Car/Drivetrain Output'\r\n * '<S45>'  : 'FCEvReferenceApplication/Passenger Car/Drivetrain Plant Input'\r\n * '<S46>'  : 'FCEvReferenceApplication/Passenger Car/Electric Plant Input'\r\n * '<S47>'  : 'FCEvReferenceApplication/Passenger Car/Electric Plant Output'\r\n * '<S48>'  : 'FCEvReferenceApplication/Visualization/Performance Calculations'\r\n */\r\n\r\n/* user code (bottom of header file) */\r\nextern const int_T gblNumToFiles;\r\nextern const int_T gblNumFrFiles;\r\nextern const int_T gblNumFrWksBlocks;\r\nextern rtInportTUtable *gblInportTUtables;\r\nextern const char *gblInportFileName;\r\nextern const int_T gblNumRootInportBlks;\r\nextern const int_T gblNumModelInputs;\r\nextern const int_T gblInportDataTypeIdx[];\r\nextern const int_T gblInportDims[];\r\nextern const int_T gblInportComplex[];\r\nextern const int_T gblInportInterpoFlag[];\r\nextern const int_T gblInportContinuous[];\r\n\r\n#endif                              /* RTW_HEADER_FCEvReferenceApplication_h_ */\r\n"},{"name":"FCEvReferenceApplication_private.h","type":"header","group":"model","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * FCEvReferenceApplication_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FCEvReferenceApplication_private_h_\r\n#define RTW_HEADER_FCEvReferenceApplication_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"model_reference_types.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"FCEvReferenceApplication.h\"\r\n#include \"FCEvReferenceApplication_types.h\"\r\n#if !defined(rt_VALIDATE_MEMORY)\r\n#define rt_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(rtS, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n\r\nextern void FCEvReferenceA_PassThrough_Init(real_T rtp_IC,\r\n  B_PassThrough_FCEvReferenceAp_T *localB);\r\nextern void FCEvReference_PassThrough_Start(SimStruct * const rtS_0,\r\n  DW_PassThrough_FCEvReferenceA_T *localDW);\r\nextern void FCEvReferen_PassThrough_Disable(DW_PassThrough_FCEvReferenceA_T\r\n  *localDW);\r\nextern void FCEvReferenceApplic_PassThrough(SimStruct * const rtS_2, boolean_T\r\n  rtu_Enable, real_T rtu_u, B_PassThrough_FCEvReferenceAp_T *localB,\r\n  DW_PassThrough_FCEvReferenceA_T *localDW);\r\n\r\n#if defined(MULTITASKING)\r\n#  error Models using the variable step solvers cannot define MULTITASKING\r\n#endif\r\n#endif                      /* RTW_HEADER_FCEvReferenceApplication_private_h_ */\r\n"},{"name":"FCEvReferenceApplication_types.h","type":"header","group":"model","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * FCEvReferenceApplication_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FCEvReferenceApplication_types_h_\r\n#define RTW_HEADER_FCEvReferenceApplication_types_h_\r\n#ifndef SS_UINT64\r\n#define SS_UINT64                      20\r\n#endif\r\n\r\n#ifndef SS_INT64\r\n#define SS_INT64                       21\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_FCEvReferenceApplication_T_ P_FCEvReferenceApplication_T;\r\n\r\n#endif                        /* RTW_HEADER_FCEvReferenceApplication_types_h_ */\r\n"},{"name":"FCEvReferenceApplication_data.c","type":"source","group":"data","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"数据文件","code":"/*\r\n * FCEvReferenceApplication_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"FCEvReferenceApplication.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_FCEvReferenceApplication_T FCEvReferenceApplication_P = {\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  10000.0,\r\n  4.0,\r\n  160.0,\r\n  1.0,\r\n  0.36,\r\n  9.81,\r\n  1500.0,\r\n  0.1,\r\n  0.12,\r\n  1.0,\r\n  0.0,\r\n  0.0,\r\n  -1.0,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n  3.6,\r\n  1000.0,\r\n  0.0,\r\n  0.0,\r\n  1.0,\r\n  0.0,\r\n  0.0,\r\n  1.0,\r\n  0.0,\r\n  1369.0,\r\n  0.0,\r\n  0.0,\r\n\r\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.3411166666666667, 2.6375294444444441,\r\n    3.8445344444444443, 5.1409472222222226, 6.3926561111111111,\r\n    7.5549572222222219, 7.7337727777777783, 8.09140388888889, 9.253705,\r\n    9.7007438888888888, 10.01367111111111, 10.058375, 9.8795594444444443,\r\n    9.6113361111111111, 9.343112777777776, 9.1195933333333326, 8.85137,\r\n    7.5996611111111108, 6.6608794444444444, 6.6608794444444444,\r\n    6.794991111111111, 6.9291027777777767, 7.152622222222222, 7.644365,\r\n    8.538442777777778, 9.4325205555555556, 10.147782777777778,\r\n    10.237190555555554, 10.147782777777778, 10.10307888888889,\r\n    9.5219283333333333, 8.4937388888888883, 7.644365, 7.0632144444444442,\r\n    7.0632144444444442, 7.9125883333333329, 8.85137, 9.6560399999999991,\r\n    10.371302222222221, 10.81834111111111, 10.997156666666667,\r\n    11.131268333333331, 11.175972222222223, 10.997156666666667,\r\n    10.952452777777777, 11.041860555555555, 11.086564444444445,\r\n    11.041860555555555, 10.997156666666667, 10.997156666666667,\r\n    11.220676111111112, 11.444195555555558, 11.488899444444444,\r\n    11.354787777777776, 11.131268333333331, 11.175972222222223,\r\n    11.354787777777776, 11.623011111111111, 11.623011111111111,\r\n    11.488899444444444, 11.667715, 11.935938333333333, 12.293569444444444,\r\n    12.785312222222222, 13.098239444444445, 13.321758888888889,\r\n    13.455870555555556, 13.589982222222222, 13.724093888888888,\r\n    13.724093888888888, 13.634686111111112, 13.589982222222222,\r\n    13.545278333333332, 13.589982222222222, 13.768797777777777,\r\n    13.589982222222222, 13.366462777777777, 13.187647222222221,\r\n    13.321758888888889, 13.545278333333332, 13.724093888888888,\r\n    13.813501666666665, 13.858205555555553, 13.813501666666665,\r\n    13.589982222222222, 13.321758888888889, 13.366462777777777,\r\n    13.500574444444442, 13.724093888888888, 13.947613333333333,\r\n    14.215836666666666, 14.394652222222222, 14.48406, 14.394652222222222,\r\n    14.171132777777778, 12.785312222222222, 11.310083888888888,\r\n    9.8348555555555546, 8.3596272222222225, 6.8843988888888887,\r\n    5.4091705555555549, 3.9339422222222225, 2.4587138888888886,\r\n    0.98348555555555561, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    1.4752283333333334, 2.9504566666666667, 4.425685, 5.9009133333333335,\r\n    7.3761416666666673, 8.85137, 9.9242633333333323, 10.863045000000001,\r\n    11.533603333333334, 11.801826666666667, 11.488899444444444,\r\n    11.220676111111112, 11.041860555555555, 11.175972222222223, 11.26538,\r\n    11.354787777777776, 11.533603333333334, 12.159457777777778,\r\n    11.846530555555555, 10.728933333333334, 10.147782777777778,\r\n    8.6725544444444438, 7.9125883333333329, 7.6890688888888885, 8.09140388888889,\r\n    8.3149233333333328, 8.940777777777777, 9.9242633333333323,\r\n    10.952452777777777, 12.204161666666666, 13.634686111111112,\r\n    14.975802777777776, 16.182807777777779, 16.674550555555552,\r\n    17.568628333333329, 18.105075, 18.820337222222221, 19.446191666666664,\r\n    20.161453888888886, 20.56378888888889, 20.921419999999998,\r\n    21.234347222222222, 21.234347222222222, 21.144939444444443,\r\n    21.100235555555553, 21.010827777777777, 21.010827777777777,\r\n    21.010827777777777, 21.010827777777777, 21.010827777777777,\r\n    21.100235555555553, 21.189643333333333, 21.413162777777774,\r\n    21.681386111111109, 21.949609444444445, 22.128425, 22.351944444444445,\r\n    22.620167777777777, 22.798983333333332, 23.022502777777778, 23.33543,\r\n    23.782468888888889, 24.18480388888889, 24.408323333333332, 24.542435,\r\n    24.587138888888887, 24.542435, 24.408323333333332, 24.408323333333332,\r\n    24.497731111111108, 24.631842777777777, 24.810658333333333,\r\n    24.900066111111112, 25.078881666666668, 25.168289444444444,\r\n    25.302401111111109, 25.347105, 25.347105, 25.257697222222223,\r\n    25.257697222222223, 25.257697222222223, 25.257697222222223,\r\n    25.257697222222223, 25.257697222222223, 25.21299333333333,\r\n    25.078881666666668, 24.94477, 24.631842777777777, 24.408323333333332,\r\n    24.22950777777778, 24.140099999999997, 24.005988333333335,\r\n    23.961284444444445, 24.095396111111111, 24.140099999999997,\r\n    24.18480388888889, 24.18480388888889, 24.050692222222221, 23.871876666666665,\r\n    23.69306111111111, 23.514245555555558, 23.290726111111113,\r\n    23.424837777777775, 23.246022222222223, 23.201318333333329,\r\n    23.111910555555554, 23.022502777777778, 23.067206666666667,\r\n    23.156614444444443, 23.290726111111113, 23.469541666666668,\r\n    23.69306111111111, 23.916580555555555, 24.140099999999997, 24.542435,\r\n    24.765954444444446, 24.855362222222222, 25.034177777777778,\r\n    25.034177777777778, 24.94477, 24.676546666666667, 24.363619444444442,\r\n    23.961284444444445, 23.469541666666668, 23.022502777777778,\r\n    23.022502777777778, 23.022502777777778, 22.843687222222222,\r\n    22.396648333333331, 22.351944444444445, 22.396648333333331,\r\n    22.351944444444445, 22.17312888888889, 22.128425, 22.128425, 22.128425,\r\n    21.949609444444445, 21.726090000000003, 21.502570555555558,\r\n    21.100235555555553, 20.608492777777776, 20.11675, 19.580303333333333,\r\n    19.043856666666667, 18.55211388888889, 18.01566722222222, 17.210997222222222,\r\n    16.54043888888889, 15.73576888888889, 15.109914444444444, 14.528763888888889,\r\n    14.081724999999999, 13.67939, 13.634686111111112, 13.411166666666666,\r\n    12.964127777777776, 12.293569444444444, 11.086564444444445,\r\n    9.6113361111111111, 8.9854816666666668, 8.538442777777778,\r\n    8.2702194444444448, 7.5996611111111108, 6.9291027777777767,\r\n    5.5879861111111113, 4.8280199999999995, 3.576311111111111,\r\n    2.1010827777777776, 0.62585444444444438, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.44703888888888887, 1.9222672222222221,\r\n    3.3974955555555555, 4.8727238888888893, 6.3479522222222222,\r\n    7.7337727777777783, 8.940777777777777, 10.058375, 10.594821666666666,\r\n    11.26538, 11.891234444444445, 12.561792777777777, 13.411166666666666,\r\n    13.768797777777777, 14.126428888888888, 14.349948333333334,\r\n    14.662875555555553, 15.020506666666666, 15.422841666666667,\r\n    15.467545555555557, 15.601657222222221, 15.556953333333331,\r\n    15.422841666666667, 15.512249444444445, 15.869880555555554, 16.0934, 16.0934,\r\n    16.0934, 16.0934, 16.0934, 16.0934, 16.138103888888889, 16.272215555555555,\r\n    16.316919444444444, 16.272215555555555, 16.0934, 15.691065,\r\n    15.244026111111111, 14.975802777777776, 14.037021111111111,\r\n    12.964127777777776, 11.488899444444444, 10.281894444444445,\r\n    9.0748894444444428, 7.823180555555556, 6.482063888888888, 5.3644666666666669,\r\n    3.8892383333333327, 2.4140099999999998, 0.93878166666666663, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 1.162301111111111, 2.6375294444444441, 4.1127577777777775,\r\n    5.5879861111111113, 7.0632144444444442, 8.538442777777778, 10.01367111111111,\r\n    11.175972222222223, 11.444195555555558, 12.293569444444444,\r\n    12.964127777777776, 13.411166666666666, 13.455870555555556,\r\n    13.411166666666666, 13.277055, 13.098239444444445, 12.87472,\r\n    12.517088888888889, 11.175972222222223, 9.7007438888888888,\r\n    8.225515555555555, 6.7502872222222212, 5.2750588888888883,\r\n    3.7998305555555554, 2.324602222222222, 0.84937388888888887, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 1.4752283333333334, 2.9504566666666667, 4.425685, 5.9009133333333335,\r\n    7.3761416666666673, 8.85137, 10.326598333333335, 11.801826666666667,\r\n    12.427681111111111, 13.008831666666667, 14.081724999999999,\r\n    14.752283333333335, 15.020506666666666, 15.556953333333331, 15.691065,\r\n    15.914584444444444, 16.138103888888889, 16.0934, 16.138103888888889,\r\n    16.182807777777779, 16.0934, 15.959288333333335, 16.0934, 16.0934,\r\n    15.914584444444444, 15.869880555555554, 15.825176666666666,\r\n    15.73576888888889, 15.73576888888889, 15.73576888888889, 15.73576888888889,\r\n    15.73576888888889, 15.73576888888889, 15.646361111111112, 15.691065,\r\n    15.73576888888889, 15.869880555555554, 15.73576888888889, 15.646361111111112,\r\n    15.646361111111112, 15.646361111111112, 15.556953333333331,\r\n    15.467545555555557, 15.422841666666667, 14.975802777777776,\r\n    14.305244444444444, 13.455870555555556, 12.517088888888889,\r\n    11.399491666666666, 10.058375, 8.85137, 7.3761416666666673,\r\n    5.9009133333333335, 4.604500555555556, 3.21868, 1.7881555555555555,\r\n    0.44703888888888887, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.53644666666666663,\r\n    1.5646361111111111, 2.4587138888888886, 2.9057527777777779,\r\n    3.7998305555555554, 4.291573333333333, 4.6939083333333338,\r\n    5.3197627777777781, 6.2585444444444445, 7.152622222222222,\r\n    7.9125883333333329, 8.4937388888888883, 8.9854816666666668,\r\n    9.3878166666666676, 9.8348555555555546, 10.281894444444445,\r\n    10.639525555555556, 10.952452777777777, 11.131268333333331,\r\n    11.175972222222223, 11.175972222222223, 11.175972222222223,\r\n    11.175972222222223, 11.175972222222223, 11.175972222222223,\r\n    11.444195555555558, 11.533603333333334, 11.623011111111111,\r\n    11.444195555555558, 11.26538, 11.175972222222223, 11.175972222222223,\r\n    11.175972222222223, 10.907748888888889, 10.326598333333335, 8.85137,\r\n    7.3761416666666673, 5.9009133333333335, 4.425685, 2.9504566666666667,\r\n    1.4752283333333334, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.4752283333333334, 2.9504566666666667,\r\n    4.425685, 5.8115055555555557, 6.5267677777777777, 7.152622222222222,\r\n    7.5996611111111108, 7.5996611111111108, 7.5996611111111108,\r\n    7.823180555555556, 7.9125883333333329, 7.9125883333333329, 7.823180555555556,\r\n    7.5996611111111108, 7.5549572222222219, 7.4208455555555561,\r\n    7.5996611111111108, 7.644365, 7.5996611111111108, 7.4208455555555561,\r\n    7.3761416666666673, 7.3761416666666673, 7.4208455555555561,\r\n    7.5996611111111108, 7.8678844444444449, 8.2702194444444448,\r\n    8.583146666666666, 9.0301855555555548, 9.3878166666666676,\r\n    9.4325205555555556, 9.4772244444444436, 9.6560399999999991,\r\n    9.8348555555555546, 10.01367111111111, 10.058375, 10.058375, 10.058375,\r\n    10.147782777777778, 10.594821666666666, 11.220676111111112,\r\n    11.623011111111111, 11.846530555555555, 12.070049999999998, 11.667715,\r\n    10.192486666666666, 8.7172583333333336, 7.24203, 5.7668016666666668,\r\n    4.291573333333333, 2.816345, 1.3411166666666667, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.89407777777777775, 2.011675,\r\n    3.4869033333333332, 4.5597966666666663, 5.5879861111111113,\r\n    6.2585444444444445, 6.839695, 7.823180555555556, 8.7619622222222215,\r\n    9.3878166666666676, 9.9242633333333323, 10.416006111111111,\r\n    10.952452777777777, 11.310083888888888, 11.444195555555558,\r\n    11.623011111111111, 11.667715, 11.712418888888887, 11.712418888888887,\r\n    11.801826666666667, 11.846530555555555, 11.846530555555555,\r\n    11.623011111111111, 11.399491666666666, 10.550117777777777,\r\n    9.5666322222222213, 8.2702194444444448, 7.3314377777777766,\r\n    6.482063888888888, 5.1856511111111105, 3.8892383333333327,\r\n    2.5928255555555553, 1.5646361111111111, 0.89407777777777775, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.62585444444444438,\r\n    1.4752283333333334, 1.9669711111111112, 2.9057527777777779,\r\n    4.1127577777777775, 5.0515394444444448, 6.0350249999999992,\r\n    6.5267677777777777, 7.3314377777777766, 7.4655494444444441,\r\n    7.3761416666666673, 7.3761416666666673, 8.1361077777777773,\r\n    8.583146666666666, 8.9854816666666668, 9.6113361111111111, 10.058375,\r\n    10.058375, 9.8795594444444443, 10.147782777777778, 10.416006111111111,\r\n    10.505413888888889, 10.058375, 9.6560399999999991, 9.1642972222222223,\r\n    8.0467, 6.7055833333333332, 5.3644666666666669, 4.02335, 2.7716411111111112,\r\n    2.011675, 1.3411166666666667, 0.93878166666666663, 0.22351944444444444,\r\n    0.22351944444444444, 1.4305244444444447, 2.9057527777777779,\r\n    4.291573333333333, 5.5879861111111113, 6.2585444444444445, 7.152622222222222,\r\n    8.0467, 8.7619622222222215, 9.6113361111111111, 10.326598333333335,\r\n    10.952452777777777, 11.399491666666666, 11.846530555555555,\r\n    12.11475388888889, 12.338273333333333, 12.472385, 12.651200555555555,\r\n    12.785312222222222, 12.785312222222222, 12.651200555555555,\r\n    12.606496666666665, 12.517088888888889, 12.293569444444444,\r\n    11.980642222222222, 11.399491666666666, 10.505413888888889,\r\n    9.6113361111111111, 8.4937388888888883, 7.3761416666666673,\r\n    6.6608794444444444, 5.5879861111111113, 4.2021655555555553,\r\n    2.7716411111111112, 1.3411166666666667, 0.67055833333333337,\r\n    0.67055833333333337, 0.22351944444444444, 0.0, 1.3411166666666667, 2.816345,\r\n    4.291573333333333, 5.7668016666666668, 7.0632144444444442, 7.823180555555556,\r\n    8.225515555555555, 8.7172583333333336, 9.253705, 9.8348555555555546,\r\n    10.371302222222221, 11.175972222222223, 11.846530555555555,\r\n    12.293569444444444, 12.517088888888889, 12.651200555555555,\r\n    12.919423888888888, 12.919423888888888, 12.919423888888888, 12.87472,\r\n    12.740608333333334, 12.651200555555555, 12.651200555555555,\r\n    12.651200555555555, 12.606496666666665, 12.338273333333333,\r\n    12.293569444444444, 12.293569444444444, 12.293569444444444,\r\n    12.293569444444444, 12.293569444444444, 12.293569444444444,\r\n    12.338273333333333, 12.517088888888889, 12.740608333333334,\r\n    13.411166666666666, 13.858205555555553, 14.305244444444444,\r\n    14.752283333333335, 14.752283333333335, 15.020506666666666,\r\n    15.199322222222222, 15.333433888888887, 15.28873, 15.199322222222222,\r\n    15.199322222222222, 15.154618333333332, 15.020506666666666,\r\n    14.796987222222223, 14.752283333333335, 14.528763888888889,\r\n    14.305244444444444, 14.260540555555554, 14.126428888888888,\r\n    14.081724999999999, 13.67939, 13.411166666666666, 13.366462777777777,\r\n    13.366462777777777, 13.366462777777777, 13.366462777777777,\r\n    13.232351111111111, 13.187647222222221, 13.187647222222221,\r\n    13.098239444444445, 12.919423888888888, 12.606496666666665,\r\n    12.382977222222223, 12.070049999999998, 11.399491666666666,\r\n    10.594821666666666, 9.8348555555555546, 9.1642972222222223,\r\n    8.583146666666666, 8.583146666666666, 8.9854816666666668, 9.343112777777776,\r\n    9.5666322222222213, 9.8348555555555546, 10.10307888888889,\r\n    10.371302222222221, 10.728933333333334, 11.175972222222223,\r\n    11.623011111111111, 11.891234444444445, 11.891234444444445,\r\n    11.980642222222222, 12.070049999999998, 12.159457777777778,\r\n    12.427681111111111, 12.561792777777777, 12.87472, 12.919423888888888,\r\n    12.964127777777776, 13.008831666666667, 12.964127777777776,\r\n    12.561792777777777, 12.293569444444444, 12.070049999999998,\r\n    11.533603333333334, 11.175972222222223, 10.952452777777777,\r\n    11.086564444444445, 11.220676111111112, 11.399491666666666,\r\n    11.488899444444444, 11.712418888888887, 12.02534611111111,\r\n    12.293569444444444, 12.427681111111111, 12.695904444444444,\r\n    12.964127777777776, 13.053535555555555, 13.008831666666667,\r\n    12.964127777777776, 12.919423888888888, 12.740608333333334,\r\n    12.561792777777777, 12.517088888888889, 12.517088888888889,\r\n    12.338273333333333, 12.159457777777778, 11.891234444444445,\r\n    12.070049999999998, 12.293569444444444, 12.427681111111111,\r\n    12.517088888888889, 12.427681111111111, 12.517088888888889,\r\n    12.517088888888889, 12.517088888888889, 12.382977222222223,\r\n    12.248865555555554, 12.02534611111111, 11.891234444444445,\r\n    11.846530555555555, 11.846530555555555, 11.846530555555555,\r\n    11.757122777777779, 11.712418888888887, 11.712418888888887,\r\n    11.578307222222222, 11.444195555555558, 11.444195555555558,\r\n    11.578307222222222, 11.533603333333334, 11.399491666666666,\r\n    10.997156666666667, 10.505413888888889, 9.9242633333333323,\r\n    9.6560399999999991, 9.6560399999999991, 9.7007438888888888,\r\n    10.10307888888889, 10.460709999999999, 10.728933333333334, 10.81834111111111,\r\n    10.907748888888889, 11.131268333333331, 11.220676111111112, 11.26538,\r\n    11.310083888888888, 11.399491666666666, 11.26538, 11.175972222222223,\r\n    11.175972222222223, 11.175972222222223, 11.041860555555555,\r\n    10.952452777777777, 10.863045000000001, 10.863045000000001,\r\n    10.952452777777777, 11.175972222222223, 11.175972222222223,\r\n    10.997156666666667, 10.997156666666667, 10.773637222222222,\r\n    10.952452777777777, 11.220676111111112, 11.444195555555558,\r\n    11.220676111111112, 10.728933333333334, 9.8348555555555546,\r\n    8.9854816666666668, 7.5549572222222219, 6.079728888888889, 4.604500555555556,\r\n    3.1292722222222222, 1.6540438888888889, 0.17881555555555559, 0.0, 0.0, 0.0,\r\n    0.89407777777777775, 2.3693061111111109, 3.8445344444444443,\r\n    5.3197627777777781, 6.794991111111111, 7.823180555555556, 8.3149233333333328,\r\n    8.940777777777777, 9.4325205555555556, 9.8348555555555546,\r\n    10.281894444444445, 10.952452777777777, 11.757122777777779,\r\n    12.293569444444444, 12.561792777777777, 12.695904444444444,\r\n    12.740608333333334, 12.740608333333334, 12.740608333333334,\r\n    12.382977222222223, 12.293569444444444, 12.159457777777778,\r\n    11.980642222222222, 11.846530555555555, 11.623011111111111,\r\n    11.488899444444444, 11.26538, 10.728933333333334, 9.8348555555555546,\r\n    9.6113361111111111, 9.6113361111111111, 9.7454477777777786, 10.058375,\r\n    10.281894444444445, 10.192486666666666, 10.192486666666666,\r\n    10.281894444444445, 10.147782777777778, 10.147782777777778,\r\n    10.147782777777778, 10.505413888888889, 10.728933333333334,\r\n    10.997156666666667, 11.086564444444445, 11.220676111111112,\r\n    11.399491666666666, 11.444195555555558, 11.399491666666666,\r\n    11.175972222222223, 10.773637222222222, 10.594821666666666,\r\n    10.371302222222221, 10.237190555555554, 10.058375, 9.8348555555555546,\r\n    9.6560399999999991, 9.1642972222222223, 7.823180555555556,\r\n    6.3479522222222222, 4.8727238888888893, 3.3974955555555555,\r\n    1.9222672222222221, 0.44703888888888887, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.53644666666666663,\r\n    1.7881555555555555, 3.2633838888888889, 4.7386122222222218,\r\n    6.2138405555555556, 7.5996611111111108, 8.2702194444444448,\r\n    8.940777777777777, 9.7454477777777786, 10.281894444444445,\r\n    10.728933333333334, 11.086564444444445, 11.444195555555558,\r\n    11.846530555555555, 11.980642222222222, 12.248865555555554, 12.472385,\r\n    12.651200555555555, 12.517088888888889, 12.293569444444444,\r\n    12.070049999999998, 12.070049999999998, 11.757122777777779,\r\n    10.952452777777777, 10.058375, 9.6113361111111111, 9.2090011111111121,\r\n    8.0467, 6.7055833333333332, 5.4985783333333336, 4.9621316666666662,\r\n    4.7386122222222218, 4.4703888888888885, 4.2468694444444441,\r\n    4.0680538888888886, 3.8892383333333327, 3.8445344444444443,\r\n    3.9339422222222225, 4.02335, 3.8892383333333327, 3.8445344444444443,\r\n    3.576311111111111, 3.1292722222222222, 2.2351944444444443,\r\n    1.8775633333333333, 1.162301111111111, 0.44703888888888887, 0.0,\r\n    0.0447038888888889, 0.26822333333333331, 0.71526222222222235, 1.60934,\r\n    3.0845683333333334, 4.4703888888888885, 5.7220977777777788,\r\n    6.2585444444444445, 6.482063888888888, 7.152622222222222, 8.09140388888889,\r\n    8.940777777777777, 9.3878166666666676, 9.4772244444444436,\r\n    9.5219283333333333, 9.5666322222222213, 9.7007438888888888, 10.058375,\r\n    10.281894444444445, 10.639525555555556, 10.952452777777777,\r\n    11.175972222222223, 11.131268333333331, 11.086564444444445,\r\n    11.175972222222223, 11.354787777777776, 11.533603333333334,\r\n    11.623011111111111, 11.801826666666667, 11.891234444444445,\r\n    12.02534611111111, 12.070049999999998, 12.070049999999998,\r\n    12.070049999999998, 12.02534611111111, 11.980642222222222,\r\n    11.980642222222222, 11.846530555555555, 11.801826666666667,\r\n    11.623011111111111, 11.399491666666666, 10.997156666666667,\r\n    10.505413888888889, 9.6113361111111111, 8.940777777777777, 7.823180555555556,\r\n    7.152622222222222, 6.2585444444444445, 4.7833161111111107,\r\n    3.3080877777777777, 1.8328594444444442, 0.35763111111111118, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.93878166666666663, 2.4140099999999998, 3.8892383333333327,\r\n    5.3644666666666669, 6.839695, 8.3149233333333328, 9.4325205555555556,\r\n    10.281894444444445, 10.505413888888889, 10.281894444444445, 10.058375,\r\n    8.940777777777777, 7.4655494444444441, 5.9903211111111112,\r\n    4.5150927777777774, 3.0398644444444445, 1.5646361111111111,\r\n    0.0894077777777778, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0894077777777778, 0.67055833333333337, 1.5646361111111111,\r\n    2.9057527777777779, 4.3809811111111108, 5.3644666666666669,\r\n    5.7668016666666668, 5.8115055555555557, 5.63269, 5.7220977777777788,\r\n    5.8562094444444437, 5.8562094444444437, 6.2585444444444445,\r\n    6.9291027777777767, 7.5996611111111108, 8.3149233333333328,\r\n    8.8066661111111113, 9.3878166666666676, 9.6113361111111111,\r\n    9.7454477777777786, 9.7454477777777786, 9.6113361111111111,\r\n    9.4772244444444436, 9.6113361111111111, 9.7454477777777786,\r\n    9.8348555555555546, 9.7901516666666666, 9.7007438888888888,\r\n    9.6113361111111111, 9.6113361111111111, 9.5666322222222213,\r\n    8.9854816666666668, 8.7172583333333336, 8.583146666666666,\r\n    8.7619622222222215, 8.85137, 8.940777777777777, 8.7172583333333336,\r\n    7.823180555555556, 6.9291027777777767, 5.8115055555555557,\r\n    4.4703888888888885, 3.576311111111111, 2.6822333333333335,\r\n    1.7881555555555555, 1.1175972222222221, 0.31292722222222219, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.44703888888888887, 0.44703888888888887,\r\n    0.44703888888888887, 0.44703888888888887, 0.44703888888888887,\r\n    0.71526222222222235, 1.3411166666666667, 1.7881555555555555,\r\n    2.2351944444444443, 2.816345, 3.576311111111111, 4.4703888888888885,\r\n    4.6939083333333338, 4.2468694444444441, 3.7998305555555554,\r\n    3.3974955555555555, 3.9339422222222225, 4.9174277777777773,\r\n    6.2585444444444445, 7.5996611111111108, 8.7172583333333336,\r\n    9.3878166666666676, 9.7454477777777786, 9.9242633333333323,\r\n    10.281894444444445, 10.550117777777777, 10.773637222222222,\r\n    10.952452777777777, 10.952452777777777, 10.728933333333334,\r\n    10.505413888888889, 10.505413888888889, 10.505413888888889,\r\n    10.505413888888889, 10.505413888888889, 10.505413888888889,\r\n    10.728933333333334, 10.773637222222222, 10.952452777777777,\r\n    11.041860555555555, 11.175972222222223, 11.354787777777776,\r\n    11.444195555555558, 11.488899444444444, 11.623011111111111,\r\n    11.712418888888887, 12.070049999999998, 12.427681111111111,\r\n    12.651200555555555, 12.964127777777776, 13.008831666666667,\r\n    12.964127777777776, 12.517088888888889, 11.041860555555555,\r\n    9.5666322222222213, 8.09140388888889, 6.6161755555555555, 5.1409472222222226,\r\n    3.6657188888888883, 2.1904905555555554, 0.71526222222222235, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.67055833333333337, 2.1457866666666665,\r\n    3.621015, 5.0962433333333328, 5.9009133333333335, 6.7502872222222212,\r\n    7.510253333333333, 8.180811666666667, 8.7172583333333336, 9.0748894444444428,\r\n    9.5219283333333333, 9.7901516666666666, 9.8795594444444443,\r\n    10.01367111111111, 9.8348555555555546, 9.6560399999999991,\r\n    9.4325205555555556, 9.1642972222222223, 8.940777777777777,\r\n    8.7619622222222215, 8.2702194444444448, 7.823180555555556,\r\n    7.3761416666666673, 6.9291027777777767, 6.2585444444444445,\r\n    4.9174277777777773, 3.576311111111111, 2.324602222222222, 1.1175972222222221,\r\n    0.0, 0.0, 0.0 },\r\n\r\n  { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0,\r\n    14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0,\r\n    27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0,\r\n    40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0,\r\n    53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0,\r\n    66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0,\r\n    79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0,\r\n    92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0, 101.0, 102.0, 103.0,\r\n    104.0, 105.0, 106.0, 107.0, 108.0, 109.0, 110.0, 111.0, 112.0, 113.0, 114.0,\r\n    115.0, 116.0, 117.0, 118.0, 119.0, 120.0, 121.0, 122.0, 123.0, 124.0, 125.0,\r\n    126.0, 127.0, 128.0, 129.0, 130.0, 131.0, 132.0, 133.0, 134.0, 135.0, 136.0,\r\n    137.0, 138.0, 139.0, 140.0, 141.0, 142.0, 143.0, 144.0, 145.0, 146.0, 147.0,\r\n    148.0, 149.0, 150.0, 151.0, 152.0, 153.0, 154.0, 155.0, 156.0, 157.0, 158.0,\r\n    159.0, 160.0, 161.0, 162.0, 163.0, 164.0, 165.0, 166.0, 167.0, 168.0, 169.0,\r\n    170.0, 171.0, 172.0, 173.0, 174.0, 175.0, 176.0, 177.0, 178.0, 179.0, 180.0,\r\n    181.0, 182.0, 183.0, 184.0, 185.0, 186.0, 187.0, 188.0, 189.0, 190.0, 191.0,\r\n    192.0, 193.0, 194.0, 195.0, 196.0, 197.0, 198.0, 199.0, 200.0, 201.0, 202.0,\r\n    203.0, 204.0, 205.0, 206.0, 207.0, 208.0, 209.0, 210.0, 211.0, 212.0, 213.0,\r\n    214.0, 215.0, 216.0, 217.0, 218.0, 219.0, 220.0, 221.0, 222.0, 223.0, 224.0,\r\n    225.0, 226.0, 227.0, 228.0, 229.0, 230.0, 231.0, 232.0, 233.0, 234.0, 235.0,\r\n    236.0, 237.0, 238.0, 239.0, 240.0, 241.0, 242.0, 243.0, 244.0, 245.0, 246.0,\r\n    247.0, 248.0, 249.0, 250.0, 251.0, 252.0, 253.0, 254.0, 255.0, 256.0, 257.0,\r\n    258.0, 259.0, 260.0, 261.0, 262.0, 263.0, 264.0, 265.0, 266.0, 267.0, 268.0,\r\n    269.0, 270.0, 271.0, 272.0, 273.0, 274.0, 275.0, 276.0, 277.0, 278.0, 279.0,\r\n    280.0, 281.0, 282.0, 283.0, 284.0, 285.0, 286.0, 287.0, 288.0, 289.0, 290.0,\r\n    291.0, 292.0, 293.0, 294.0, 295.0, 296.0, 297.0, 298.0, 299.0, 300.0, 301.0,\r\n    302.0, 303.0, 304.0, 305.0, 306.0, 307.0, 308.0, 309.0, 310.0, 311.0, 312.0,\r\n    313.0, 314.0, 315.0, 316.0, 317.0, 318.0, 319.0, 320.0, 321.0, 322.0, 323.0,\r\n    324.0, 325.0, 326.0, 327.0, 328.0, 329.0, 330.0, 331.0, 332.0, 333.0, 334.0,\r\n    335.0, 336.0, 337.0, 338.0, 339.0, 340.0, 341.0, 342.0, 343.0, 344.0, 345.0,\r\n    346.0, 347.0, 348.0, 349.0, 350.0, 351.0, 352.0, 353.0, 354.0, 355.0, 356.0,\r\n    357.0, 358.0, 359.0, 360.0, 361.0, 362.0, 363.0, 364.0, 365.0, 366.0, 367.0,\r\n    368.0, 369.0, 370.0, 371.0, 372.0, 373.0, 374.0, 375.0, 376.0, 377.0, 378.0,\r\n    379.0, 380.0, 381.0, 382.0, 383.0, 384.0, 385.0, 386.0, 387.0, 388.0, 389.0,\r\n    390.0, 391.0, 392.0, 393.0, 394.0, 395.0, 396.0, 397.0, 398.0, 399.0, 400.0,\r\n    401.0, 402.0, 403.0, 404.0, 405.0, 406.0, 407.0, 408.0, 409.0, 410.0, 411.0,\r\n    412.0, 413.0, 414.0, 415.0, 416.0, 417.0, 418.0, 419.0, 420.0, 421.0, 422.0,\r\n    423.0, 424.0, 425.0, 426.0, 427.0, 428.0, 429.0, 430.0, 431.0, 432.0, 433.0,\r\n    434.0, 435.0, 436.0, 437.0, 438.0, 439.0, 440.0, 441.0, 442.0, 443.0, 444.0,\r\n    445.0, 446.0, 447.0, 448.0, 449.0, 450.0, 451.0, 452.0, 453.0, 454.0, 455.0,\r\n    456.0, 457.0, 458.0, 459.0, 460.0, 461.0, 462.0, 463.0, 464.0, 465.0, 466.0,\r\n    467.0, 468.0, 469.0, 470.0, 471.0, 472.0, 473.0, 474.0, 475.0, 476.0, 477.0,\r\n    478.0, 479.0, 480.0, 481.0, 482.0, 483.0, 484.0, 485.0, 486.0, 487.0, 488.0,\r\n    489.0, 490.0, 491.0, 492.0, 493.0, 494.0, 495.0, 496.0, 497.0, 498.0, 499.0,\r\n    500.0, 501.0, 502.0, 503.0, 504.0, 505.0, 506.0, 507.0, 508.0, 509.0, 510.0,\r\n    511.0, 512.0, 513.0, 514.0, 515.0, 516.0, 517.0, 518.0, 519.0, 520.0, 521.0,\r\n    522.0, 523.0, 524.0, 525.0, 526.0, 527.0, 528.0, 529.0, 530.0, 531.0, 532.0,\r\n    533.0, 534.0, 535.0, 536.0, 537.0, 538.0, 539.0, 540.0, 541.0, 542.0, 543.0,\r\n    544.0, 545.0, 546.0, 547.0, 548.0, 549.0, 550.0, 551.0, 552.0, 553.0, 554.0,\r\n    555.0, 556.0, 557.0, 558.0, 559.0, 560.0, 561.0, 562.0, 563.0, 564.0, 565.0,\r\n    566.0, 567.0, 568.0, 569.0, 570.0, 571.0, 572.0, 573.0, 574.0, 575.0, 576.0,\r\n    577.0, 578.0, 579.0, 580.0, 581.0, 582.0, 583.0, 584.0, 585.0, 586.0, 587.0,\r\n    588.0, 589.0, 590.0, 591.0, 592.0, 593.0, 594.0, 595.0, 596.0, 597.0, 598.0,\r\n    599.0, 600.0, 601.0, 602.0, 603.0, 604.0, 605.0, 606.0, 607.0, 608.0, 609.0,\r\n    610.0, 611.0, 612.0, 613.0, 614.0, 615.0, 616.0, 617.0, 618.0, 619.0, 620.0,\r\n    621.0, 622.0, 623.0, 624.0, 625.0, 626.0, 627.0, 628.0, 629.0, 630.0, 631.0,\r\n    632.0, 633.0, 634.0, 635.0, 636.0, 637.0, 638.0, 639.0, 640.0, 641.0, 642.0,\r\n    643.0, 644.0, 645.0, 646.0, 647.0, 648.0, 649.0, 650.0, 651.0, 652.0, 653.0,\r\n    654.0, 655.0, 656.0, 657.0, 658.0, 659.0, 660.0, 661.0, 662.0, 663.0, 664.0,\r\n    665.0, 666.0, 667.0, 668.0, 669.0, 670.0, 671.0, 672.0, 673.0, 674.0, 675.0,\r\n    676.0, 677.0, 678.0, 679.0, 680.0, 681.0, 682.0, 683.0, 684.0, 685.0, 686.0,\r\n    687.0, 688.0, 689.0, 690.0, 691.0, 692.0, 693.0, 694.0, 695.0, 696.0, 697.0,\r\n    698.0, 699.0, 700.0, 701.0, 702.0, 703.0, 704.0, 705.0, 706.0, 707.0, 708.0,\r\n    709.0, 710.0, 711.0, 712.0, 713.0, 714.0, 715.0, 716.0, 717.0, 718.0, 719.0,\r\n    720.0, 721.0, 722.0, 723.0, 724.0, 725.0, 726.0, 727.0, 728.0, 729.0, 730.0,\r\n    731.0, 732.0, 733.0, 734.0, 735.0, 736.0, 737.0, 738.0, 739.0, 740.0, 741.0,\r\n    742.0, 743.0, 744.0, 745.0, 746.0, 747.0, 748.0, 749.0, 750.0, 751.0, 752.0,\r\n    753.0, 754.0, 755.0, 756.0, 757.0, 758.0, 759.0, 760.0, 761.0, 762.0, 763.0,\r\n    764.0, 765.0, 766.0, 767.0, 768.0, 769.0, 770.0, 771.0, 772.0, 773.0, 774.0,\r\n    775.0, 776.0, 777.0, 778.0, 779.0, 780.0, 781.0, 782.0, 783.0, 784.0, 785.0,\r\n    786.0, 787.0, 788.0, 789.0, 790.0, 791.0, 792.0, 793.0, 794.0, 795.0, 796.0,\r\n    797.0, 798.0, 799.0, 800.0, 801.0, 802.0, 803.0, 804.0, 805.0, 806.0, 807.0,\r\n    808.0, 809.0, 810.0, 811.0, 812.0, 813.0, 814.0, 815.0, 816.0, 817.0, 818.0,\r\n    819.0, 820.0, 821.0, 822.0, 823.0, 824.0, 825.0, 826.0, 827.0, 828.0, 829.0,\r\n    830.0, 831.0, 832.0, 833.0, 834.0, 835.0, 836.0, 837.0, 838.0, 839.0, 840.0,\r\n    841.0, 842.0, 843.0, 844.0, 845.0, 846.0, 847.0, 848.0, 849.0, 850.0, 851.0,\r\n    852.0, 853.0, 854.0, 855.0, 856.0, 857.0, 858.0, 859.0, 860.0, 861.0, 862.0,\r\n    863.0, 864.0, 865.0, 866.0, 867.0, 868.0, 869.0, 870.0, 871.0, 872.0, 873.0,\r\n    874.0, 875.0, 876.0, 877.0, 878.0, 879.0, 880.0, 881.0, 882.0, 883.0, 884.0,\r\n    885.0, 886.0, 887.0, 888.0, 889.0, 890.0, 891.0, 892.0, 893.0, 894.0, 895.0,\r\n    896.0, 897.0, 898.0, 899.0, 900.0, 901.0, 902.0, 903.0, 904.0, 905.0, 906.0,\r\n    907.0, 908.0, 909.0, 910.0, 911.0, 912.0, 913.0, 914.0, 915.0, 916.0, 917.0,\r\n    918.0, 919.0, 920.0, 921.0, 922.0, 923.0, 924.0, 925.0, 926.0, 927.0, 928.0,\r\n    929.0, 930.0, 931.0, 932.0, 933.0, 934.0, 935.0, 936.0, 937.0, 938.0, 939.0,\r\n    940.0, 941.0, 942.0, 943.0, 944.0, 945.0, 946.0, 947.0, 948.0, 949.0, 950.0,\r\n    951.0, 952.0, 953.0, 954.0, 955.0, 956.0, 957.0, 958.0, 959.0, 960.0, 961.0,\r\n    962.0, 963.0, 964.0, 965.0, 966.0, 967.0, 968.0, 969.0, 970.0, 971.0, 972.0,\r\n    973.0, 974.0, 975.0, 976.0, 977.0, 978.0, 979.0, 980.0, 981.0, 982.0, 983.0,\r\n    984.0, 985.0, 986.0, 987.0, 988.0, 989.0, 990.0, 991.0, 992.0, 993.0, 994.0,\r\n    995.0, 996.0, 997.0, 998.0, 999.0, 1000.0, 1001.0, 1002.0, 1003.0, 1004.0,\r\n    1005.0, 1006.0, 1007.0, 1008.0, 1009.0, 1010.0, 1011.0, 1012.0, 1013.0,\r\n    1014.0, 1015.0, 1016.0, 1017.0, 1018.0, 1019.0, 1020.0, 1021.0, 1022.0,\r\n    1023.0, 1024.0, 1025.0, 1026.0, 1027.0, 1028.0, 1029.0, 1030.0, 1031.0,\r\n    1032.0, 1033.0, 1034.0, 1035.0, 1036.0, 1037.0, 1038.0, 1039.0, 1040.0,\r\n    1041.0, 1042.0, 1043.0, 1044.0, 1045.0, 1046.0, 1047.0, 1048.0, 1049.0,\r\n    1050.0, 1051.0, 1052.0, 1053.0, 1054.0, 1055.0, 1056.0, 1057.0, 1058.0,\r\n    1059.0, 1060.0, 1061.0, 1062.0, 1063.0, 1064.0, 1065.0, 1066.0, 1067.0,\r\n    1068.0, 1069.0, 1070.0, 1071.0, 1072.0, 1073.0, 1074.0, 1075.0, 1076.0,\r\n    1077.0, 1078.0, 1079.0, 1080.0, 1081.0, 1082.0, 1083.0, 1084.0, 1085.0,\r\n    1086.0, 1087.0, 1088.0, 1089.0, 1090.0, 1091.0, 1092.0, 1093.0, 1094.0,\r\n    1095.0, 1096.0, 1097.0, 1098.0, 1099.0, 1100.0, 1101.0, 1102.0, 1103.0,\r\n    1104.0, 1105.0, 1106.0, 1107.0, 1108.0, 1109.0, 1110.0, 1111.0, 1112.0,\r\n    1113.0, 1114.0, 1115.0, 1116.0, 1117.0, 1118.0, 1119.0, 1120.0, 1121.0,\r\n    1122.0, 1123.0, 1124.0, 1125.0, 1126.0, 1127.0, 1128.0, 1129.0, 1130.0,\r\n    1131.0, 1132.0, 1133.0, 1134.0, 1135.0, 1136.0, 1137.0, 1138.0, 1139.0,\r\n    1140.0, 1141.0, 1142.0, 1143.0, 1144.0, 1145.0, 1146.0, 1147.0, 1148.0,\r\n    1149.0, 1150.0, 1151.0, 1152.0, 1153.0, 1154.0, 1155.0, 1156.0, 1157.0,\r\n    1158.0, 1159.0, 1160.0, 1161.0, 1162.0, 1163.0, 1164.0, 1165.0, 1166.0,\r\n    1167.0, 1168.0, 1169.0, 1170.0, 1171.0, 1172.0, 1173.0, 1174.0, 1175.0,\r\n    1176.0, 1177.0, 1178.0, 1179.0, 1180.0, 1181.0, 1182.0, 1183.0, 1184.0,\r\n    1185.0, 1186.0, 1187.0, 1188.0, 1189.0, 1190.0, 1191.0, 1192.0, 1193.0,\r\n    1194.0, 1195.0, 1196.0, 1197.0, 1198.0, 1199.0, 1200.0, 1201.0, 1202.0,\r\n    1203.0, 1204.0, 1205.0, 1206.0, 1207.0, 1208.0, 1209.0, 1210.0, 1211.0,\r\n    1212.0, 1213.0, 1214.0, 1215.0, 1216.0, 1217.0, 1218.0, 1219.0, 1220.0,\r\n    1221.0, 1222.0, 1223.0, 1224.0, 1225.0, 1226.0, 1227.0, 1228.0, 1229.0,\r\n    1230.0, 1231.0, 1232.0, 1233.0, 1234.0, 1235.0, 1236.0, 1237.0, 1238.0,\r\n    1239.0, 1240.0, 1241.0, 1242.0, 1243.0, 1244.0, 1245.0, 1246.0, 1247.0,\r\n    1248.0, 1249.0, 1250.0, 1251.0, 1252.0, 1253.0, 1254.0, 1255.0, 1256.0,\r\n    1257.0, 1258.0, 1259.0, 1260.0, 1261.0, 1262.0, 1263.0, 1264.0, 1265.0,\r\n    1266.0, 1267.0, 1268.0, 1269.0, 1270.0, 1271.0, 1272.0, 1273.0, 1274.0,\r\n    1275.0, 1276.0, 1277.0, 1278.0, 1279.0, 1280.0, 1281.0, 1282.0, 1283.0,\r\n    1284.0, 1285.0, 1286.0, 1287.0, 1288.0, 1289.0, 1290.0, 1291.0, 1292.0,\r\n    1293.0, 1294.0, 1295.0, 1296.0, 1297.0, 1298.0, 1299.0, 1300.0, 1301.0,\r\n    1302.0, 1303.0, 1304.0, 1305.0, 1306.0, 1307.0, 1308.0, 1309.0, 1310.0,\r\n    1311.0, 1312.0, 1313.0, 1314.0, 1315.0, 1316.0, 1317.0, 1318.0, 1319.0,\r\n    1320.0, 1321.0, 1322.0, 1323.0, 1324.0, 1325.0, 1326.0, 1327.0, 1328.0,\r\n    1329.0, 1330.0, 1331.0, 1332.0, 1333.0, 1334.0, 1335.0, 1336.0, 1337.0,\r\n    1338.0, 1339.0, 1340.0, 1341.0, 1342.0, 1343.0, 1344.0, 1345.0, 1346.0,\r\n    1347.0, 1348.0, 1349.0, 1350.0, 1351.0, 1352.0, 1353.0, 1354.0, 1355.0,\r\n    1356.0, 1357.0, 1358.0, 1359.0, 1360.0, 1361.0, 1362.0, 1363.0, 1364.0,\r\n    1365.0, 1366.0, 1367.0, 1368.0, 1369.0 },\r\n  0.0,\r\n  0.0,\r\n  0.001,\r\n  0.0,\r\n  0.0,\r\n  0.001,\r\n  0.5,\r\n  0.0,\r\n  0.0,\r\n  0.0,\r\n\r\n  { 0.0, 0.0 },\r\n  -1000.0,\r\n  1000.0,\r\n  0.0,\r\n  0.0,\r\n  2.23694,\r\n  9.5492965855137211,\r\n  0.0,\r\n  0.000621371,\r\n  0.0,\r\n  264.172,\r\n  0.0,\r\n  0.001,\r\n  1.0E-5,\r\n  0.0,\r\n  0.001,\r\n  1000.0,\r\n  1000.0,\r\n  33.7,\r\n  3600.0,\r\n  0.98911968348170143,\r\n  0.00378541,\r\n  1.0\r\n};\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * builtin_typeid_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,\r\n  SS_SINGLE = 1,\r\n  SS_INT8 = 2,\r\n  SS_UINT8 = 3,\r\n  SS_INT16 = 4,\r\n  SS_UINT16 = 5,\r\n  SS_INT32 = 6,\r\n  SS_UINT32 = 7,\r\n  SS_BOOLEAN = 8\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int DTypeId;\r\n\r\n/* Enumeration of pre-defined data types */\r\ntypedef enum {\r\n  SS_FCN_CALL = 9,\r\n  SS_INTEGER = 10,\r\n  SS_POINTER = 11,\r\n  SS_INTERNAL_DTYPE2 = 12,\r\n  SS_TIMER_UINT32_PAIR = 13,\r\n  SS_CONNECTION_TYPE = 14\r\n} PreDefinedDTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n"},{"name":"log2_tqJQ4MCN.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * log2_tqJQ4MCN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"log2_tqJQ4MCN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <math.h>\r\n#include \"rtGetInf.h\"\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nreal_T log2_tqJQ4MCN(real_T x)\r\n{\r\n  real_T f;\r\n  int32_T inte;\r\n  if (x == 0.0) {\r\n    f = (rtMinusInf);\r\n  } else if ((!rtIsInf(x)) && (!rtIsNaN(x))) {\r\n    real_T t;\r\n    t = frexp(x, &inte);\r\n    if (t == 0.5) {\r\n      f = (real_T)inte - 1.0;\r\n    } else if ((inte == 1) && (t < 0.75)) {\r\n      f = log(2.0 * t) / 0.69314718055994529;\r\n    } else {\r\n      f = log(t) / 0.69314718055994529 + (real_T)inte;\r\n    }\r\n  } else {\r\n    f = x;\r\n  }\r\n\r\n  return f;\r\n}\r\n"},{"name":"log2_tqJQ4MCN.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * log2_tqJQ4MCN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_log2_tqJQ4MCN_h_\r\n#define RTW_HEADER_log2_tqJQ4MCN_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern real_T log2_tqJQ4MCN(real_T x);\r\n\r\n#endif                                 /* RTW_HEADER_log2_tqJQ4MCN_h_ */\r\n"},{"name":"look1_pbinlcapw.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * look1_pbinlcapw.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"look1_pbinlcapw.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nreal_T look1_pbinlcapw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T prevIndex[], uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T y;\r\n  uint32_T bpIdx;\r\n\r\n  /* Column-major Lookup 1-D\r\n     Search method: 'binary'\r\n     Use previous index: 'on'\r\n     Interpolation method: 'Linear point-slope'\r\n     Extrapolation method: 'Clip'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Extrapolation method: 'Clip'\r\n     Use previous index: 'on'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u0 <= bp0[0U]) {\r\n    bpIdx = 0U;\r\n    frac = 0.0;\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T found;\r\n    uint32_T iLeft;\r\n    uint32_T iRght;\r\n\r\n    /* Binary Search using Previous Index */\r\n    bpIdx = prevIndex[0U];\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    found = 0U;\r\n    while (found == 0U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx - 1U;\r\n        bpIdx = ((bpIdx + iLeft) - 1U) >> 1U;\r\n      } else if (u0 < bp0[bpIdx + 1U]) {\r\n        found = 1U;\r\n      } else {\r\n        iLeft = bpIdx + 1U;\r\n        bpIdx = ((bpIdx + iRght) + 1U) >> 1U;\r\n      }\r\n    }\r\n\r\n    frac = (u0 - bp0[bpIdx]) / (bp0[bpIdx + 1U] - bp0[bpIdx]);\r\n  } else {\r\n    bpIdx = maxIndex;\r\n    frac = 0.0;\r\n  }\r\n\r\n  prevIndex[0U] = bpIdx;\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Overflow mode: 'portable wrapping'\r\n   */\r\n  if (bpIdx == maxIndex) {\r\n    y = table[bpIdx];\r\n  } else {\r\n    real_T yL_0d0;\r\n    yL_0d0 = table[bpIdx];\r\n    y = (table[bpIdx + 1U] - yL_0d0) * frac + yL_0d0;\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"look1_pbinlcapw.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * look1_pbinlcapw.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_look1_pbinlcapw_h_\r\n#define RTW_HEADER_look1_pbinlcapw_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern real_T look1_pbinlcapw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T prevIndex[], uint32_T maxIndex);\r\n\r\n#endif                                 /* RTW_HEADER_look1_pbinlcapw_h_ */\r\n"},{"name":"model_reference_types.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * model_reference_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef MODEL_REFERENCE_TYPES_H\r\n#define MODEL_REFERENCE_TYPES_H\r\n#include \"rtwtypes.h\"\r\n#ifndef MODEL_REFERENCE_TYPES\r\n#define MODEL_REFERENCE_TYPES\r\n\r\n/*===========================================================================*\r\n * Model reference type definitions                                          *\r\n *===========================================================================*/\r\n/*\r\n * This structure is used by model reference to\r\n * communicate timing information through the hierarchy.\r\n */\r\ntypedef struct _rtTimingBridge_tag rtTimingBridge;\r\nstruct _rtTimingBridge_tag {\r\n  uint32_T nTasks;\r\n  uint32_T** clockTick;\r\n  uint32_T** clockTickH;\r\n  uint32_T* taskCounter;\r\n  real_T** taskTime;\r\n  boolean_T** rateTransition;\r\n  boolean_T *firstInitCond;\r\n};\r\n\r\n/*\r\n * This structure is used by model reference to\r\n * communicate variable discrete rate timing information through the hierarchy.\r\n */\r\ntypedef struct _rtCtrlRateMdlRefTiming_tag rtCtrlRateMdlRefTiming;\r\nstruct _rtCtrlRateMdlRefTiming_tag {\r\n  uint32_T firstCtrlRateTID;\r\n  uint32_T* numTicksToNextHitForCtrlRate;\r\n};\r\n\r\n#endif                                 /* MODEL_REFERENCE_TYPES */\r\n#endif                                 /* MODEL_REFERENCE_TYPES_H */\r\n"},{"name":"multiword_types.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"norm_7x8GXtWF.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * norm_7x8GXtWF.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"norm_7x8GXtWF.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nreal_T norm_7x8GXtWF(const real_T x[4])\r\n{\r\n  real_T y;\r\n  int32_T j;\r\n  boolean_T exitg1;\r\n  y = 0.0;\r\n  j = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (j < 2)) {\r\n    real_T s;\r\n    int32_T s_tmp;\r\n    s_tmp = j << 1;\r\n    s = fabs(x[s_tmp + 1]) + fabs(x[s_tmp]);\r\n    if (rtIsNaN(s)) {\r\n      y = (rtNaN);\r\n      exitg1 = true;\r\n    } else {\r\n      if (s > y) {\r\n        y = s;\r\n      }\r\n\r\n      j++;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"norm_7x8GXtWF.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * norm_7x8GXtWF.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_norm_7x8GXtWF_h_\r\n#define RTW_HEADER_norm_7x8GXtWF_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern real_T norm_7x8GXtWF(const real_T x[4]);\r\n\r\n#endif                                 /* RTW_HEADER_norm_7x8GXtWF_h_ */\r\n"},{"name":"recomputeBlockDiag_NxbsuIUb.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * recomputeBlockDiag_NxbsuIUb.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"recomputeBlockDiag_NxbsuIUb.h\"\r\n#include <math.h>\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nvoid recomputeBlockDiag_NxbsuIUb(const real_T A[4], real_T F[4], int32_T\r\n  blockFormat)\r\n{\r\n  if (blockFormat == 1) {\r\n    real_T delta;\r\n    real_T expa;\r\n    real_T sinchdelta;\r\n    delta = exp(A[0]);\r\n    expa = exp(A[3]);\r\n    sinchdelta = (A[0] + A[3]) / 2.0;\r\n    if (fmax(sinchdelta, fabs(A[0] - A[3]) / 2.0) < 709.782712893384) {\r\n      real_T x;\r\n      x = (A[3] - A[0]) / 2.0;\r\n      if (x == 0.0) {\r\n        x = 1.0;\r\n      } else {\r\n        x = sinh(x) / x;\r\n      }\r\n\r\n      F[2] = A[2] * exp(sinchdelta) * x;\r\n    } else {\r\n      F[2] = (expa - delta) * A[2] / (A[3] - A[0]);\r\n    }\r\n\r\n    F[0] = delta;\r\n    F[3] = expa;\r\n  } else {\r\n    real_T delta;\r\n    real_T expa;\r\n    real_T sinchdelta;\r\n    delta = sqrt(fabs(A[1] * A[2]));\r\n    expa = exp(A[0]);\r\n    if (delta == 0.0) {\r\n      sinchdelta = 1.0;\r\n    } else {\r\n      sinchdelta = sin(delta) / delta;\r\n    }\r\n\r\n    F[0] = expa * cos(delta);\r\n    F[1] = expa * A[1] * sinchdelta;\r\n    F[2] = expa * A[2] * sinchdelta;\r\n    F[3] = F[0];\r\n  }\r\n}\r\n"},{"name":"recomputeBlockDiag_NxbsuIUb.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * recomputeBlockDiag_NxbsuIUb.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_recomputeBlockDiag_NxbsuIUb_h_\r\n#define RTW_HEADER_recomputeBlockDiag_NxbsuIUb_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern void recomputeBlockDiag_NxbsuIUb(const real_T A[4], real_T F[4], int32_T\r\n  blockFormat);\r\n\r\n#endif                           /* RTW_HEADER_recomputeBlockDiag_NxbsuIUb_h_ */\r\n"},{"name":"rtGetInf.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rtGetInf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rtGetNaN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_assert.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_assert.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_assert_h_\r\n#define RTW_HEADER_rt_assert_h_\r\n\r\n/*=========*\r\n * Asserts *\r\n *=========*/\r\n#ifndef utAssert\r\n#if defined(DOASSERTS)\r\n#if !defined(PRINT_ASSERTS)\r\n#include <assert.h>\r\n#define utAssert(exp)                  assert(exp)\r\n#else\r\n#include <stdio.h>\r\n\r\nstatic void _assert(char *statement, char *file, int line)\r\n{\r\n  printf(\"%s in %s on line %d\\n\", statement, file, line);\r\n}\r\n\r\n#define utAssert(_EX)                  ((_EX) ? (void)0 : _assert(#_EX, __FILE__, __LINE__))\r\n#endif\r\n\r\n#else\r\n#define utAssert(exp)                                            /* do nothing */\r\n#endif\r\n#endif\r\n#endif                                 /* RTW_HEADER_rt_assert_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_defines.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_defines_h_\r\n#define RTW_HEADER_rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_hypotd_snf.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_hypotd_snf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_hypotd_snf.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\nreal_T rt_hypotd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T a;\r\n  real_T b;\r\n  real_T y;\r\n  a = fabs(u0);\r\n  b = fabs(u1);\r\n  if (a < b) {\r\n    a /= b;\r\n    y = sqrt(a * a + 1.0) * b;\r\n  } else if (a > b) {\r\n    b /= a;\r\n    y = sqrt(b * b + 1.0) * a;\r\n  } else if (rtIsNaN(b)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    y = a * 1.4142135623730951;\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"rt_hypotd_snf.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_hypotd_snf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_hypotd_snf_h_\r\n#define RTW_HEADER_rt_hypotd_snf_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern real_T rt_hypotd_snf(real_T u0, real_T u1);\r\n\r\n#endif                                 /* RTW_HEADER_rt_hypotd_snf_h_ */\r\n"},{"name":"rt_modd_snf.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_modd_snf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_modd_snf.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <math.h>\r\n#include <float.h>\r\n#include \"rtGetNaN.h\"\r\n\r\nreal_T rt_modd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  y = u0;\r\n  if (u1 == 0.0) {\r\n    if (u0 == 0.0) {\r\n      y = u1;\r\n    }\r\n  } else if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (u0 == 0.0) {\r\n    y = 0.0 / u1;\r\n  } else if (rtIsInf(u1)) {\r\n    if ((u1 < 0.0) != (u0 < 0.0)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    boolean_T yEq;\r\n    y = fmod(u0, u1);\r\n    yEq = (y == 0.0);\r\n    if ((!yEq) && (u1 > floor(u1))) {\r\n      real_T q;\r\n      q = fabs(u0 / u1);\r\n      yEq = !(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0;\r\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"rt_modd_snf.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_modd_snf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_modd_snf_h_\r\n#define RTW_HEADER_rt_modd_snf_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern real_T rt_modd_snf(real_T u0, real_T u1);\r\n\r\n#endif                                 /* RTW_HEADER_rt_modd_snf_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rt_powd_snf.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_powd_snf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n * Created for block: DrivetrainEv\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_powd_snf.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <math.h>\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n\r\nreal_T rt_powd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    real_T tmp;\r\n    real_T tmp_0;\r\n    tmp = fabs(u0);\r\n    tmp_0 = fabs(u1);\r\n    if (rtIsInf(u1)) {\r\n      if (tmp == 1.0) {\r\n        y = 1.0;\r\n      } else if (tmp > 1.0) {\r\n        if (u1 > 0.0) {\r\n          y = (rtInf);\r\n        } else {\r\n          y = 0.0;\r\n        }\r\n      } else if (u1 > 0.0) {\r\n        y = 0.0;\r\n      } else {\r\n        y = (rtInf);\r\n      }\r\n    } else if (tmp_0 == 0.0) {\r\n      y = 1.0;\r\n    } else if (tmp_0 == 1.0) {\r\n      if (u1 > 0.0) {\r\n        y = u0;\r\n      } else {\r\n        y = 1.0 / u0;\r\n      }\r\n    } else if (u1 == 2.0) {\r\n      y = u0 * u0;\r\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\r\n      y = sqrt(u0);\r\n    } else if ((u0 < 0.0) && (u1 > floor(u1))) {\r\n      y = (rtNaN);\r\n    } else {\r\n      y = pow(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"rt_powd_snf.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rt_powd_snf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n * Created for block: DrivetrainEv\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_powd_snf_h_\r\n#define RTW_HEADER_rt_powd_snf_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern real_T rt_powd_snf(real_T u0, real_T u1);\r\n\r\n#endif                                 /* RTW_HEADER_rt_powd_snf_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"xhseqr_f1Jkm75w.c","type":"source","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * xhseqr_f1Jkm75w.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"xhseqr_f1Jkm75w.h\"\r\n#include <math.h>\r\n#include \"rt_hypotd_snf.h\"\r\n\r\n/* Function for MATLAB Function: '<S25>/Vehicle' */\r\nint32_T xhseqr_f1Jkm75w(real_T h[4], real_T z[4])\r\n{\r\n  int32_T i;\r\n  int32_T info;\r\n  info = 0;\r\n  i = 1;\r\n  while (i + 1 >= 1) {\r\n    real_T aa;\r\n    real_T ab;\r\n    real_T ba;\r\n    real_T htmp1;\r\n    real_T htmp2;\r\n    int32_T k;\r\n    boolean_T exitg1;\r\n    k = i + 1;\r\n    exitg1 = false;\r\n    while ((!exitg1) && (k > 1)) {\r\n      htmp1 = fabs(h[1]);\r\n      if (htmp1 <= 2.0041683600089728E-292) {\r\n        exitg1 = true;\r\n      } else {\r\n        aa = fabs(h[3]);\r\n        if (htmp1 <= (fabs(h[0]) + aa) * 2.2204460492503131E-16) {\r\n          htmp1 = fabs(h[1]);\r\n          htmp2 = fabs(h[2]);\r\n          if (htmp1 > htmp2) {\r\n            ab = htmp1;\r\n            ba = htmp2;\r\n          } else {\r\n            ab = htmp2;\r\n            ba = htmp1;\r\n          }\r\n\r\n          htmp1 = aa;\r\n          htmp2 = fabs(h[0] - h[3]);\r\n          if (aa > htmp2) {\r\n            htmp1 = htmp2;\r\n          } else {\r\n            aa = htmp2;\r\n          }\r\n\r\n          htmp2 = aa + ab;\r\n          if (ab / htmp2 * ba <= fmax(2.0041683600089728E-292, aa / htmp2 *\r\n               htmp1 * 2.2204460492503131E-16)) {\r\n            exitg1 = true;\r\n          } else {\r\n            k = 1;\r\n          }\r\n        } else {\r\n          k = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (k > 1) {\r\n      h[1] = 0.0;\r\n    }\r\n\r\n    if ((i + 1 != k) && (k == i)) {\r\n      real_T b_bb;\r\n      real_T p;\r\n      int32_T aa_tmp;\r\n      int32_T p_tmp;\r\n      b_bb = h[0];\r\n      aa_tmp = i << 1;\r\n      aa = h[aa_tmp];\r\n      htmp2 = h[i];\r\n      p_tmp = aa_tmp + i;\r\n      p = h[p_tmp];\r\n      if (h[i] == 0.0) {\r\n        htmp1 = 1.0;\r\n        ab = 0.0;\r\n      } else if (aa == 0.0) {\r\n        htmp1 = 0.0;\r\n        ab = 1.0;\r\n        p = h[0];\r\n        b_bb = h[p_tmp];\r\n        aa = -h[i];\r\n        htmp2 = 0.0;\r\n      } else {\r\n        ba = h[0] - p;\r\n        if ((ba == 0.0) && ((aa < 0.0) != (h[i] < 0.0))) {\r\n          htmp1 = 1.0;\r\n          ab = 0.0;\r\n        } else {\r\n          real_T sab;\r\n          int32_T count;\r\n          int32_T tmp;\r\n          p = 0.5 * ba;\r\n          ab = fmax(fabs(h[aa_tmp]), fabs(h[i]));\r\n          if (!(h[aa_tmp] < 0.0)) {\r\n            count = 1;\r\n          } else {\r\n            count = -1;\r\n          }\r\n\r\n          if (!(h[i] < 0.0)) {\r\n            tmp = 1;\r\n          } else {\r\n            tmp = -1;\r\n          }\r\n\r\n          sab = h[aa_tmp];\r\n          aa = fmin(fabs(sab), fabs(h[i])) * (real_T)count * (real_T)tmp;\r\n          htmp2 = fmax(fabs(p), ab);\r\n          htmp1 = p / htmp2 * p + ab / htmp2 * aa;\r\n          if (htmp1 >= 8.8817841970012523E-16) {\r\n            real_T tau;\r\n            htmp1 = sqrt(htmp2) * sqrt(htmp1);\r\n            if (p < 0.0) {\r\n              htmp1 = -htmp1;\r\n            }\r\n\r\n            htmp1 += p;\r\n            ba = h[p_tmp];\r\n            b_bb = ba + htmp1;\r\n            p = ba - ab / htmp1 * aa;\r\n            tau = rt_hypotd_snf(h[i], htmp1);\r\n            htmp1 /= tau;\r\n            ab = h[i] / tau;\r\n            aa = sab - h[i];\r\n            htmp2 = 0.0;\r\n          } else {\r\n            real_T tau;\r\n            ab = sab + h[i];\r\n            htmp2 = fmax(fabs(ba), fabs(ab));\r\n            count = 0;\r\n            while ((htmp2 >= 7.4428285367870146E+137) && (count <= 20)) {\r\n              ab *= 1.3435752215134178E-138;\r\n              ba *= 1.3435752215134178E-138;\r\n              htmp2 = fmax(fabs(ba), fabs(ab));\r\n              count++;\r\n            }\r\n\r\n            while ((htmp2 <= 1.3435752215134178E-138) && (count <= 20)) {\r\n              ab *= 7.4428285367870146E+137;\r\n              ba *= 7.4428285367870146E+137;\r\n              htmp2 = fmax(fabs(ba), fabs(ab));\r\n              count++;\r\n            }\r\n\r\n            tau = rt_hypotd_snf(ab, ba);\r\n            htmp1 = sqrt((fabs(ab) / tau + 1.0) * 0.5);\r\n            if (!(ab < 0.0)) {\r\n              count = 1;\r\n            } else {\r\n              count = -1;\r\n            }\r\n\r\n            ab = -(0.5 * ba / (tau * htmp1)) * (real_T)count;\r\n            ba = sab * ab + h[0] * htmp1;\r\n            b_bb = sab * htmp1 + -h[0] * ab;\r\n            aa = h[p_tmp];\r\n            p = aa * ab + h[i] * htmp1;\r\n            tau = aa * htmp1 + -h[i] * ab;\r\n            aa = b_bb * htmp1 + tau * ab;\r\n            htmp2 = -ba * ab + p * htmp1;\r\n            ba = ((ba * htmp1 + p * ab) + (-b_bb * ab + tau * htmp1)) * 0.5;\r\n            b_bb = ba;\r\n            p = ba;\r\n            if (htmp2 != 0.0) {\r\n              if (aa != 0.0) {\r\n                if ((aa < 0.0) == (htmp2 < 0.0)) {\r\n                  real_T sac;\r\n                  sab = sqrt(fabs(aa));\r\n                  sac = sqrt(fabs(htmp2));\r\n                  if (!(htmp2 < 0.0)) {\r\n                    p = sab * sac;\r\n                  } else {\r\n                    p = -(sab * sac);\r\n                  }\r\n\r\n                  tau = 1.0 / sqrt(fabs(aa + htmp2));\r\n                  b_bb = ba + p;\r\n                  p = ba - p;\r\n                  aa -= htmp2;\r\n                  htmp2 = 0.0;\r\n                  sab *= tau;\r\n                  tau *= sac;\r\n                  ba = htmp1 * sab - ab * tau;\r\n                  ab = htmp1 * tau + ab * sab;\r\n                  htmp1 = ba;\r\n                }\r\n              } else {\r\n                aa = -htmp2;\r\n                htmp2 = 0.0;\r\n                ba = htmp1;\r\n                htmp1 = -ab;\r\n                ab = ba;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      h[0] = b_bb;\r\n      h[aa_tmp] = aa;\r\n      h[i] = htmp2;\r\n      h[p_tmp] = p;\r\n      if (i + 1 < 2) {\r\n        b_bb = htmp1 * h[2];\r\n        ba = ab * h[2];\r\n        h[2] = b_bb - ba;\r\n        h[2] = b_bb + ba;\r\n      }\r\n\r\n      i = (i - 1) << 1;\r\n      ba = htmp1 * z[i] + ab * z[2];\r\n      z[2] = htmp1 * z[2] - ab * z[i];\r\n      z[i] = ba;\r\n      b_bb = z[i + 1];\r\n      ba = b_bb * htmp1 + ab * z[3];\r\n      z[3] = htmp1 * z[3] - b_bb * ab;\r\n      z[i + 1] = ba;\r\n    }\r\n\r\n    i = k - 2;\r\n  }\r\n\r\n  return info;\r\n}\r\n"},{"name":"xhseqr_f1Jkm75w.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * xhseqr_f1Jkm75w.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n * Created for block: FCEvReferenceApplication\r\n */\r\n\r\n#ifndef RTW_HEADER_xhseqr_f1Jkm75w_h_\r\n#define RTW_HEADER_xhseqr_f1Jkm75w_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\nextern int32_T xhseqr_f1Jkm75w(real_T h[4], real_T z[4]);\r\n\r\n#endif                                 /* RTW_HEADER_xhseqr_f1Jkm75w_h_ */\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"sharedutility","path":"D:\\FCEV_GAIl\\FCEV\\Work\\slprj\\rsim\\_sharedutils","tag":"","groupDisplay":"共享文件","code":"/*\r\n * zero_crossing_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"DrivetrainEv\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:19:21 2023\r\n */\r\n\r\n#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/* Trigger directions: falling, either, and rising */\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\n/* Previous state of a trigger signal */\r\ntypedef uint8_T ZCSigState;\r\n\r\n/* Initial value of a trigger zero crossing signal */\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\n/* Current state of a trigger signal */\r\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 }\r\n  ZCEventType;\r\n\r\n#endif                                 /* ZERO_CROSSING_TYPES_H */\r\n"},{"name":"FCEvReferenceApplication_dt.h","type":"header","group":"interface","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"接口文件","code":"/*\r\n * FCEvReferenceApplication_dt.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/* data type size table */\r\nstatic uint_T rtDataTypeSizes[] = {\r\n  sizeof(real_T),\r\n  sizeof(real32_T),\r\n  sizeof(int8_T),\r\n  sizeof(uint8_T),\r\n  sizeof(int16_T),\r\n  sizeof(uint16_T),\r\n  sizeof(int32_T),\r\n  sizeof(uint32_T),\r\n  sizeof(boolean_T),\r\n  sizeof(fcn_call_T),\r\n  sizeof(int_T),\r\n  sizeof(pointer_T),\r\n  sizeof(action_T),\r\n  2*sizeof(uint32_T),\r\n  sizeof(int32_T),\r\n  sizeof(int64_T),\r\n  sizeof(uint64_T),\r\n  sizeof(MdlrefDW_FCEvPowertrainContro_T),\r\n  sizeof(MdlrefDW_DrivetrainEv_T),\r\n  sizeof(MdlrefDW_FCElectricPlant_T),\r\n  sizeof(uint64_T),\r\n  sizeof(int64_T),\r\n  sizeof(uint_T),\r\n  sizeof(char_T),\r\n  sizeof(uchar_T),\r\n  sizeof(time_T)\r\n};\r\n\r\n/* data type name table */\r\nstatic const char_T * rtDataTypeNames[] = {\r\n  \"real_T\",\r\n  \"real32_T\",\r\n  \"int8_T\",\r\n  \"uint8_T\",\r\n  \"int16_T\",\r\n  \"uint16_T\",\r\n  \"int32_T\",\r\n  \"uint32_T\",\r\n  \"boolean_T\",\r\n  \"fcn_call_T\",\r\n  \"int_T\",\r\n  \"pointer_T\",\r\n  \"action_T\",\r\n  \"timer_uint32_pair_T\",\r\n  \"physical_connection\",\r\n  \"int64_T\",\r\n  \"uint64_T\",\r\n  \"MdlrefDW_FCEvPowertrainContro_T\",\r\n  \"MdlrefDW_DrivetrainEv_T\",\r\n  \"MdlrefDW_FCElectricPlant_T\",\r\n  \"uint64_T\",\r\n  \"int64_T\",\r\n  \"uint_T\",\r\n  \"char_T\",\r\n  \"uchar_T\",\r\n  \"time_T\"\r\n};\r\n\r\n/* data type transitions for block I/O structure */\r\nstatic DataTypeTransition rtBTransitions[] = {\r\n  { (char_T *)(&FCEvReferenceApplication_B.MotTrqCmd), 0, 0, 86 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_B.LogicalOperator2), 8, 0, 5 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_B.PassThrough_b.u), 0, 0, 1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_B.PassThrough.u), 0, 0, 1 }\r\n  ,\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.UnitDelay_DSTATE[0]), 0, 0, 40 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.Scope_PWORK.LoggedData), 11, 0, 18 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.m_bpIndex), 7, 0, 1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.Saturation_MODE), 10, 0, 3 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.RateTransition1_semaphoreTaken), 2,\r\n    0, 17 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.is_GearSelect), 3, 0, 2 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.Compare_Mode), 8, 0, 2 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.Drivetrain_InstanceData), 18, 0, 1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.ElectricPlant_InstanceData), 19, 0,\r\n    1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.ElectricPlant_MASS_MATRIX_PR), 6, 0,\r\n    1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.PowertrainControlModulePCM_Inst), 17,\r\n    0, 1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.PassThrough_b.PassThrough_MODE), 8,\r\n    0, 1 },\r\n\r\n  { (char_T *)(&FCEvReferenceApplication_DW.PassThrough.PassThrough_MODE), 8, 0,\r\n    1 }\r\n};\r\n\r\n/* data type transition table for block I/O structure */\r\nstatic DataTypeTransitionTable rtBTransTable = {\r\n  17U,\r\n  rtBTransitions\r\n};\r\n\r\n/* data type transitions for Parameters structure */\r\nstatic DataTypeTransition rtPTransitions[] = {\r\n  { (char_T *)(&FCEvReferenceApplication_P.LongitudinalDriverModel_GearIni), 0,\r\n    0, 2810 }\r\n};\r\n\r\n/* data type transition table for Parameters structure */\r\nstatic DataTypeTransitionTable rtPTransTable = {\r\n  1U,\r\n  rtPTransitions\r\n};\r\n\r\n/* [EOF] FCEvReferenceApplication_dt.h */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"D:\\FCEV_GAIl\\FCEV\\Work\\FCEvReferenceApplication_rsim_rtw","tag":"","groupDisplay":"接口文件","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"FCEvReferenceApplication\".\r\n *\r\n * Model version              : 5.108\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Mon Mar 27 10:44:52 2023\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"FCEvReferenceApplication.h\"\r\n#define GRTINTERFACE                   1\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"E:\\MATLAB_R2022b\\rtw\\c\\src","tag":"","groupDisplay":"其他文件","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};